(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./app/main.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var document = require('global/document');
var window = require('global/window');
var serverCommunication = require('./client-api');

// the actual rigging of the application is done in the router!
var router = require('./router-container');

var AppDispatcher = require('./appdispatcher');
var constants = require('./constants/RouterConstants');

serverCommunication.setup();

// the mission timer gets out sync if losing focus, so resync with server every time the window regains focus
window.onfocus = serverCommunication.askForMissionTime;

// run startup actions - usually only relevant when developing
require('./client-bootstrap').run();

router.run(function (Handler, state) {
    // pass the state down into the RouteHandlers, as that will make
    // the router related properties available on each RH. Taken from Upgrade tips for React Router
    React.render(React.createElement(Handler, state), document.body);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","./client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","./client-bootstrap":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-bootstrap.js","./constants/RouterConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/RouterConstants.js","./router-container":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js","global/document":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/global/document.js","global/window":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/global/window.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/AstroTeamActionCreators.js":[function(require,module,exports){
'use strict';

var Dispatcher = require('../appdispatcher');
var MConstants = require('../constants/MissionConstants');
var AstConstants = require('../constants/AstroTeamConstants');
var MessageActionCreators = require('./MessageActionCreators');
var utils = require('../utils');

// lazy load due to avoid circular dependencies
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
var getServerAPI = lazyRequire('../client-api');
var getMissionAC = lazyRequire('./MissionActionCreators');
// for browserify to work it needs to find these magic strings
require('./MissionActionCreators');
require('../client-api');
var TimerActionCreators = require('./TimerActionCreators');

window.__astActions = module.exports = {

    /* in units per minute */
    setOxygenConsumption: function setOxygenConsumption(units) {
        getServerAPI().setOxygenConsumption(units);
    },

    heartRateRead: function heartRateRead(rate) {
        var text, level;
        if (rate < 90) {
            level = 'info';
            text = 'Fine verdier';
        } else if (rate > 120) {
            text = 'Veldig høye verdier!';
            level = 'danger';
        } else {
            text = 'Ganske høy hjerterytme. Grunn til bekymring?';
            level = 'warning';
        }

        MessageActionCreators.addMessage({ text: text, level: level, duration: 20 });
    },

    startMonitorTask: function startMonitorTask() {

        TimerActionCreators.resetTimer(AstConstants.HEART_RATE_TIMER);
        TimerActionCreators.resetTimer(AstConstants.RESPIRATION_TIMER);
        getMissionAC().startTask('astronaut', 'breathing_timer');
    }

};

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","./MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","./TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

var AppDispatcher = require('../appdispatcher'),
    uuid = require('./../utils').uuid,
    constants = require('../constants/MessageConstants');

var actions = {

    /**
     * @param msg.text the message
     * @param [msg.id] the message id. if not given, one will be created
     * @param [msg.level] same as bootstrap's alert classes: [success, info, warning, danger]
     * @param [msg.duration] {Number} optional duration for transient messages
     *
     * @returns {string} the message id
     */
    addMessage: function addMessage(msg) {
        var id = msg.id;

        if (!id) {
            id = uuid();
            msg.id = id;
        }

        if (!msg.level) {
            msg.level = 'success';
        }

        AppDispatcher.dispatch({
            action: constants.MESSAGE_ADDED,
            data: msg
        });

        if (msg.duration) {
            setTimeout(function () {
                return actions.removeMessage(msg.id);
            }, msg.duration * 1000);
        }

        return id;
    },

    /**
     * msg with default duration of 5 seconds
     * @param msg
     * @param [duration] default of 5 seconds
     *
     * @see #addMessage() for more params
     * @returns {string} the message id
     */
    addTransientMessage: function addTransientMessage(msg) {
        var duration = arguments[1] === undefined ? 5 : arguments[1];

        return actions.addMessage(_Object$assign({ duration: duration }, msg));
    },

    removeMessage: function removeMessage(id) {
        AppDispatcher.dispatch({
            action: constants.REMOVE_MESSAGE,
            data: id
        });
    }

};

// prevent new properties from being added or removed
_Object$freeze(actions);
window.__MessageActions = actions;
module.exports = actions;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MessageConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MessageConstants.js","./../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher'),
    MissionConstants = require('../constants/MissionConstants'),
    router = require('./../router-container');

// lazy load due to circular dependencies
var serverAPI = (function () {
    var api;

    return function () {
        if (!api) {
            api = require('../client-api');
        }
        return api;
    };
})();

var tmp = {

    startMission: function startMission() {
        serverAPI().startMission();
    },

    stopMission: function stopMission() {
        serverAPI().stopMission();
    },

    resetMission: function resetMission() {
        serverAPI().resetMission();
    },

    missionStarted: function missionStarted() {
        AppDispatcher.dispatch({ action: MissionConstants.MISSION_STARTED_EVENT });
    },

    missionStopped: function missionStopped() {
        AppDispatcher.dispatch({ action: MissionConstants.MISSION_STOPPED_EVENT });
    },

    missionWasReset: function missionWasReset() {
        AppDispatcher.dispatch({ action: MissionConstants.MISSION_WAS_RESET });
        serverAPI().askForAppState();
    },

    missionCompleted: function missionCompleted() {
        //AppDispatcher.dispatch({action: MissionConstants.MISSION_COMPLETED_EVENT});
        router.transitionTo('/completed');
    },

    completeMission: function completeMission() {
        serverAPI().completeMission();
    },

    receivedEvents: function receivedEvents(eventsCollection) {
        AppDispatcher.dispatch(_Object$assign({}, eventsCollection, { action: MissionConstants.RECEIVED_EVENTS }));
    },

    askForEvents: function askForEvents() {
        serverAPI().askForEvents();
    },

    introWasRead: function introWasRead(teamId) {
        AppDispatcher.dispatch({ action: MissionConstants.INTRODUCTION_READ, teamName: teamId });
        serverAPI().sendTeamStateChange();
    },

    changeScrubber: function changeScrubber() {
        serverAPI().askToChangeScrubFilter();
    },

    startTask: function startTask(teamId, taskId) {
        AppDispatcher.dispatch({ action: MissionConstants.START_TASK, teamId: teamId, taskId: taskId });
        serverAPI().sendTeamStateChange();
    },

    taskCompleted: function taskCompleted(teamId, taskId) {
        AppDispatcher.dispatch({ action: MissionConstants.COMPLETED_TASK, taskId: taskId, teamId: teamId });
        serverAPI().sendTeamStateChange();

        // also publish this to server as separate event? - maybe to trigger something at certain point?
    },

    askToStartNextChapter: function askToStartNextChapter() {
        serverAPI().askToStartNextChapter();
    },

    askToTriggerEvent: function askToTriggerEvent(uuid) {
        serverAPI().triggerEvent(uuid);
    },

    setMissionTime: function setMissionTime(elapsedSeconds) {
        AppDispatcher.dispatch({
            action: MissionConstants.MISSION_TIME_SYNC,
            data: { elapsedMissionTime: elapsedSeconds }
        });
    }

};

window.__MissionAC = tmp;
module.exports = tmp;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./../router-container":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js":[function(require,module,exports){
'use strict';

var AppDispatcher = require('../appdispatcher');
var RadiationStore = require('./../stores/radiation-store');
var ScienceTeamConstants = require('../constants/ScienceTeamConstants');
var MissionConstants = require('../constants/MissionConstants');
var MessageActionsCreators = require('./MessageActionCreators');
var TimerActionCreators = require('../actions/TimerActionCreators');
var api = require('../client-api');

var missionActionCreators = (function () {
    var tmp;

    return function () {
        if (!tmp) tmp = require('../actions/MissionActionCreators');
        return tmp;
    };
})();

var actions = {

    startSampleTask: function startSampleTask() {
        AppDispatcher.dispatch({ action: ScienceTeamConstants.SCIENCE_CLEAR_RADIATION_SAMPLES });
        missionActionCreators().startTask('science', 'sample');
        this.resetSamplingTimer();
    },

    completeTask: function completeTask(taskId) {
        missionActionCreators().taskCompleted('science', taskId);
    },

    resetSamplingTimer: function resetSamplingTimer() {
        TimerActionCreators.resetTimer(ScienceTeamConstants.SCIENCE_TIMER_1);
    },

    takeRadiationSample: function takeRadiationSample() {
        AppDispatcher.dispatch({
            action: ScienceTeamConstants.SCIENCE_TAKE_RADIATION_SAMPLE
        });
    },

    averageRadiationCalculated: function averageRadiationCalculated(average) {
        var samples = RadiationStore.getSamples();

        if (samples.length) {
            var sum = samples.reduce(function (prev, current) {
                return prev + current;
            }, 0),
                trueCalculatedAverage = sum / samples.length,
                diffInPercent = 100 * Math.abs((trueCalculatedAverage - average) / trueCalculatedAverage);

            if (diffInPercent > 15) {
                MessageActionsCreators.addTransientMessage({ text: 'Mulig det gjennomsnittet ble litt feil.' });
            }
        }

        AppDispatcher.dispatch({
            action: ScienceTeamConstants.SCIENCE_AVG_RADIATION_CALCULATED,
            data: { average: average }
        });

        if (average > ScienceTeamConstants.SCIENCE_AVG_RAD_RED_THRESHOLD) {
            MessageActionsCreators.addTransientMessage({
                text: 'Veldig høyt radioaktivt nivå detektert. Varsle sikkerhetsteamet umiddelbart!',
                level: 'danger',
                id: ScienceTeamConstants.SCIENCE_RADIATION_WARNING_MSG
            }, 30);
        } else if (average > ScienceTeamConstants.SCIENCE_AVG_RAD_ORANGE_THRESHOLD) {
            MessageActionsCreators.addTransientMessage({
                text: 'Høye verdier av radioaktivitet. Følg med på om det går nedover igjen',
                level: 'warning',
                id: ScienceTeamConstants.SCIENCE_RADIATION_WARNING_MSG
            }, 10);
        }

        this.completeTask('average');
    },

    /**
     * Set the radiation level that will be reported to the view layer
     * The reported radiation will generated values in the range given by the parameters
     *
     * We are not actually receiving a stream of values from the server, as that could
     * be very resource heavy. Instead we generate random values between the given values,
     * which to the user will look the same.
     * @param min
     * @param max
     */
    setRadiationLevel: function setRadiationLevel(min, max) {
        AppDispatcher.dispatch({
            action: ScienceTeamConstants.SCIENCE_RADIATION_LEVEL_CHANGED,
            data: { min: min, max: max }
        });
    },

    addToTotalRadiationLevel: function addToTotalRadiationLevel(amount) {

        var total = amount + RadiationStore.getTotalLevel();

        if (total > ScienceTeamConstants.SCIENCE_TOTAL_RADIATION_VERY_SERIOUS_THRESHOLD) {
            MessageActionsCreators.addTransientMessage({
                id: 'science_high_radiation_level',
                text: 'Faretruende høyt strålingsnivå!',
                level: 'danger'
            }, 30);
        } else if (total > ScienceTeamConstants.SCIENCE_TOTAL_RADIATION_SERIOUS_THRESHOLD) {
            MessageActionsCreators.addTransientMessage({
                id: 'science_high_radiation_level',
                text: 'Høyt strålingsnivå!',
                level: 'warning'
            }, 30);
        }

        AppDispatcher.dispatch({
            action: ScienceTeamConstants.SCIENCE_TOTAL_RADIATION_LEVEL_CHANGED,
            data: { total: total, added: amount }
        });

        this.completeTask('addtotal');
    }

};

window.__ScienceActions = actions;
module.exports = actions;

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","./../stores/radiation-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/radiation-store.js","./MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/SecurityTeamActionCreators.js":[function(require,module,exports){
'use strict';

var MessageActionCreators = require('../actions/MessageActionCreators');

// lazy load due to avoid circular dependencies
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
var getMissionAC = lazyRequire('./MissionActionCreators');
var getServerAPI = lazyRequire('../client-api');
// for browserify to work it needs to find these magic strings
require('./MissionActionCreators');
require('../client-api');

var actions = module.exports = {
    startDataTransferCheck: function startDataTransferCheck() {
        getMissionAC().startTask('security', 'signal_test');
    },

    endDataQualityTest: function endDataQualityTest(goodOutcome) {
        if (!goodOutcome) {
            MessageActionCreators.addMessage({
                text: 'Kvaliteten på kommunikasjonssignalet er for dårlig. Er reparasjonen fullført?',
                level: 'warning',
                duration: 10
            });
        } else {
            MessageActionCreators.addMessage({
                text: 'TEST OK', duration: 2, level: 'info'
            });
            actions.sendReadyForSafeMode();
        }
        getMissionAC().taskCompleted('security', 'signal_test');
    },

    endDataTransferTest: function endDataTransferTest(goodOutcome) {
        if (!goodOutcome) {
            MessageActionCreators.addMessage({
                text: 'Overføringen av data var for ustabil. Testen feilet.',
                level: 'warning',
                duration: 10
            });
            getMissionAC().taskCompleted('security', 'signal_test');
        } else {
            MessageActionCreators.addMessage({
                text: 'TEST OK', duration: 2, level: 'info'
            });
        }
    },

    sendReadyForSafeMode: function sendReadyForSafeMode() {
        getServerAPI().setReadyForSafeMode();
    },

    setInSafeMode: function setInSafeMode() {
        getServerAPI().setInSafeMode();
    }
};

window.__SecTeamActions = actions;

},{"../actions/MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","../client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","./MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js":[function(require,module,exports){
'use strict';

var AppDispatcher = require('../appdispatcher');
var constants = require('../constants/TimerConstants');

var actions = {

    startTimer: function startTimer(id) {
        AppDispatcher.dispatch({ action: constants.START_TIMER, data: { timerId: id } });
    },

    resetTimer: function resetTimer(id) {
        AppDispatcher.dispatch({ action: constants.RESET_TIMER, data: { timerId: id } });
    },

    stopTimer: function stopTimer(id) {
        AppDispatcher.dispatch({ action: constants.STOP_TIMER, data: { timerId: id } });
    },

    setTimer: function setTimer(timerId, time) {
        AppDispatcher.dispatch({
            action: constants.SET_TIMER,
            data: {
                remainingTime: time,
                timerId: timerId
            }
        });
    }

};

module.exports = actions;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/TimerConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/TimerConstants.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js":[function(require,module,exports){
/*
 * Dispatcher - a singleton
 *
 * This is essentially the main driver in the Flux architecture
 * @see http://facebook.github.io/flux/docs/overview.html
*/

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _require = require('flux');

var Dispatcher = _require.Dispatcher;

var AppDispatcher = _Object$assign(new Dispatcher(), {});

window.__AppDispatcher = AppDispatcher;
module.exports = AppDispatcher;

// optional methods

},{"babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","flux":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js":[function(require,module,exports){
(function (global){
'use strict';

var AppDispatcher = require('./appdispatcher');
var io = (typeof window !== "undefined" ? window.io : typeof global !== "undefined" ? global.io : null);
var socket = io();
var MissionConstants = require('./constants/MissionConstants');
var MissionActionCreators = require('./actions/MissionActionCreators');
var MessageActionCreators = require('./actions/MessageActionCreators');
var ScienceTeamActionCreators = require('./actions/ScienceActionCreators');
var SecurityTeamActionCreators = require('./actions/SecurityTeamActionCreators');
var AstroTeamTeamActionCreators = require('./actions/AstroTeamActionCreators');
var RadiationStore = require('./stores/radiation-store');
var TimerStore = require('./stores/timer-store');
var TaskStore = require('./stores/task-store');
var IntroductionStore = require('./stores/introduction-store');
var Router = require('./router-container');
var EventConstants = require('../server/EventConstants');

var api = {

    setup: function setup() {
        var _this = this;

        socket.on('connect', function () {
            console.log('Connected to server WebSocket');
            console.log('Asking server for app state');
            api.askForAppState();
            MessageActionCreators.removeMessage('disconnect message');
        });

        socket.on('disconnect', function () {
            MessageActionCreators.addMessage({
                id: 'disconnect message',
                text: 'Mistet kontakt med serveren. Last siden på nytt',
                level: 'danger'
            });
        });

        socket.on(EventConstants.MISSION_STARTED, function (appState) {
            MissionActionCreators.missionStarted();
            _this._appStateReceived(appState);
        });
        socket.on(EventConstants.MISSION_STOPPED, function () {
            return MissionActionCreators.missionStopped();
        });
        socket.on(EventConstants.MISSION_COMPLETED, function () {
            return MissionActionCreators.missionCompleted();
        });
        socket.on(EventConstants.MISSION_RESET, function () {
            return MissionActionCreators.missionWasReset();
        });

        socket.on(EventConstants.SET_EVENTS, MissionActionCreators.receivedEvents);
        socket.on(EventConstants.ADD_MESSAGE, function (serverMsg) {
            if (serverMsg.audience && serverMsg.audience !== Router.getTeamId()) return;

            MessageActionCreators.addMessage(serverMsg);
        });

        socket.on('mission time', MissionActionCreators.setMissionTime);

        socket.on(EventConstants.APP_STATE, function (state) {
            _this._appStateReceived(state);
        });

        // if the client misses the message/event it is lost ... and the current_event will be unchanged :-(
        // TODO: store it server_side in the teamState before sending
        socket.on(EventConstants.AST_CHECK_VITALS, function () {
            AstroTeamTeamActionCreators.startMonitorTask();
        });

        socket.on(EventConstants.SCIENCE_CHECK_RADIATION, function () {
            ScienceTeamActionCreators.startSampleTask();
        });

        socket.on(EventConstants.SECURITY_CHECK_DATA_TRANSFER, function () {
            SecurityTeamActionCreators.startDataTransferCheck();
        });
    },

    startMission: function startMission() {
        socket.emit('start mission');
    },

    stopMission: function stopMission() {
        socket.emit('stop mission');
    },

    resetMission: function resetMission() {
        socket.emit('reset mission');
    },

    askToStartNextChapter: function askToStartNextChapter() {
        socket.emit(EventConstants.ADVANCE_CHAPTER);
    },

    triggerEvent: function triggerEvent(uuid) {
        socket.emit(EventConstants.TRIGGER_EVENT, uuid);
    },

    /*
     * Send the client held state (for the current team) to server on change
     * The most important bits are held on server, and is not transferred back,
     * such as if the mission is running, the current chapter, etc.
     *
     * This is important to store on the server in case we drop the connection and reconnect in other session
     */
    sendTeamStateChange: function sendTeamStateChange() {
        var teamId = arguments[0] === undefined ? Router.getTeamId() : arguments[0];

        var state = {};

        state.team = teamId;
        state.introduction_read = IntroductionStore.isIntroductionRead(teamId);
        state.current_task = TaskStore.getCurrentTaskId(teamId);

        if (teamId === 'science') {
            state.radiation = RadiationStore.getState();
        }

        socket.emit('set team state', state);
    },

    completeMission: function completeMission() {
        socket.emit(EventConstants.COMPLETE_MISSION);
    },

    /*
     * This is only stubbed out until server communication is up and running
     */
    askForAppState: function askForAppState() {
        socket.emit('get app state');
    },

    askForMissionTime: function askForMissionTime() {
        socket.emit('get mission time');
    },

    askToChangeScrubFilter: function askToChangeScrubFilter() {
        socket.emit('set scrub filter changed');
    },

    _appStateReceived: function _appStateReceived(appState) {
        AppDispatcher.dispatch({ action: MissionConstants.RECEIVED_APP_STATE, appState: appState });
    },

    askForEvents: function askForEvents() {
        socket.emit(EventConstants.GET_EVENTS);
    },

    setOxygenConsumption: function setOxygenConsumption(units) {
        socket.emit('set oxygen consumption', units);
    },

    setReadyForSafeMode: function setReadyForSafeMode() {
        socket.emit('ready for safe mode');
    },

    setInSafeMode: function setInSafeMode() {
        socket.emit('set in safe mode');
    },

    // meant for testing - not actual client use
    setOxygenLevel: function setOxygenLevel(units) {
        socket.emit('set oxygen remaining', units);
    }

};

window.__api = api;
module.exports = api;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../server/EventConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/server/EventConstants.js","./actions/AstroTeamActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/AstroTeamActionCreators.js","./actions/MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","./actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","./actions/ScienceActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js","./actions/SecurityTeamActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/SecurityTeamActionCreators.js","./appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","./constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./router-container":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js","./stores/introduction-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/introduction-store.js","./stores/radiation-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/radiation-store.js","./stores/task-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/task-store.js","./stores/timer-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-bootstrap.js":[function(require,module,exports){
/* Script to bootstrap the application */

'use strict';

var MissionActionCreators = require('./actions/MissionActionCreators'),
    MessageActionCreators = require('./actions/MessageActionCreators'),
    ScienceActionCreators = require('./actions/ScienceActionCreators'),
    ScienceConstants = require('./constants/ScienceTeamConstants'),
    TimerActionCreators = require('./actions/TimerActionCreators'),
    AppDispatcher = require('./appdispatcher');

AppDispatcher.register(function (payload) {
    console.log('DEBUG AppDispatcher.dispatch', payload);
});

function run() {

    // SETTINGS
    MissionActionCreators.startMission();
}

module.exports = { run: run };

},{"./actions/MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","./actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","./actions/ScienceActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js","./actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","./appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","./constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/app.react.js":[function(require,module,exports){
(function (global){
'use strict';

var _extends = require('babel-runtime/helpers/extends')['default'];

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);

var RouteHandler = Router.RouteHandler;

var Header = require('./header.react');

var MessageList = require('./message-list.react');
var MissionStateStore = require('../stores/mission-state-store');

var App = React.createClass({
    displayName: 'App',

    mixins: [],

    getInitialState: function getInitialState() {
        return { isMissionRunning: MissionStateStore.isMissionRunning() };
    },

    componentWillMount: function componentWillMount() {
        MissionStateStore.addChangeListener(this._handleMissionStateChange);
    },

    componentDidMount: function componentDidMount() {
        console.log('App.componentDidMount');
    },

    componentWillUnmount: function componentWillUnmount() {
        MissionStateStore.removeChangeListener(this._handleMissionStateChange);
    },

    _handleMissionStateChange: function _handleMissionStateChange() {
        this.setState({ isMissionRunning: MissionStateStore.isMissionRunning() });
    },

    render: function render() {

        return React.createElement(
            'div',
            { className: 'container' },
            React.createElement(Header, null),
            React.createElement(RouteHandler, _extends({}, this.props, this.state)),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement('footer', { id: 'main-footer' })
            )
        );
    }
});

module.exports = App;
/* this is the important part */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/mission-state-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/mission-state-store.js","./header.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/header.react.js","./message-list.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/message-list.react.js","babel-runtime/helpers/extends":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/extends.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/astronaut-task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var HeartRateChart = require('./heart-rate-chart.react');
var BreathRateChart = require('./breath-rate-chart.react');
var TimerPanel = require('./timer-panel.react');
var TimerActionCreators = require('../actions/TimerActionCreators');
var OxygenStore = require('../stores/oxygen-store');
var AstronautConstants = require('../constants/AstroTeamConstants');
var AstronautActionCreators = require('../actions/AstroTeamActionCreators');

var _require = require('../utils');

var parseNumber = _require.parseNumber;

TimerActionCreators.setTimer(AstronautConstants.RESPIRATION_TIMER, 15);
TimerActionCreators.setTimer(AstronautConstants.HEART_RATE_TIMER, 10);

// lazy load due to avoid circular dependencies
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
var getMissionAC = lazyRequire('../actions/MissionActionCreators');
// for browserify to work it needs to find these magic strings
require('../actions/MissionActionCreators');

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},

    propTypes: {},

    mixins: [],

    getInitialState: function getInitialState() {
        return this._getState();
    },
    componentWillMount: function componentWillMount() {
        var _this = this;

        OxygenStore.addChangeListener(function () {
            return _this._updateState();
        });
    },

    _indicatorColor: function _indicatorColor() {
        return this.state.oxygenStore.colorIndicator;
    },

    _updateState: function _updateState() {
        this.setState(this._getState());
    },

    _getState: function _getState() {
        return {
            oxygenStore: OxygenStore.getState()
        };
    },

    _handleBreathRate: function _handleBreathRate(e) {
        e.preventDefault();
        var el = React.findDOMNode(this.refs['breath-rate']);
        AstronautActionCreators.setOxygenConsumption(parseNumber(el.value));
        getMissionAC().taskCompleted('astronaut', 'breathing_calculate');
    },

    _handleHeartRate: function _handleHeartRate(e) {
        e.preventDefault();
        var el = React.findDOMNode(this.refs['heart-rate-input']);
        AstronautActionCreators.heartRateRead(parseNumber(el.value));
        getMissionAC().taskCompleted('astronaut', 'heartrate_calculate');
    },

    render: function render() {

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'ul',
                    null,
                    React.createElement(
                        'li',
                        null,
                        'Luftstatus:',
                        React.createElement('div', {
                            className: 'circle ',
                            style: { display: 'inline-block', backgroundColor: this._indicatorColor() }
                        })
                    ),
                    React.createElement(
                        'li',
                        null,
                        'Forbruk : ',
                        this.state.oxygenStore.consumptionPerMinute
                    ),
                    React.createElement(
                        'li',
                        null,
                        'Gjenstående oksygen: ',
                        this.state.oxygenStore.remaining,
                        ' enheter'
                    )
                )
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'col-md-6' },
                    React.createElement(
                        'h2',
                        null,
                        'Pust'
                    ),
                    React.createElement(BreathRateChart, { height: 240 })
                ),
                React.createElement(
                    'div',
                    { className: 'col-md-6' },
                    React.createElement(
                        'h2',
                        null,
                        'Hjerteslag'
                    ),
                    React.createElement(HeartRateChart, { height: 240 })
                ),
                React.createElement(TimerPanel, { timerId: AstronautConstants.RESPIRATION_TIMER, className: 'col-md-6' }),
                React.createElement(TimerPanel, { timerId: AstronautConstants.HEART_RATE_TIMER, className: 'col-md-6' })
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'col-xs-6' },
                    React.createElement(
                        'fieldset',
                        { disabled: false },
                        React.createElement(
                            'h3',
                            null,
                            'Beregnet luftforbruk'
                        ),
                        React.createElement(
                            'form',
                            { onSubmit: this._handleBreathRate },
                            React.createElement(
                                'select',
                                { ref: 'breath-rate' },
                                React.createElement(
                                    'option',
                                    { value: 1 },
                                    '1 enhet per minutt'
                                ),
                                React.createElement(
                                    'option',
                                    { value: 2 },
                                    '2 enheter per minutt'
                                )
                            ),
                            React.createElement(
                                'button',
                                { className: 'btn btn-primary' },
                                'Evaluer'
                            )
                        )
                    )
                ),
                React.createElement(
                    'div',
                    { className: 'col-xs-6' },
                    React.createElement(
                        'fieldset',
                        { disabled: false },
                        React.createElement(
                            'h3',
                            null,
                            'Beregnet hjerterytme'
                        ),
                        React.createElement(
                            'form',
                            { onSubmit: this._handleHeartRate },
                            React.createElement('input', { ref: 'heart-rate-input', type: 'number', min: '50', max: '200' }),
                            React.createElement(
                                'button',
                                { className: 'btn btn-primary' },
                                'Evaluer'
                            )
                        )
                    )
                )
            )
        );
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/AstroTeamActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/AstroTeamActionCreators.js","../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../stores/oxygen-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/oxygen-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./breath-rate-chart.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/breath-rate-chart.react.js","./heart-rate-chart.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/heart-rate-chart.react.js","./timer-panel.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer-panel.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/breath-rate-chart.react.js":[function(require,module,exports){
(function (global){
/**
 * THIS DESIGN ONLY SUPPORTS ONE CHART AS THEY *SHARE* STATE
 * For a non-stupid design, do something like the
 * implementation in the article by Nicolas Hery:
 * http://nicolashery.com/integrating-d3js-visualizations-in-a-react-app
 *
 * Chart code more or less copied from the prototype by Leo Martin Westby
 */
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var AmCharts = (typeof window !== "undefined" ? window.AmCharts : typeof global !== "undefined" ? global.AmCharts : null);
var BreathRateStore = require('../stores/breath-rate-store');

var _require = require('../utils');

var randomInt = _require.randomInt;

//Lung volume in ml before and after inhalation
var lowVolume = 2000;
var highVolume = 3000;

//Millivolts displayed on the Y axis of the ECG graph
var highMV = 1;
var lowMV = 0;

var breathRateSamples = [];
var chart;

//Configure the charts
function initChart(domElement) {
    chart = new AmCharts.AmSerialChart();

    chart.marginTop = 20;
    chart.marginRight = 10;
    chart.autoMarginOffset = 5;
    chart.dataProvider = breathRateSamples;
    chart.categoryField = 'timestamp';

    //X Axis
    var categoryAxis = chart.categoryAxis;
    categoryAxis.dashLength = 1;
    categoryAxis.gridAlpha = 0.1;
    categoryAxis.axisColor = '#DADADA';
    categoryAxis.autoGridCount = false;
    categoryAxis.gridCount = 15;
    categoryAxis.forceShowField = 'forceShow';
    //categoryAxis.title = "Seconds";

    //Hide every label that is not explicitly shown
    categoryAxis.labelFunction = function (valueText, object) {
        if (object.forceShow) {
            return valueText;
        }
    };

    //Y Axis
    var valueAxis = new AmCharts.ValueAxis();
    valueAxis.axisAlpha = 0.2;
    valueAxis.dashLength = 1;
    valueAxis.minimum = lowVolume;
    valueAxis.maximum = highVolume * 1.1;
    valueAxis.title = 'Lungevolum (ml)';
    chart.addValueAxis(valueAxis);

    //Line
    var graph = new AmCharts.AmGraph();
    graph.type = 'smoothedLine';
    graph.valueField = 'volume';
    graph.lineThickness = 1.5;
    graph.lineColor = '#b5030d';
    chart.addGraph(graph);

    chart.write(domElement);
}

var breathRateBuffer;
var breathRateBufferIndex;
var msUntilNextBreathRateBufferFrame;

//Fills the breath rate buffer with samples from the specified range
//The breath rate buffer contains twice as many samples as the breath rate chart and is used to animate the chart
function createBreathRateSamples(min, max) {
    breathRateBuffer = [];
    breathRateBufferIndex = 0;
    msUntilNextBreathRateBufferFrame = 0;

    var breathsPerMinute = randomInt(min, max);
    var msBetweenBreaths = 60 * 1000 / breathsPerMinute;
    var msUntilNextBreath = msBetweenBreaths;

    for (var i = 0; i <= 120; i++) {
        var lungVolume;

        if (msUntilNextBreath <= 0) {
            lungVolume = highVolume;
            msUntilNextBreath = msBetweenBreaths;
        } else {
            lungVolume = lowVolume * 1.05;
        }

        //The resolution of the chart is two samples per second
        breathRateBuffer.push({ timestamp: i / 2, volume: lungVolume });
        msUntilNextBreath -= 500;
    }
}

var chartUpdater;

//Animates the breath rate and heart rate charts
function startEventLoop() {
    var startTime = Date.now();
    var msSinceLastUpdate = 0;
    var msSinceStart = 0;
    var updateFrequency = 400;
    stopEventLoop();

    chartUpdater = setInterval(function () {
        msSinceLastUpdate = Date.now() - startTime - msSinceStart;
        msUntilNextBreathRateBufferFrame -= msSinceLastUpdate;
        msSinceStart = Date.now() - startTime;

        if (msUntilNextBreathRateBufferFrame <= 0) {
            var framesMissed = Math.floor(msUntilNextBreathRateBufferFrame * -1 / 500 + 1);

            for (var i = 0; i < framesMissed; i++) {
                breathRateBufferIndex++;

                if (breathRateBufferIndex >= breathRateBuffer.length) {
                    breathRateBufferIndex = 0;
                }

                breathRateSamples.push(breathRateBuffer[breathRateBufferIndex]);

                //When the chart grows to 30 seconds, start cutting off the oldest sample to give the chart a sliding effect
                if (breathRateSamples.length > 60) {
                    breathRateSamples.shift();
                }
            }

            msUntilNextBreathRateBufferFrame = 250;
        }

        //Always show from 0 to 30 seconds on the X axis
        if (breathRateSamples.length >= 60) {
            for (var i = 0; i < breathRateSamples.length; i++) {
                breathRateSamples[i].timestamp = Math.floor(i / (breathRateSamples.length - 1) * 30);
            }
        }

        //Only show every 5th timestamp
        for (var i = 0; i < breathRateSamples.length; i++) {
            breathRateSamples[i].forceShow = breathRateSamples[i].timestamp % 5 == 0 && (i == 0 || breathRateSamples[i - 1].timestamp % 5 != 0);
        }

        chart.validateData();
    }, updateFrequency);
}

function stopEventLoop() {
    clearInterval(chartUpdater);
    breathRateSamples.length = 0;
    chart.validateData();
}

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},

    propTypes: {
        height: React.PropTypes.number.isRequired,
        width: React.PropTypes.number
    },

    mixins: [],

    getInitialState: function getInitialState() {
        return this._getChartState();
    },

    componentWillMount: function componentWillMount() {
        var _this = this;

        this._updateChart();
        BreathRateStore.addChangeListener(function () {
            return _this._updateChart();
        });
    },

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        initChart(el);
        startEventLoop();
    },

    componentWillUnmount: function componentWillUnmount() {
        chart && chart.clear();
        stopEventLoop();
    },

    componentDidUnmount: function componentDidUnmount() {
        chart = null;
    },

    componentDidUpdate: function componentDidUpdate() {},

    // this chart is responsible for drawing itself
    shouldComponentUpdate: function shouldComponentUpdate() {
        return false;
    },

    // Private methods
    _updateChart: function _updateChart() {
        this.setState(this._getChartState());
        createBreathRateSamples(this.state.min, this.state.max);
    },

    _getChartState: function _getChartState() {
        return BreathRateStore.getState();
    },

    _onChange: function _onChange() {},

    render: function render() {

        // if you don't specify width it will max out to 100% (which is ok)
        return React.createElement('div', {
            style: { width: this.props.width + 'px', height: this.props.height + 'px' },
            className: this.props.className
        });
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/breath-rate-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/breath-rate-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/communication-task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var OxygenStore = require('../stores/oxygen-store');

var _require = require('../utils');

var parseNumber = _require.parseNumber;

var _require2 = require('../utils');

var randomInt = _require2.randomInt;

// lazy load due to avoid circular dependencies
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
var getMissionAC = lazyRequire('../actions/MissionActionCreators');
// for browserify to work it needs to find these magic strings
require('../actions/MissionActionCreators');

var lowThreshold = 30,
    mediumThreshold = 70;

var satellites = [{ name: 'Satelitt 1', freq: { min: 2.8, max: 3.4 }, reception: 90, color: 'green' }, { name: 'Satelitt 2', freq: { min: 2.1, max: 2.5 }, reception: 30, color: 'red' }, { name: 'Satelitt 3', freq: { min: 3.6, max: 4 }, reception: 60, color: 'orange' }];

function color(reception) {
    if (reception > mediumThreshold) {
        return 'green';
    }
    if (reception > lowThreshold) {
        return 'orange';
    }
    return 'red';
}

var i = 0;
function newValues() {
    satellites[(i + 0) % 3].reception = randomInt(25, 65);
    satellites[(i + 1) % 3].reception = randomInt(45, 85);
    satellites[(i + 2) % 3].reception = randomInt(25, 65);
    i++;

    chart.validateData();
}

setInterval(newValues, 1000 * 60 * 4);

var chart;
function initGraph(domElement) {
    chart = new AmCharts.AmSerialChart();

    chart.dataProvider = satellites;
    chart.categoryField = 'name';

    //X axis
    var categoryAxis = chart.categoryAxis;
    categoryAxis.gridPosition = 'start';

    //Y axis
    var valueAxis = new AmCharts.ValueAxis();
    valueAxis.axisAlpha = 0;
    valueAxis.minimum = 0;
    valueAxis.maximum = 100;
    valueAxis.title = 'Mottak';
    valueAxis.position = 'left';
    chart.addValueAxis(valueAxis);

    //Line
    var graph = new AmCharts.AmGraph();
    graph.valueField = 'reception';
    graph.colorField = 'color';
    graph.lineAlpha = 0.2;
    graph.fillAlphas = 0.8;
    graph.type = 'column';
    graph.showBalloon = false;
    chart.addGraph(graph);

    chart.write(domElement);

    return chart;
}

var SatelliteReceptionChart = React.createClass({
    displayName: 'SatelliteReceptionChart',

    propTypes: {},

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        initGraph(el);
    },

    render: function render() {
        return React.createElement('div', { className: this.props.className, style: this.props.style });
    }

});

var SatelliteTable = React.createClass({
    displayName: 'SatelliteTable',

    propTypes: {
        satellites: React.PropTypes.array.isRequired
    },

    render: function render() {

        return React.createElement(
            'div',
            this.props,
            React.createElement(
                'table',
                { className: 'table table-bordered table-striped ' },
                React.createElement(
                    'thead',
                    null,
                    React.createElement(
                        'tr',
                        null,
                        React.createElement(
                            'th',
                            null,
                            'Satelitt'
                        ),
                        React.createElement(
                            'th',
                            null,
                            'Frekvensområde'
                        )
                    )
                ),
                React.createElement(
                    'tbody',
                    null,
                    this.props.satellites.map(function (sat, i) {
                        return React.createElement(
                            'tr',
                            { key: i },
                            React.createElement(
                                'td',
                                null,
                                sat.name
                            ),
                            React.createElement(
                                'td',
                                null,
                                sat.freq.min,
                                ' - ',
                                sat.freq.max
                            )
                        );
                    })
                )
            )
        );
    }

});

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},

    propTypes: {},

    mixins: [],

    getInitialState: function getInitialState() {
        return {
            chosenSatellite: satellites[0]
        };
    },
    componentWillMount: function componentWillMount() {},

    componentWillUnmount: function componentWillUnmount() {},

    _getState: function _getState() {
        return {};
    },

    render: function render() {

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(SatelliteTable, { satellites: satellites, className: 'col-sm-6' }),
                React.createElement(SatelliteReceptionChart, { style: { height: '250px' }, className: 'col-sm-6' })
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'h3',
                    null,
                    'Velg satelitt og tilhørende frekvensområde'
                ),
                React.createElement(
                    'select',
                    null,
                    satellites.map(function (sat) {
                        return React.createElement(
                            'option',
                            { key: sat.name, value: sat.name },
                            sat.name
                        );
                    })
                ),
                React.createElement(
                    'h4',
                    null,
                    'Velg frekvens:'
                ),
                React.createElement('input', { type: 'number' })
            )
        );
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../stores/oxygen-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/oxygen-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/dialogs.react.js":[function(require,module,exports){
(function (global){
// needed to avoid compilation error
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

module.exports = {
    science_intro: React.createElement(
        'div',
        null,
        React.createElement(
            'p',
            null,
            'Dere skal overvåke strålingsnivået astronatuen utsettes for. Dere må da passe på at astronauten ikke blir utsatt for strålingsnivåer som er skadelig.'
        ),
        React.createElement(
            'p',
            null,
            'Ved hjelp av instrumentene som er tilgjengelig må dere jevnlig ta prøver og regne ut verdiene for gjennomsnittlig og totalt strålingsnivå. Finner dere ut at nivåene er blitt farlig høye ',
            React.createElement(
                'em',
                null,
                'må'
            ),
            ' dere si fra til oppdragslederen så vi kan få ut astronauten!'
        ),
        React.createElement(
            'p',
            null,
            'Er oppdraget forstått?'
        )
    ),

    astronaut_intro: React.createElement(
        'div',
        null,
        React.createElement(
            'p',
            null,
            'Deres jobb er å sikre at det er nok oksygen for å gjennomføre oppdraget. Her er det viktig å jevnlig sjekke hvor fort astronaut Steigen puster og hvor fort hjertet hennes slår.'
        ),
        React.createElement(
            'p',
            null,
            'Finner dere ut at astronaut Steigen ikke vil ha nok luft til å gjennomføre oppdraget ',
            React.createElement(
                'em',
                null,
                'må'
            ),
            ' dere si fra til oppdragslederen så vi kan avbryte i tide.'
        )
    ),

    communication_intro: React.createElement(
        'div',
        null,
        React.createElement(
            'p',
            null,
            'Deres mål er å holde kommunikasjonen oppe, og kommunisere med oppdragskoordinator og astronauten. Om nødvendig må dere kanskje bytte til en annen kommunikasjonssatelitt.'
        ),
        React.createElement(
            'p',
            null,
            'Dere skal også informere astronauten om eventuelle beskjeder fra Andaøya Space Center (ASC), og likeledes informere ASC om hendelser eller beskjeder fra astronauten.'
        )
    ),

    security_intro: React.createElement(
        'div',
        null,
        React.createElement(
            'p',
            null,
            'Deres hovedoppgave er å innhente informasjon fra de forskjellige gruppene og bestemme dere for hva som skal gjøres. Her må dere samarbeide godt med oppdragskoordinatoren (',
            React.createElement(
                'em',
                null,
                'mission commander'
            ),
            ')!'
        ),
        React.createElement(
            'p',
            null,
            'Dere må også holde et øye på indikatoren som sier om det er nok luft til å gjennomføre oppdraget, samt sjekke om karbondioksidskrubberen må skiftes slik at astronauten ikke kveles.'
        ),
        React.createElement(
            'p',
            null,
            'Deres må også sjekke at kommunikasjonsstatusen og datakvaliteten er god når reparasjonen er utført.'
        )
    )

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/dummy-render.mixin.js":[function(require,module,exports){
'use strict';

module.exports = {
    render: function render() {
        throw new Error('DUMMY_RENDER. This react component is not for presentational purposes');
    }
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/full-screen-video.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

var player;
function onYouTubeIframeAPIReady() {
    console.log('onYouTubeIframeAPIReady');
    player = new YT.Player('player', {
        events: {
            onReady: onPlayerReady
        }
    });
}

function playVideo() {
    player.seekTo(96);
    player.playVideo();

    // stop video after ten seconds
    setTimeout(function () {
        player.stopVideo(player);
        playVideo();
    }, 10000);
}

function onPlayerReady(event) {
    //event.target.mute();
    player.mute();
    playVideo();
}

window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;

module.exports = React.createClass({
    displayName: 'exports',

    /* https://developers.google.com/youtube/iframe_api_reference#Getting_Started */
    componentDidMount: function componentDidMount() {
        console.log('componentDidMount');
        var tag = document.createElement('script');

        tag.src = 'https://www.youtube.com/iframe_api';
        document.head.appendChild(tag);
    },

    render: function render() {
        var rickRolled = 'http://www.youtube.com/embed/oHg5SJYRHA0?autoplay=1';
        var origin = location.protocol + '//' + location.host;
        var solarStorm = 'http://www.youtube.com/embed/DU4hpsistDk?&start=96&enablejsapi=1&origin=' + origin;
        var video = solarStorm;

        //return <div />
        return React.createElement('iframe', { id: 'player',
            style: { position: 'absolute', top: 0, right: 0, width: '100%', height: '100%' },
            src: video,
            frameBorder: '0', allowFullScreen: true });
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/header.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var Link = Router.Link;

var Header = React.createClass({
    displayName: 'Header',

    render: function render() {
        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'header',
                    { id: 'narom-header' },
                    React.createElement(
                        'div',
                        null,
                        React.createElement('img', { className: 'narom-logo-img', src: '/images/logo.png' }),
                        'NAROM e-Mission prototype'
                    )
                )
            ),
            React.createElement(
                'div',
                { id: 'main-header', className: 'row' },
                React.createElement(
                    Link,
                    { to: '/' },
                    React.createElement(
                        'header',
                        null,
                        React.createElement(
                            'h1',
                            { className: '' },
                            'Under en solstorm'
                        )
                    )
                )
            )
        );
    }
});

module.exports = Header;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/heart-rate-chart.react.js":[function(require,module,exports){
(function (global){
/**
 * THIS DESIGN ONLY SUPPORTS ONE CHART AS THEY *SHARE* STATE
 * For a non-stupid design, do something like the
 * implementation in the article by Nicolas Hery:
 * http://nicolashery.com/integrating-d3js-visualizations-in-a-react-app
 *
 * Chart code more or less copied from the prototype by Leo Martin Westby
 */
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var AmCharts = (typeof window !== "undefined" ? window.AmCharts : typeof global !== "undefined" ? global.AmCharts : null);

var _require = require('../utils');

var randomInt = _require.randomInt;

var HeartStore = require('../stores/heart-rate-store');

var chart;
var heartRateSamples = [];

var heartRateBuffer;
var heartRateBufferIndex;
var msUntilNextHeartRateBufferFrame;

//Millivolts displayed on the Y axis of the ECG graph
var highMV = 1;
var lowMV = 0;

var chartUpdater;

function initChart(domElement) {

    chart = new AmCharts.AmSerialChart();

    chart.marginTop = 20;
    chart.marginRight = 10;
    chart.autoMarginOffset = 5;
    chart.dataProvider = heartRateSamples;
    chart.categoryField = 'timestamp';

    //X Axis
    var categoryAxis = chart.categoryAxis;
    categoryAxis.dashLength = 1;
    categoryAxis.gridAlpha = 0.1;
    categoryAxis.axisColor = '#DADADA';
    categoryAxis.forceShowField = 'forceShow';
    //categoryAxis.title = "Seconds";

    //Hide every label that is not explicitly shown
    categoryAxis.labelFunction = function (valueText, object) {
        if (object.forceShow) {
            return valueText;
        }
    };

    //Y Axis
    var valueAxis = new AmCharts.ValueAxis();
    valueAxis.axisAlpha = 0.2;
    valueAxis.dashLength = 1;
    valueAxis.minimum = lowMV;
    valueAxis.maximum = highMV * 1.1;
    valueAxis.title = 'mV';
    chart.addValueAxis(valueAxis);

    //Line
    var graph = new AmCharts.AmGraph();

    graph.valueField = 'mV';
    graph.type = 'smoothedLine';
    graph.lineThickness = 1;
    graph.lineColor = '#b5030d';
    chart.addGraph(graph);

    chart.write(domElement);
}

//Fills the heart rate buffer with samples from the specified range
//The heart rate buffer contains twice as many samples as the heart rate chart and is used to animate the chart
function createHeartRateSamples(min, max) {
    heartRateBuffer = [];
    heartRateBufferIndex = 0;
    msUntilNextHeartRateBufferFrame = 0;

    var beatsPerMinute = randomInt(min, max);
    var msBetweenBeats = 60 * 1000 / beatsPerMinute;
    var msUntilNextBeat = msBetweenBeats;

    for (var i = 0; i <= 200; i++) {
        var mV;

        if (msUntilNextBeat <= 0) {
            mV = highMV;
            msUntilNextBeat = msBetweenBeats;
        } else {
            mV = Math.random() * 0.2;
        }

        //The resolution of the chart is ten samples per second
        heartRateBuffer.push({ timestamp: i / 10, mV: mV });
        msUntilNextBeat -= 50;
    }
}

//Animates the  heart rate charts
function startEventLoop() {
    var startTime = Date.now();
    var msSinceLastUpdate = 0;
    var msSinceStart = 0;
    var updateFrequency = 400;
    stopEventLoop();

    chartUpdater = setInterval(function () {
        msSinceLastUpdate = Date.now() - startTime - msSinceStart;
        msUntilNextHeartRateBufferFrame -= msSinceLastUpdate;
        msSinceStart = Date.now() - startTime;

        if (msUntilNextHeartRateBufferFrame <= 0) {
            var framesMissed = Math.floor(msUntilNextHeartRateBufferFrame * -1 / 100 + 1);

            for (var i = 0; i < framesMissed; i++) {
                heartRateBufferIndex++;

                if (heartRateBufferIndex >= heartRateBuffer.length) {
                    heartRateBufferIndex = 0;
                }

                heartRateSamples.push(heartRateBuffer[heartRateBufferIndex]);

                //When the chart grows to 10 seconds, start cutting off the oldest sample to give the chart a sliding effect
                if (heartRateSamples.length > 100) {
                    heartRateSamples.shift();
                }
            }

            msUntilNextHeartRateBufferFrame = 100;
        }

        //Always show from 0 to 10 seconds on the X axis
        if (heartRateSamples.length >= 100) {
            for (var i = 0; i < heartRateSamples.length; i++) {
                heartRateSamples[i].timestamp = Math.floor(i / (heartRateSamples.length - 1) * 10);
            }
        }

        //Only show every 5th timestamp
        for (var i = 0; i < heartRateSamples.length; i++) {
            heartRateSamples[i].forceShow = heartRateSamples[i].timestamp % 5 == 0 && (i == 0 || heartRateSamples[i - 1].timestamp % 5 != 0);
        }

        chart.validateData();
    }, updateFrequency);
}

function stopEventLoop() {
    clearInterval(chartUpdater);
    heartRateSamples.length = 0;
    chart.validateData();
}

var HeartRateChart = React.createClass({
    displayName: 'HeartRateChart',

    statics: {},

    propTypes: {
        height: React.PropTypes.number.isRequired,
        width: React.PropTypes.number
    },

    mixins: [],

    getInitialState: function getInitialState() {
        return this._getChartState();
    },

    componentWillMount: function componentWillMount() {
        var _this = this;

        this._updateChart();
        HeartStore.addChangeListener(function () {
            return _this._updateChart();
        });
    },

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        initChart(el);
        startEventLoop();
    },

    componentWillReceiveProps: function componentWillReceiveProps() {},

    componentWillUnmount: function componentWillUnmount() {
        chart && chart.clear();
        stopEventLoop();
    },

    componentDidUnmount: function componentDidUnmount() {
        chart = null;
    },

    componentDidUpdate: function componentDidUpdate() {},

    // this chart is responsible for drawing itself
    shouldComponentUpdate: function shouldComponentUpdate() {
        return false;
    },

    // Private methods
    _updateChart: function _updateChart() {
        this.setState(this._getChartState());
        createHeartRateSamples(this.state.min, this.state.max);
    },

    _getChartState: function _getChartState() {
        return HeartStore.getState();
    },

    _onChange: function _onChange() {},

    render: function render() {

        // if you don't specify width it will max out to 100% (which is ok)
        return React.createElement('div', {
            style: { width: this.props.width + 'px', height: this.props.height + 'px' },
            className: this.props.className
        });
    }

});

module.exports = HeartRateChart;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/heart-rate-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/heart-rate-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/index-app.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var Link = Router.Link;

module.exports = React.createClass({
    displayName: 'exports',

    render: function render() {
        return React.createElement(
            'div',
            null,
            React.createElement(
                'h3',
                null,
                'Velg lag'
            ),
            React.createElement(
                'ul',
                null,
                React.createElement(
                    'li',
                    null,
                    React.createElement(
                        Link,
                        { to: 'team-root', params: { teamId: 'science' } },
                        'Forskningsgruppa'
                    )
                ),
                React.createElement(
                    'li',
                    null,
                    React.createElement(
                        Link,
                        { to: 'team-root', params: { teamId: 'astronaut' } },
                        'Astronautgruppa'
                    )
                ),
                React.createElement(
                    'li',
                    null,
                    React.createElement(
                        Link,
                        { to: 'team-root', params: { teamId: 'security' } },
                        'Sikkerhetsgruppa'
                    )
                ),
                React.createElement(
                    'li',
                    null,
                    React.createElement(
                        Link,
                        { to: 'team-root', params: { teamId: 'communication' } },
                        'Kommunikasjonsgruppa'
                    )
                )
            )
        );
    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/introduction-screen.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var dialogs = require('./dialogs.react');

var _require = require('../utils');

var cleanRootPath = _require.cleanRootPath;

var RouteStore = require('../stores/route-store');
var IntroStore = require('../stores/introduction-store');

var IntroductionScreen = React.createClass({
    displayName: 'IntroductionScreen',

    mixins: [],

    contextTypes: {
        router: React.PropTypes.func
    },

    statics: {
        willTransitionTo: function willTransitionTo(transition) {
            var teamId = cleanRootPath(transition.path);

            if (IntroStore.isIntroductionRead(teamId)) {
                console.log('Introduction read earlier');
                transition.redirect('team-task', { taskId: 'sample', teamId: teamId });
            }
        }
    },

    _handleClick: function _handleClick() {
        var MissionActionCreators = require('../actions/MissionActionCreators');

        var teamId = RouteStore.getTeamId();
        MissionActionCreators.introWasRead(teamId);
        this.context.router.transitionTo('team-task', { taskId: 'sample', teamId: teamId });
    },

    render: function render() {
        var teamId = RouteStore.getTeamId();
        var introText = dialogs[teamId + '_intro'] || React.createElement(
            'p',
            null,
            'Mangler oppdrag'
        );

        return React.createElement(
            'div',
            { className: 'row jumbotron introscreen' },
            React.createElement(
                'h2',
                null,
                'Mål for oppdraget'
            ),
            introText,
            React.createElement(
                'button',
                {
                    className: 'btn btn-primary btn-lg',
                    onClick: this._handleClick
                },
                'Jeg forstår'
            )
        );
    }
});

module.exports = IntroductionScreen;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../stores/introduction-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/introduction-store.js","../stores/route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./dialogs.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/dialogs.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/message-list.react.js":[function(require,module,exports){
(function (global){
'use strict';

var _extends = require('babel-runtime/helpers/extends')['default'];

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var actions = require('../actions/MessageActionCreators');

var ListMessageWrapper = React.createClass({
    displayName: 'ListMessageWrapper',

    propTypes: {
        level: React.PropTypes.string.isRequired,
        text: React.PropTypes.string.isRequired,
        id: React.PropTypes.string.isRequired
    },

    render: function render() {
        var _this = this;

        var button = undefined;

        if (this.props.dismissable) {
            button = React.createElement(
                'button',
                {
                    type: 'button',
                    className: 'close',
                    onClick: function () {
                        return actions.removeMessage(_this.props.id);
                    }
                },
                React.createElement(
                    'span',
                    null,
                    '×'
                )
            );
        }

        return React.createElement(
            'li',
            { className: 'alert alert-dismissible alert-' + this.props.level },
            button,
            this.props.text
        );
    }
});

var MessageList = React.createClass({
    displayName: 'MessageList',

    render: function render() {
        var hidden = this.props.messages.length === 0 ? 'hide' : '';
        var classes = (this.props.className || '') + ' messagebox ' + hidden;

        return React.createElement(
            'ul',
            { className: classes },
            this.props.messages.map(function (msg) {
                return React.createElement(ListMessageWrapper, _extends({ key: msg.id }, msg));
            })
        );
    }

});

module.exports = MessageList;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","babel-runtime/helpers/extends":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/extends.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-commander.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Link = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null).Link;
var MissionStore = require('../stores/mission-state-store');
var MissionTimer = require('./mission-timer.react');
var EventStore = require('../stores/event-store');
var utils = require('../utils');
var getMissionAC = (function () {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require('../actions/MissionActionCreators');
        return tmp;
    };
})();

var EventTable = React.createClass({
    displayName: 'EventTable',

    propTypes: {
        events: React.PropTypes.array.isRequired,
        triggerDisabled: React.PropTypes.bool
    },

    render: function render() {
        var _this = this;

        return React.createElement(
            'table',
            { className: 'table' },
            React.createElement(
                'thead',
                null,
                React.createElement(
                    'tr',
                    null,
                    React.createElement(
                        'th',
                        null,
                        'Time'
                    ),
                    React.createElement(
                        'th',
                        null,
                        'Description'
                    ),
                    React.createElement(
                        'th',
                        null,
                        'Value'
                    ),
                    React.createElement(
                        'th',
                        null,
                        'Trigger'
                    )
                )
            ),
            React.createElement(
                'tbody',
                null,
                this.props.events.map(function (ev) {
                    return React.createElement(
                        'tr',
                        { key: ev.id },
                        React.createElement(
                            'td',
                            null,
                            ev.triggerTime
                        ),
                        React.createElement(
                            'td',
                            null,
                            ev.short_description
                        ),
                        React.createElement(
                            'td',
                            null,
                            JSON.stringify(ev.value || '')
                        ),
                        React.createElement(
                            'td',
                            null,
                            React.createElement(
                                'button',
                                { className: 'btn btn-primary ' + (_this.props.triggerDisabled && 'disabled'),
                                    onClick: function () {
                                        return getMissionAC().askToTriggerEvent(ev.id);
                                    }
                                },
                                'Trigger'
                            )
                        )
                    );
                })
            )
        );
    }
});

var App = React.createClass({
    displayName: 'App',

    componentWillMount: function componentWillMount() {
        var ac = getMissionAC();
        ac.askForEvents();

        EventStore.addChangeListener(this._onChange);
        MissionStore.addChangeListener(this._onChange);
    },

    componentDidMount: function componentDidMount() {
        var _this2 = this;

        this._interval = setInterval(function () {
            _this2.setState({ chapterTime: _this2.state.chapterTime + 1 });
        }, 1000);
    },

    componentWillUnmount: function componentWillUnmount() {
        clearInterval(this._interval);
        EventStore.removeChangeListener(this._onChange);
        MissionStore.removeChangeListener(this._onChange);
    },

    getInitialState: function getInitialState() {
        return {
            completedEvents: [],
            overdueEvents: [],
            remainingEvents: [],
            running: MissionStore.isMissionRunning(),
            chapter: MissionStore.currentChapter(),
            chapterTime: MissionStore.chapterTime()
        };
    },

    _onChange: function _onChange() {
        this.setState({
            completedEvents: EventStore.completed(),
            overdueEvents: EventStore.overdue(),
            remainingEvents: EventStore.remaining(),
            running: MissionStore.isMissionRunning(),
            chapter: MissionStore.currentChapter(),
            chapterTime: MissionStore.chapterTime(),
            safeMode: MissionStore.isSatelliteInSafeMode()
        });
    },

    render: function render() {

        var status;

        if (!this.state.running) {
            status = React.createElement(
                'p',
                { id: 'missionTime' },
                'Oppdraget har ikke startet'
            );
        }

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                null,
                React.createElement(
                    'h3',
                    null,
                    'Status'
                ),
                status,
                React.createElement(
                    'dl',
                    null,
                    React.createElement(
                        'dt',
                        null,
                        'Nåværende kapittel:'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        this.state.chapter
                    ),
                    React.createElement(
                        'dt',
                        null,
                        'Tid brukt i kapittel'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        this.state.chapterTime
                    ),
                    React.createElement(
                        'dt',
                        null,
                        'Total tid'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        React.createElement(MissionTimer, null)
                    )
                ),
                'Satellite in safe mode? ',
                this.state.safeMode ? 'Yes' : 'No'
            ),
            React.createElement(
                'div',
                null,
                React.createElement(
                    'button',
                    { className: 'btn btn-primary', onClick: getMissionAC().startMission },
                    'Start oppdrag'
                ),
                React.createElement(
                    'button',
                    { className: 'btn btn-primary', onClick: getMissionAC().stopMission },
                    'Stop'
                ),
                React.createElement(
                    'button',
                    { className: 'btn btn-primary', onClick: getMissionAC().askToStartNextChapter },
                    'Neste kapittel'
                ),
                React.createElement(
                    'button',
                    { className: 'btn btn-primary', onClick: getMissionAC().resetMission },
                    'Begynn på nytt'
                )
            ),
            React.createElement(
                'button',
                { className: 'btn btn-primary', onClick: getMissionAC().completeMission },
                'Oppdrag utført'
            ),
            React.createElement(
                'button',
                { className: 'btn btn-primary', onClick: getMissionAC().changeScrubber },
                'Bytt scrubber'
            ),
            React.createElement(
                'h2',
                null,
                'Chapter events'
            ),
            React.createElement(
                'h3',
                null,
                'remaining'
            ),
            React.createElement(EventTable, { key: 'foo', events: this.state.remainingEvents }),
            React.createElement(
                'h3',
                null,
                'overdue'
            ),
            React.createElement(EventTable, { events: this.state.overdueEvents }),
            React.createElement(
                'h3',
                null,
                'completed'
            ),
            React.createElement(EventTable, { triggerDisabled: true, events: this.state.completedEvents })
        );
    }

});

module.exports = App;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../stores/event-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/event-store.js","../stores/mission-state-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/mission-state-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./mission-timer.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-timer.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-timer.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null),
    TimerStore = require('../stores/timer-store'),
    Timer = require('./timer.react');

var MissionTimer = React.createClass({
    displayName: 'MissionTimer',

    getInitialState: function getInitialState() {
        return { elapsed: TimerStore.getElapsedMissionTime() };
    },

    componentDidMount: function componentDidMount() {
        TimerStore.addChangeListener(this._handleTimeChange);
    },

    componentWillUnmount: function componentWillUnmount() {
        TimerStore.removeChangeListener(this._handleTimeChange);
    },

    _handleTimeChange: function _handleTimeChange() {
        this.setState({
            elapsed: TimerStore.getElapsedMissionTime()
        });
    },

    render: function render() {
        return React.createElement(Timer, { className: this.props.className, timeInSeconds: this.state.elapsed });
    }
});

module.exports = MissionTimer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/timer-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js","./timer.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/not-found.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

var NotFound = React.createClass({
    displayName: 'NotFound',

    render: function render() {
        return React.createElement(
            'div',
            { className: 'container' },
            React.createElement(
                'div',
                { className: 'row jumbotron' },
                React.createElement(
                    'div',
                    null,
                    'Ojsann. Tror du har gått deg vill, jeg'
                )
            )
        );
    }
});

module.exports = NotFound;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/overlay.react.js":[function(require,module,exports){
(function (global){
/*
 * Simple component that overlays a section, signalling a disabled state
 *
 * Dependant on working CSS, of course: the parent must be positioned (relative, absolute, ...)
 * Loosely based http://stackoverflow.com/questions/3627283/how-to-dim-other-div-on-clicking-input-box-using-jquery
 */
"use strict";

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

module.exports = React.createClass({
    displayName: "exports",

    propTypes: {
        active: React.PropTypes.bool.isRequired
    },

    render: function render() {
        return this.props.active ? React.createElement("div", { className: "overlay" }) : null;
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-chart.react.js":[function(require,module,exports){
(function (global){
/**
 * THIS DESIGN ONLY SUPPORTS ONE CHART AS THEY *SHARE* STATE
 * For a non-stupid design, do something like the
 * implementation in the article by Nicolas Hery:
 * http://nicolashery.com/integrating-d3js-visualizations-in-a-react-app
 *
 * Chart code more or less copied from the prototype by Leo Martin Westby
 */
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var AmCharts = (typeof window !== "undefined" ? window.AmCharts : typeof global !== "undefined" ? global.AmCharts : null);
var constants = require('../constants/ScienceTeamConstants');

var chart, chartUpdater, getNewValue, updateFrequency, maxSeconds;
var radiationSamples = [];

var _require = require('../utils');

var randomInt = _require.randomInt;

function initChart(domElement) {

    chart = new AmCharts.AmSerialChart();

    chart.marginTop = 20;
    chart.marginRight = 0;
    chart.marginLeft = 0;
    chart.autoMarginOffset = 0;
    chart.dataProvider = radiationSamples;
    chart.categoryField = 'timestamp';

    //X axis
    var categoryAxis = chart.categoryAxis;
    categoryAxis.dashLength = 1;
    categoryAxis.gridAlpha = 0.15;
    categoryAxis.axisColor = '#DADADA';
    categoryAxis.title = 'Seconds';

    //Y axis
    var valueAxis = new AmCharts.ValueAxis();
    valueAxis.axisAlpha = 0.2;
    valueAxis.dashLength = 1;
    valueAxis.title = 'μSv/h';
    valueAxis.minimum = constants.SCIENCE_RADIATION_MIN;
    valueAxis.maximum = constants.SCIENCE_RADIATION_MAX;
    chart.addValueAxis(valueAxis);

    //Line
    var graph = new AmCharts.AmGraph();
    graph.valueField = 'radiation';
    graph.bullet = 'round';
    graph.bulletBorderColor = '#FFFFFF';
    graph.bulletBorderThickness = 2;
    graph.lineThickness = 2;
    graph.lineColor = '#b5030d';
    graph.negativeLineColor = '#228B22';
    graph.negativeBase = 60;
    graph.hideBulletsCount = 50;
    chart.addGraph(graph);

    //Mouseover
    var chartCursor = new AmCharts.ChartCursor();
    chartCursor.cursorPosition = 'mouse';
    chart.addChartCursor(chartCursor);
    chart.write(domElement);
}

//Adds a new radiation sample to the chart every few seconds
function startEventLoop() {
    var startTime = Date.now();
    stopEventLoop();

    chartUpdater = setInterval(function () {
        var secondsPassed = (Date.now() - startTime) / 1000;

        radiationSamples.push({
            timestamp: Math.floor(secondsPassed + 0.5),
            radiation: getNewValue()
        });

        //When the chart grows, start cutting off the oldest sample to give the chart a sliding effect
        if (radiationSamples.length > maxSeconds / updateFrequency) {
            radiationSamples.shift();
        }

        chart.validateData();
    }, updateFrequency * 1000);
}

function stopEventLoop() {
    clearInterval(chartUpdater);
}

var RadiationChart = React.createClass({
    displayName: 'RadiationChart',

    statics: {},

    propTypes: {
        updateFrequencySeconds: React.PropTypes.number.isRequired,
        maxSecondsShown: React.PropTypes.number.isRequired,
        getNewValue: React.PropTypes.func.isRequired,
        height: React.PropTypes.number.isRequired,
        width: React.PropTypes.number
    },

    mixins: [],

    componentWillMount: function componentWillMount() {
        updateFrequency = this.props.updateFrequencySeconds;
        maxSeconds = this.props.maxSecondsShown;
        getNewValue = this.props.getNewValue;
    },

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        initChart(el);
        startEventLoop();
    },

    componentWillReceiveProps: function componentWillReceiveProps() {},

    componentWillUnmount: function componentWillUnmount() {
        chart && chart.clear();
        stopEventLoop();
    },

    componentDidUnmount: function componentDidUnmount() {
        chart = null;
        //radiationSamples.length = 0;
    },

    componentDidUpdate: function componentDidUpdate() {},

    // this chart is responsible for drawing itself
    shouldComponentUpdate: function shouldComponentUpdate() {
        return false;
    },

    // Private methods

    render: function render() {

        // if you don't specify width it will max out to 100% (which is ok)
        return React.createElement('div', {
            style: { width: this.props.width + 'px', height: this.props.height + 'px' },
            className: this.props.className
        });
    }

});

module.exports = RadiationChart;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-sampler.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null),
    TimerStore = require('../stores/timer-store'),
    MissionActionCreators = require('../actions/MissionActionCreators'),
    TimerActionCreators = require('../actions/TimerActionCreators'),
    ScienceActionCreators = require('../actions/ScienceActionCreators'),
    constants = require('../constants/ScienceTeamConstants');

var RadiationSampler = React.createClass({
    displayName: 'RadiationSampler',

    propTypes: {
        requiredSamples: React.PropTypes.number.isRequired,
        radiationStoreState: React.PropTypes.object.isRequired
    },

    componentWillMount: function componentWillMount() {
        TimerStore.addChangeListener(this._handleTimerChange);
    },

    componentDidUpdate: function componentDidUpdate() {
        if (this.state.timerActive) {
            var el = React.findDOMNode(this.refs['sample-button']);
            el.focus();
        }
    },

    componentWillUnmount: function componentWillUnmount() {
        TimerStore.removeChangeListener(this._handleTimerChange);
    },

    getInitialState: function getInitialState() {
        return { timerActive: false };
    },

    _isDisabled: function _isDisabled() {
        return !this.state.timerActive;
    },

    _handleTimerChange: function _handleTimerChange() {
        var audio = React.findDOMNode(this.refs.geigerSound);
        var timerActive = TimerStore.isRunning(constants.SCIENCE_TIMER_1);

        this.setState({ timerActive: timerActive });

        if (timerActive && audio.paused) {
            audio.play();
        } else if (!timerActive && !audio.paused) {
            audio.pause();
        }
    },

    _handleClick: function _handleClick() {
        ScienceActionCreators.takeRadiationSample();

        if (this.props.radiationStoreState.samples.length + 1 >= this.props.requiredSamples) {
            TimerActionCreators.stopTimer(constants.SCIENCE_TIMER_1);
            ScienceActionCreators.completeTask('sample');
        }
    },

    render: function render() {
        var disabled, classes;

        classes = 'btn btn-primary';

        if (this._isDisabled()) {
            classes += ' disabled';
        }

        return React.createElement(
            'section',
            { className: 'radiation-sampler ' + this.props.className },
            React.createElement('div', { className: 'radiation-sampler__padder clearfix visible-xs-block' }),
            React.createElement(
                'audio',
                { ref: 'geigerSound', loop: true },
                React.createElement('source', { src: '/sounds/AOS04595_Electric_Geiger_Counter_Fast.wav', type: 'audio/wav' })
            ),
            React.createElement(
                'div',
                null,
                React.createElement(
                    'button',
                    {
                        ref: 'sample-button',
                        className: classes,
                        onClick: this._handleClick
                    },
                    'Ta strålingsprøve'
                )
            )
        );
    }

});

module.exports = RadiationSampler;
/* Avoid floating into previous block */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../actions/ScienceActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js","../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","../stores/timer-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-table.react.js":[function(require,module,exports){
(function (global){
"use strict";

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

module.exports = React.createClass({
    displayName: "exports",

    statics: {},
    propTypes: {
        samples: React.PropTypes.array.isRequired,
        minimalRowsToShow: React.PropTypes.number
    },

    // Private methods

    getDefaultProps: function getDefaultProps() {
        return { minimalRowsToShow: 0 };
    },

    render: function render() {
        var sampleRows = this.props.samples.map(function (val, i) {
            return React.createElement(
                "tr",
                { key: i },
                React.createElement(
                    "th",
                    { scope: "row" },
                    i + 1
                ),
                React.createElement(
                    "td",
                    null,
                    val
                )
            );
        }),
            missingRows = this.props.minimalRowsToShow - sampleRows.length,
            fillRows = undefined;

        if (missingRows > 0) {
            fillRows = [];

            while (missingRows--) {
                fillRows.push(React.createElement(
                    "tr",
                    { key: fillRows.length },
                    React.createElement("th", { scope: "row" }),
                    React.createElement(
                        "td",
                        null,
                        " "
                    )
                ));
            }
        }

        return React.createElement(
            "div",
            { className: this.props.className },
            React.createElement(
                "h3",
                null,
                "Prøveresultater"
            ),
            React.createElement(
                "table",
                { className: " table table-bordered" },
                React.createElement(
                    "caption",
                    null,
                    "Strålingspartikler per sekund (p/s)"
                ),
                React.createElement(
                    "thead",
                    null,
                    React.createElement(
                        "tr",
                        null,
                        React.createElement(
                            "th",
                            { scope: "col" },
                            "Prøvenummer"
                        ),
                        React.createElement(
                            "th",
                            { scope: "col" },
                            "p/s"
                        )
                    )
                ),
                React.createElement(
                    "tbody",
                    null,
                    sampleRows,
                    fillRows
                )
            )
        );
    }

});
/* Needs filler to not collapse cell */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/science-task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var TimerPanel = require('./timer-panel.react');
var RadiationChart = require('./radiation-chart.react.js');
var RadiationSampleButton = require('./radiation-sampler.react');
var Overlay = require('./overlay.react');
var RadiationTable = require('./radiation-table.react');
var RadiationStore = require('../stores/radiation-store');
var actions = require('../actions/ScienceActionCreators');
var utils = require('../utils');
var ScienceTeamConstants = require('../constants/ScienceTeamConstants');
var TimerActionCreators = require('../actions/TimerActionCreators');

// SETTINGS
TimerActionCreators.setTimer(ScienceTeamConstants.SCIENCE_TIMER_1, 30);

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},
    propTypes: {
        appstate: React.PropTypes.object.isRequired
    },
    mixins: [],

    // life cycle methods
    getInitialState: function getInitialState() {
        return {
            radiation: RadiationStore.getState()
        };
    },

    getDefaultProps: function getDefaultProps() {
        return {};
    },

    componentWillMount: function componentWillMount() {
        RadiationStore.addChangeListener(this._handleRadiationChange);
    },

    componentWillReceiveProps: function componentWillReceiveProps() {},

    componentWillUnmount: function componentWillUnmount() {
        RadiationStore.removeChangeListener(this._handleRadiationChange);
    },

    // Private methods

    _handleRadiationChange: function _handleRadiationChange() {
        this.setState({
            radiation: RadiationStore.getState()
        });
    },

    _handleAverageRadiationSubmit: function _handleAverageRadiationSubmit(e) {
        var el = React.findDOMNode(this.refs['average-input']),
            val = el.value.trim();

        e.preventDefault();

        if (!val.length) {
            return;
        }var average = utils.parseNumber(val);
        el.value = '';

        if (average) {
            actions.averageRadiationCalculated(average);
        }
    },

    _handleAddToTotalSubmit: function _handleAddToTotalSubmit(e) {
        e.preventDefault();

        var el = React.findDOMNode(this.refs['add-to-total']);
        var val = el.value.trim();
        if (!val.length) {
            return;
        }var number = utils.parseNumber(val);

        if (!isNaN(number)) {
            actions.addToTotalRadiationLevel(number);
        }
    },

    /*
     * Helper
     * @param {string} taskName name
     * @returns {boolean} true if the current task id equals the name passed in
     */
    _isCurrentTask: function _isCurrentTask(taskName) {
        return this.props.appstate.taskStore.currentTaskId === taskName;
    },

    _radiationStatus: function _radiationStatus() {
        var num = this.state.radiation.lastCalculatedAverage,
            color;

        if (num === null) {
            return 'Ikke beregnet';
        }

        if (num > ScienceTeamConstants.SCIENCE_AVG_RAD_RED_THRESHOLD) {
            color = 'red';
        } else if (num > ScienceTeamConstants.SCIENCE_AVG_RAD_ORANGE_THRESHOLD) {
            color = 'orange';
        } else {
            color = 'green';
        }

        return React.createElement(
            'div',
            {
                className: 'radiation-indicator circle col-xs-2',
                style: { backgroundColor: color }
            },
            num
        );
    },

    render: function render() {
        var showSampleInput = this._isCurrentTask('sample'),
            showAverageInput = this._isCurrentTask('average'),
            showAddToTotalInput = this._isCurrentTask('addtotal');

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'dl',
                    { className: 'radiation-values col-xs-6 ' },
                    React.createElement(
                        'dt',
                        null,
                        'Totalt strålingsnivå'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        this.state.radiation.total
                    ),
                    React.createElement(
                        'dt',
                        null,
                        'Sist innlest strålingsnivå'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        this._radiationStatus(),
                        ' '
                    )
                ),
                React.createElement(RadiationTable, {
                    minimalRowsToShow: 4,
                    samples: this.state.radiation.samples,
                    className: 'col-xs-6 ' })
            ),
            React.createElement('hr', null),
            React.createElement(
                'div',
                { className: 'instruments' },
                React.createElement(
                    'fieldset',
                    { disabled: !showSampleInput, className: 'instruments__section row overlayable' },
                    React.createElement(Overlay, { active: !showSampleInput }),
                    React.createElement(
                        'h3',
                        { className: 'col-xs-12' },
                        'Ta prøver'
                    ),
                    React.createElement(TimerPanel, { className: 'col-xs-12 col-sm-8', timerId: ScienceTeamConstants.SCIENCE_TIMER_1 }),
                    React.createElement(RadiationSampleButton, {
                        className: 'col-xs-5 col-sm-4',
                        radiationStoreState: this.state.radiation,
                        requiredSamples: 4
                    })
                ),
                React.createElement('hr', null),
                React.createElement(
                    'div',
                    { className: 'row overlayable' },
                    React.createElement(Overlay, { active: !showAverageInput }),
                    React.createElement(
                        'section',
                        { className: 'radiation-input instruments__section col-xs-12 col-sm-6' },
                        React.createElement(
                            'div',
                            { className: 'row' },
                            React.createElement(
                                'h3',
                                { className: 'col-xs-12' },
                                'Gjennomsnittlig stråling'
                            ),
                            React.createElement(
                                'fieldset',
                                { className: 'col-xs-8', disabled: !showAverageInput },
                                React.createElement(
                                    'form',
                                    { onSubmit: this._handleAverageRadiationSubmit },
                                    React.createElement('input', { ref: 'average-input',
                                        type: 'number',
                                        step: '0.1',
                                        min: '1',
                                        max: '100',
                                        className: 'radiation-input__input'
                                    }),
                                    React.createElement(
                                        'button',
                                        { className: 'btn btn-primary' },
                                        'Evaluer'
                                    )
                                )
                            )
                        )
                    )
                ),
                React.createElement('hr', null),
                React.createElement(
                    'div',
                    { className: 'row overlayable' },
                    React.createElement(Overlay, { active: !showAddToTotalInput }),
                    React.createElement(
                        'fieldset',
                        { className: 'radiation-input col-xs-8', disabled: !showAddToTotalInput },
                        React.createElement(
                            'h3',
                            null,
                            'Legg verdi til total'
                        ),
                        React.createElement(
                            'form',
                            { onSubmit: this._handleAddToTotalSubmit },
                            React.createElement(
                                'select',
                                { ref: 'add-to-total', className: 'radiation-input__input' },
                                React.createElement(
                                    'option',
                                    { value: '0' },
                                    '0'
                                ),
                                React.createElement(
                                    'option',
                                    { value: '15' },
                                    '15'
                                ),
                                React.createElement(
                                    'option',
                                    { value: '50' },
                                    '50'
                                )
                            ),
                            React.createElement(
                                'button',
                                { className: 'btn btn-primary' },
                                'Evaluer'
                            )
                        )
                    )
                )
            )
        );
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/ScienceActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js","../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","../stores/radiation-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/radiation-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./overlay.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/overlay.react.js","./radiation-chart.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-chart.react.js","./radiation-sampler.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-sampler.react.js","./radiation-table.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-table.react.js","./timer-panel.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer-panel.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/security-task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var CO2Store = require('../stores/carbon-dioxide-store');
var OxygenStore = require('../stores/oxygen-store');
var CommunicationQualityStore = require('../stores/communication-quality-store');
var SecurityTeamAC = require('../actions/SecurityTeamActionCreators');

var chart = null;
var chartData = [{ title: 'Luft', value: 100 }];

function init(domElem) {
    chart = new AmCharts.AmPieChart();
    chart.valueField = 'value';
    chart.titleField = 'title';
    chart.dataProvider = chartData;
    chart.write(domElem);
}

var PieChart = React.createClass({
    displayName: 'PieChart',

    propTypes: {
        height: React.PropTypes.string.isRequired,
        width: React.PropTypes.string
    },

    componentWillMount: function componentWillMount() {
        var _this = this;

        CO2Store.addChangeListener(function () {
            return _this._updateData();
        });
    },

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        init(el);
    },

    shouldComponentUpdate: function shouldComponentUpdate() {
        return false;
    },

    _updateData: function _updateData() {
        var co2 = CO2Store.co2Level();
        chartData.length = 0;
        chartData.push({ title: 'Annen luft', value: 100 - co2 });
        chartData.push({ title: 'CO₂', value: co2 });

        chart.validateData();
    },

    render: function render() {
        return React.createElement('div', { style: { height: this.props.height, width: this.props.width } });
    }
});

var ProgressBar = React.createClass({
    displayName: 'ProgressBar',

    propTypes: {
        progress: React.PropTypes.number.isRequired,
        max: React.PropTypes.number.isRequired,
        active: React.PropTypes.bool.isRequired,
        className: React.PropTypes.string
    },

    render: function render() {
        var val = this.props.progress,
            max = this.props.max;
        return React.createElement(
            'div',
            { className: 'progress' },
            React.createElement(
                'div',
                {
                    className: 'progress-bar progress-bar-striped ' + this.props.className + (this.props.active ? ' active' : ''),
                    style: { width: val * max + '%' },
                    role: 'progressbar' },
                Math.min(Math.round(val * max), max),
                '%'
            )
        );
    }
});

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},

    propTypes: {},

    mixins: [],

    getInitialState: function getInitialState() {
        var state = this._getState();
        state.commProgress = 0;
        state.qualityProgress = 0;
        state.dataQualityFailing = true;
        state.readyForSafeMode = false;
        return state;
    },

    componentWillMount: function componentWillMount() {
        var _this2 = this;

        OxygenStore.addChangeListener(function () {
            return _this2._updateState();
        });
        CommunicationQualityStore.addChangeListener(function () {
            return _this2._updateState();
        });
    },

    componentWillUnmount: function componentWillUnmount() {},

    _startQualityProgressBar: function _startQualityProgressBar() {
        var _this3 = this;

        var ms = 500,
            totalDuration = 5 * 1000;
        this.setState({ qualityProgress: 0 });

        var tmp = setInterval(function () {
            var number = _this3.state.qualityProgress;
            number += ms / totalDuration;

            if (number >= 1) {
                clearInterval(tmp);
                SecurityTeamAC.endDataQualityTest(!_this3.state.dataQualityFailing);
                setTimeout(function () {
                    return _this3.setState({ qualityProgress: 0 });
                }, 9000);
            }

            _this3.setState({ qualityProgress: number });
        }, ms);
    },

    _startTransferProgressBar: function _startTransferProgressBar() {
        var _this4 = this;

        var ms = 500,
            totalDuration = 5 * 1000;
        this.setState({ commProgress: 0 });

        var tmp = setInterval(function () {
            var number = _this4.state.commProgress;
            number += ms / totalDuration;

            if (number >= 1) {
                clearInterval(tmp);
                SecurityTeamAC.endDataTransferTest(!_this4.state.dataTransferFailing);
                setTimeout(function () {
                    return _this4.setState({ commProgress: 0 });
                }, 9000);
            }

            _this4.setState({ commProgress: number });
        }, ms);
    },

    _qualityActive: function _qualityActive() {
        return this.state.qualityProgress < 1;
    },

    _commActive: function _commActive() {
        return this.state.commProgress < 1;
    },

    _updateState: function _updateState() {
        this.setState(this._getState());
    },

    _indicatorColor: function _indicatorColor() {
        return this.state.oxygenStore.colorIndicator;
    },

    _getState: function _getState() {
        return {
            oxygenStore: OxygenStore.getState(),
            dataQualityFailing: CommunicationQualityStore.qualityTestShouldFail(),
            dataTransferFailing: CommunicationQualityStore.transferTestShould(),
            readyForSafeMode: CommunicationQualityStore.readyForSafeMode()
        };
    },

    render: function render() {

        var indicator = React.createElement('div', {
            className: 'circle ',
            style: { display: 'inline-block', backgroundColor: this._indicatorColor() }
        });

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'col-sm-6' },
                    React.createElement(
                        'button',
                        {
                            style: { marginBottom: '20px' },
                            className: 'btn btn-primary ' + (this.state.readyForSafeMode ? '' : 'disabled'),
                            onClick: SecurityTeamAC.setInSafeMode
                        },
                        'Send i SAFE MODE'
                    ),
                    React.createElement(
                        'ul',
                        { className: '' },
                        React.createElement(
                            'li',
                            null,
                            'Scrubfilter byttet: ',
                            CO2Store.filterChanged() ? 'ja' : 'nei'
                        ),
                        React.createElement(
                            'li',
                            null,
                            'Oksygenindikator: ',
                            indicator,
                            ' '
                        )
                    )
                ),
                React.createElement(
                    'div',
                    { className: 'col-xs-12 col-sm-6' },
                    React.createElement(
                        'h3',
                        null,
                        'Innhold karbondioksid i drakten av total luftmengde'
                    ),
                    React.createElement(PieChart, { height: '200px' })
                )
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: '' },
                    React.createElement(
                        'p',
                        { className: '' },
                        'Kommunikasjon og data'
                    ),
                    React.createElement(
                        'p',
                        null,
                        'Kommunikasjonsstatus '
                    ),
                    React.createElement(ProgressBar, {
                        max: 100,
                        active: this._commActive(),
                        className: this.state.dataTransferFailing ? !this._commActive() ? 'progress-bar-danger' : '' : '',
                        progress: this.state.commProgress }),
                    React.createElement(
                        'button',
                        { onClick: this._startTransferProgressBar,
                            className: 'btn btn-primary' },
                        'Test'
                    ),
                    React.createElement(
                        'p',
                        null,
                        'Datakvalitet'
                    ),
                    React.createElement(ProgressBar, {
                        max: 100,
                        active: this._qualityActive(),
                        className: this.state.dataQualityFailing ? !this._qualityActive() ? 'progress-bar-danger' : '' : '',
                        progress: this.state.qualityProgress }),
                    React.createElement(
                        'button',
                        { className: 'btn btn-primary ' + (this.state.dataTransferFailing ? 'disabled' : ''),
                            onClick: this._startQualityProgressBar
                        },
                        'Test'
                    )
                )
            )
        );
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/SecurityTeamActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/SecurityTeamActionCreators.js","../stores/carbon-dioxide-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/carbon-dioxide-store.js","../stores/communication-quality-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/communication-quality-store.js","../stores/oxygen-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/oxygen-store.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var MessageStore = require('../stores/message-store');
var TaskStore = require('../stores/task-store');
var RouteStore = require('../stores/route-store');
var MessageList = require('./message-list.react');
var IntroductionScreen = require('./introduction-screen.react.js');
var TeamDisplayer = require('./team-displayer.react');
var MissionTimer = require('./mission-timer.react.js');
var ScienceTask = require('./science-task.react');
var AstronautTask = require('./astronaut-task.react');
var CommunicationTask = require('./communication-task.react.js');
var SecurityTask = require('./security-task.react.js');
var _require = require('util');

var format = _require.format;

// lazyrequire
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
if (false) {
    require('../actions/MissionActionCreators');
}
var getMissionAC = lazyRequire('../actions/MissionActionCreators');

function urlOfTask(taskId) {
    return format('/%s/task/%s', RouteStore.getTeamId(), taskId);
}

function transitionToCurrentTask(transitionFunction) {
    var currentTaskId = TaskStore.getCurrentTaskId();

    // this logic is fragile - if you should suddenly decide to visit another team
    // _after_ you have started a task, the team+task combo is invalid -> 404
    if (currentTaskId !== RouteStore.getTaskId()) {
        var to = urlOfTask(currentTaskId);
        transitionFunction(to);
    }
}

var Task = React.createClass({
    displayName: 'Task',

    contextTypes: {
        router: React.PropTypes.func
    },

    mixins: [],

    statics: {
        willTransitionTo: function willTransitionTo(transition) {
            transitionToCurrentTask(transition.redirect.bind(transition));
        }
    },

    componentDidMount: function componentDidMount() {},

    componentWillMount: function componentWillMount() {
        MessageStore.addChangeListener(this._onChange);
        TaskStore.addChangeListener(this._onChange);
        //console.log('componentWillMount');
    },

    componentWillUnmount: function componentWillUnmount() {
        //console.log('componentWillUnmount');
        MessageStore.removeChangeListener(this._onChange);
        TaskStore.removeChangeListener(this._onChange);

        clearTimeout(this._stateTimeout);
    },

    componentDidUnmount: function componentDidUnmount() {},

    componentDidUpdate: function componentDidUpdate() {},

    getInitialState: function getInitialState() {
        var _this = this;

        setTimeout(function () {
            return _this.setState({ taskIsNew: false });
        }, 2000);

        return {
            messages: MessageStore.getMessages(),
            taskStore: TaskStore.getState(),
            taskIsNew: true
        };
    },

    _onChange: function _onChange() {
        var _this2 = this;

        this.setState({
            messages: MessageStore.getMessages(),
            taskStore: TaskStore.getState(),
            taskIsNew: true
        });

        var router = this.context.router;
        transitionToCurrentTask(router.transitionTo.bind(router));

        // a bit rudimentary - triggers on all changes, not just Task changes ...
        this._stateTimeout = setTimeout(function () {
            return _this2.setState({ taskIsNew: false });
        }, 2000);
    },

    _createSubTaskUI: function _createSubTaskUI() {
        switch (RouteStore.getTeamId()) {
            case 'science':
                return React.createElement(ScienceTask, { appstate: this.state });
            case 'astronaut':
                return React.createElement(AstronautTask, { appstate: this.state });
            case 'communication':
                return React.createElement(CommunicationTask, { appstate: this.state });
            case 'security':
                return React.createElement(SecurityTask, { appstate: this.state });
        }
    },

    _handleTaskOKClick: function _handleTaskOKClick() {
        getMissionAC().taskCompleted(RouteStore.getTeamId(), this.state.taskStore.currentTaskId);
    },

    render: function render() {
        var content = this._createSubTaskUI(),
            blink = this.state.taskIsNew ? 'blink' : '',
            teamNames = undefined,
            missionTimer = undefined;

        teamNames = React.createElement(
            'div',
            { id: 'team-name', className: '' },
            React.createElement(
                'header',
                { className: '' },
                React.createElement(TeamDisplayer, { className: '' })
            )
        );

        missionTimer = React.createElement(
            'section',
            { id: 'mission-timer', className: '' },
            React.createElement(MissionTimer, null)
        );

        if (!this.props.isMissionRunning) {
            var message = {
                id: 'not_used',
                text: 'Ikke klar. Venter på at oppdraget skal starte.',
                level: 'info'
            };

            return React.createElement(
                'div',
                null,
                teamNames,
                React.createElement(
                    'div',
                    { className: 'row' },
                    React.createElement(MessageList, { className: 'col-xs-12',
                        messages: [message] })
                )
            );
        }

        return React.createElement(
            'div',
            { className: '' },
            teamNames,
            missionTimer,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(MessageList, { className: 'col-xs-12', messages: this.state.messages })
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'col-xs-12' },
                    React.createElement(
                        'div',
                        { className: 'jumbotron taskbox' },
                        React.createElement(
                            'h2',
                            { className: 'taskbox__header' },
                            'Oppgave'
                        ),
                        React.createElement(
                            'span',
                            { className: 'taskbox__text ' + blink },
                            ' ',
                            this.state.taskStore.currentTask,
                            ' '
                        ),
                        this.state.taskStore.plainInfo && React.createElement(
                            'button',
                            { className: 'btn-primary btn',
                                onClick: this._handleTaskOKClick
                            },
                            'OK'
                        )
                    )
                )
            ),
            content
        );
    }

});

module.exports = Task;

//console.log('componentDidUnmount');

//console.log('.componentDidUpdate');
/* if you want this to be sticky: http://codepen.io/senff/pen/ayGvD */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../stores/message-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/message-store.js","../stores/route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","../stores/task-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/task-store.js","./astronaut-task.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/astronaut-task.react.js","./communication-task.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/communication-task.react.js","./introduction-screen.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/introduction-screen.react.js","./message-list.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/message-list.react.js","./mission-timer.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-timer.react.js","./science-task.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/science-task.react.js","./security-task.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/security-task.react.js","./team-displayer.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/team-displayer.react.js","util":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/util.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/team-displayer.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var RouteStore = require('../stores/route-store');
var teamNames = require('../team-name-map');

var TeamWidget = React.createClass({
    displayName: 'TeamWidget',

    contextTypes: {
        router: React.PropTypes.func
    },

    mixins: [],

    _onChange: function _onChange() {
        this.forceUpdate();
    },

    componentDidMount: function componentDidMount() {},

    componentWillUnmount: function componentWillUnmount() {},

    teamName: function teamName() {
        return teamNames.nameMap[RouteStore.getTeamId()];
    },

    otherTeamNames: function otherTeamNames() {
        return teamNames.otherTeamNames(RouteStore.getTeamId());
    },

    render: function render() {

        return React.createElement(
            'div',
            { className: this.props.className + ' teamwidget' },
            React.createElement(
                'span',
                { className: 'active' },
                this.teamName()
            ),
            React.createElement(
                'span',
                { className: '' },
                ', ',
                this.otherTeamNames(),
                ' '
            )
        );
    }
});

module.exports = TeamWidget;

//RouteStore.addChangeListener(this._onChange);

//RouteStore.removeChangeListener(this._onChange);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","../team-name-map":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/team-name-map.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer-panel.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null),
    actions = require('../actions/TimerActionCreators'),
    Timer = require('./timer.react.js'),
    TimerStore = require('../stores/timer-store');

module.exports = React.createClass({
    displayName: 'exports',

    propTypes: {
        timerId: React.PropTypes.string.isRequired
    },

    getInitialState: function getInitialState() {
        return this._getTimerState();
    },

    componentDidMount: function componentDidMount() {
        TimerStore.addChangeListener(this._handleTimeStoreChange);
    },

    componentWillUnmount: function componentWillUnmount() {
        TimerStore.removeChangeListener(this._handleTimeStoreChange);
    },

    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
        return nextState.timeInSeconds !== this.state.timeInSeconds;
    },

    componentDidUpdate: function componentDidUpdate() {},

    _handleTimeStoreChange: function _handleTimeStoreChange() {
        this.setState(this._getTimerState());
    },

    _handleClick: function _handleClick() {
        actions.startTimer(this.props.timerId);
    },

    _getTimerState: function _getTimerState() {
        return {
            ready: TimerStore.isReadyToStart(this.props.timerId),
            timeInSeconds: TimerStore.getRemainingTime(this.props.timerId)
        };
    },

    render: function render() {
        return React.createElement(
            'section',
            { className: 'timer ' + this.props.className },
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'timer--button col-xs-5 ' },
                    React.createElement(
                        'button',
                        {
                            className: 'btn btn-primary ' + (this.state.ready ? '' : 'disabled'),
                            onClick: this._handleClick },
                        'Start klokka'
                    )
                ),
                React.createElement(
                    'div',
                    { className: 'timer--value col-xs-6 padding-xs-1' },
                    React.createElement(Timer, { timeInSeconds: this.state.timeInSeconds })
                )
            )
        );
    }
});

//console.log('TimerPanel.componentDidUpdate');

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../stores/timer-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js","./timer.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer.react.js":[function(require,module,exports){
(function (global){
// This example can be modified to act as a countdown timer

'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null),
    printf = require('printf');

function pad(num) {
    return printf('%02d', num);
}

var Timer = React.createClass({
    displayName: 'Timer',

    propTypes: {
        timeInSeconds: React.PropTypes.number.isRequired
    },

    componentDidUpdate: function componentDidUpdate() {},

    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
        return nextProps.timeInSeconds !== this.props.timeInSeconds;
    },

    _minutes: function _minutes() {
        return pad(Math.max(0, this.props.timeInSeconds) / 60 >> 0);
    },

    _seconds: function _seconds() {
        return pad(Math.max(0, this.props.timeInSeconds) % 60);
    },

    _timeValue: function _timeValue() {
        return this._minutes() + ':' + this._seconds();
    },

    render: function render() {
        return React.createElement(
            'div',
            { className: 'timer-value' },
            ' ',
            this._timeValue()
        );
    }
});

module.exports = Timer;

//console.log('Timer.componentDidUpdate');

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"printf":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/printf/lib/printf.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js":[function(require,module,exports){
'use strict';

window.__astConst = module.exports = {
    GOOD_OXYGEN: 'GOOD_OXYGEN',
    WARN_OXYGEN: 'WARN_OXYGEN',
    CRITICAL_OXYGEN: 'CRITICAL_OXYGEN',
    LOW_RESP_RATE: 'LOW_RESP_RATE',
    HIGH_RESP_RATE: 'HIGH_RESP_RATE',

    /* remove? don't think they are used */
    SET_HEART_RATE: 'SET_HEART_RATE',
    SET_OXYGEN_LEVEL: 'SET_OXYGEN_LEVEL',
    SET_OXYGEN_CONSUMPTION: 'SET_OXYGEN_CONSUMPTION',

    HEART_RATE_TIMER: 'HEART_RATE_TIMER',
    RESPIRATION_TIMER: 'RESPIRATION_TIMER'
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MessageConstants.js":[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

module.exports = _Object$freeze({
    // events
    MESSAGE_ADDED: 'MESSAGE_ADDED',
    REMOVE_MESSAGE: 'REMOVE_MESSAGE'
});

},{"babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js":[function(require,module,exports){
'use strict';

module.exports = require('react/lib/keyMirror')({
    MISSION_TIME_SYNC: 'MISSION_TIME_SYNC',
    MISSION_STARTED_EVENT: 'MISSION_STARTED_EVENT',
    MISSION_STOPPED_EVENT: 'MISSION_STOPPED_EVENT',
    MISSION_COMPLETED_EVENT: 'MISSION_COMPLETED_EVENT',
    MISSION_WAS_RESET: 'MISSION_WAS_RESET',
    RECEIVED_EVENTS: null,
    INTRODUCTION_READ: 'INTRODUCTION_READ',
    START_TASK: 'START_TASK',
    COMPLETED_TASK: 'COMPLETED_TASK',
    ASK_FOR_APP_STATE: 'ASK_FOR_APP_STATE',
    RECEIVED_APP_STATE: 'RECEIVED_APP_STATE',
    SENDING_TEAM_STATE: 'SENDING_TEAM_STATE'
});

},{"react/lib/keyMirror":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/keyMirror.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/RouterConstants.js":[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

module.exports = _Object$freeze({
    // events
    ROUTE_CHANGED_EVENT: 'ROUTE_CHANGED_EVENT',
    ROUTER_AVAILABLE: 'ROUTER_AVAILABLE' });

},{"babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js":[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

module.exports = _Object$freeze({
    // ids
    SCIENCE_TIMER_1: 'SCIENCE_TIMER_1',
    SCIENCE_RADIATION_WARNING_MSG: 'SCIENCE_RADIATION_WARNING_MSG',

    SCIENCE_CLEAR_RADIATION_SAMPLES: 'SCIENCE_CLEAR_RADIATION_SAMPLES',

    // events
    SCIENCE_COUNTDOWN_TIMER_CHANGED: 'SCIENCE_COUNTDOWN_TIMER_CHANGED',
    SCIENCE_TAKE_RADIATION_SAMPLE: 'SCIENCE_TAKE_RADIATION_SAMPLE',
    SCIENCE_RADIATION_LEVEL_CHANGED: 'SCIENCE_RADIATION_LEVEL_CHANGED',
    SCIENCE_TOTAL_RADIATION_LEVEL_CHANGED: 'SCIENCE_TOTAL_RADIATION_LEVEL_CHANGED',
    SCIENCE_AVG_RADIATION_CALCULATED: 'SCIENCE_AVG_RADIATION_CALCULATED',

    // values
    SCIENCE_RADIATION_MIN: 0,
    SCIENCE_RADIATION_MAX: 100,
    SCIENCE_AVG_RAD_GREEN_VALUE: 0,
    SCIENCE_AVG_RAD_ORANGE_VALUE: 15,
    SCIENCE_AVG_RAD_RED_VALUE: 50,
    SCIENCE_AVG_RAD_ORANGE_THRESHOLD: 40,
    SCIENCE_AVG_RAD_RED_THRESHOLD: 75,
    SCIENCE_TOTAL_RADIATION_SERIOUS_THRESHOLD: 50,
    SCIENCE_TOTAL_RADIATION_VERY_SERIOUS_THRESHOLD: 75
});

},{"babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/TimerConstants.js":[function(require,module,exports){
'use strict';

module.exports = {
    SET_TIMER: 'SET_TIMER',
    START_TIMER: 'START_TIMER',
    STOP_TIMER: 'STOP_TIMER',
    RESET_TIMER: 'RESET_TIMER'
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js":[function(require,module,exports){
(function (global){
// proxy access to the router as first step in bringing it into the flux flow
// @see https://github.com/rackt/react-router/blob/master/docs/guides/flux.md

'use strict';

var router = null;

window.__router = module.exports = {
    transitionTo: function transitionTo(to, params, query) {
        return router.transitionTo(to, params, query);
    },

    getCurrentPathname: function getCurrentPathname() {
        return window.location.pathname;
    },

    getTeamId: function getTeamId() {
        return this.getCurrentPathname().split('/')[1];
    },

    getTaskId: function getTaskId() {
        return this.getCurrentPathname().split('/')[3];
    },

    run: function run() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return router.run.apply(router, args);
    }
};

var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var routes = require('./routes.react');

// By the time route config is require()-d,
// require('./router') already returns a valid object

router = Router.create({
    routes: routes,

    // Use the HTML5 History API for clean URLs
    location: Router.HistoryLocation
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./routes.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/routes.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/routes.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var Route = Router.Route;
var NotFoundRoute = Router.NotFoundRoute;
var DefaultRoute = Router.DefaultRoute;

var App = require('./components/app.react');
var MissionCommanderApp = require('./components/mission-commander.react.js');
var IndexApp = require('./components/index-app.react');
var NotFound = require('./components/not-found.react');
var IntroScreen = require('./components/introduction-screen.react');
var SolarStorm = require('./components/full-screen-video.js');
var Task = require('./components/task.react');
var DummyRenderMixin = require('./components/dummy-render.mixin');

var _require = require('./utils');

var cleanRootPath = _require.cleanRootPath;

var teamNameMap = require('./team-name-map');

var RedirectToIntro = React.createClass({
    displayName: 'RedirectToIntro',

    statics: {
        willTransitionTo: function willTransitionTo(transition) {
            var teamId = cleanRootPath(transition.path);

            if (teamId in teamNameMap.nameMap) {
                transition.redirect(transition.path + '/intro');
            }
        }
    },

    //mixins : [DummyRenderMixin]
    render: function render() {
        return React.createElement(NotFound, null);
    }
});

var routes = React.createElement(
    Route,
    { name: 'app', path: '/', handler: App },
    React.createElement(Route, { name: 'job-completed', path: '/completed', handler: SolarStorm }),
    React.createElement(Route, { name: 'commander', handler: MissionCommanderApp }),
    React.createElement(Route, { name: 'team-root', path: '/:teamId', handler: RedirectToIntro }),
    React.createElement(Route, { name: 'team-intro', path: '/:teamId/intro', handler: IntroScreen }),
    React.createElement(Route, { name: 'team-task', path: '/:teamId/task/:taskId', handler: Task }),
    React.createElement(NotFoundRoute, { handler: NotFound }),
    React.createElement(DefaultRoute, { handler: IndexApp })
);

module.exports = routes;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./components/app.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/app.react.js","./components/dummy-render.mixin":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/dummy-render.mixin.js","./components/full-screen-video.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/full-screen-video.js","./components/index-app.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/index-app.react.js","./components/introduction-screen.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/introduction-screen.react.js","./components/mission-commander.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-commander.react.js","./components/not-found.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/not-found.react.js","./components/task.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/task.react.js","./team-name-map":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/team-name-map.js","./utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js":[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var EventEmitter = require('events');
var CHANGE_EVENT = 'CHANGE_EVENT';

var path = null;

var BaseStore = (function (_EventEmitter) {
    function BaseStore() {
        _classCallCheck(this, BaseStore);

        if (_EventEmitter != null) {
            _EventEmitter.apply(this, arguments);
        }
    }

    _inherits(BaseStore, _EventEmitter);

    _createClass(BaseStore, [{
        key: 'emitChange',
        value: function emitChange() {
            this.emit(CHANGE_EVENT);
        }
    }, {
        key: 'addChangeListener',

        /**
         * @param {function} callback
         * @returns emitter, so calls can be chained.
         */
        value: function addChangeListener(callback) {
            return this.on(CHANGE_EVENT, callback);
        }
    }, {
        key: 'removeChangeListener',

        /**
         * @param {function} callback
         * @returns emitter, so calls can be chained.
         */
        value: function removeChangeListener(callback) {
            return this.removeListener(CHANGE_EVENT, callback);
        }
    }, {
        key: 'dispatcherIndex',
        value: undefined,
        enumerable: true
    }]);

    return BaseStore;
})(EventEmitter);

module.exports = BaseStore;

},{"babel-runtime/helpers/class-call-check":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/class-call-check.js","babel-runtime/helpers/create-class":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/create-class.js","babel-runtime/helpers/inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/inherits.js","events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/breath-rate-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MConstants = require('../constants/MissionConstants');
var AstConstants = require('../constants/AstroTeamConstants');
var BaseStore = require('./base-store');

var current = AstConstants.LOW_RESP_RATE;

var BreathRateStore = module.exports = _Object$assign(new BaseStore(), {

    getState: function getState() {
        if (current == AstConstants.LOW_RESP_RATE) {
            return { rate: current, min: 23, max: 28 };
        } else {
            return { rate: current, min: 45, max: 55 };
        }
    },

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {
            case MConstants.RECEIVED_APP_STATE:
                var appState = payload.appState;

                if (appState.breath_rate === 'high') {
                    current = AstConstants.HIGH_RESP_RATE;
                } else {
                    current = AstConstants.LOW_RESP_RATE;
                }

                BreathRateStore.emitChange();
                break;
        }

        return true;
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/carbon-dioxide-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MissionConstants = require('../constants/MissionConstants');
var BaseStore = require('./base-store');

var level = 0;
var filterChanged = false;

var CO2Store = module.exports = _Object$assign(new BaseStore(), {

    co2Level: function co2Level() {
        return level;
    },

    filterChanged: (function (_filterChanged) {
        function filterChanged() {
            return _filterChanged.apply(this, arguments);
        }

        filterChanged.toString = function () {
            return _filterChanged.toString();
        };

        return filterChanged;
    })(function () {
        return filterChanged;
    }),

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {
            case MissionConstants.RECEIVED_APP_STATE:
                var appState = payload.appState;

                level = appState.carbon_dioxide;
                filterChanged = appState.scrub_filter_changed;
                CO2Store.emitChange();
                break;
        }

        return true;
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/communication-quality-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var MissionConstants = require('../constants/MissionConstants');
var BaseStore = require('./base-store');
var qualityShouldFail = true;
var transferShouldFail = true;
var _readyForSafeMode = false;

var CommunicationQualityStore = module.exports = _Object$assign(new BaseStore(), {

    qualityTestShouldFail: function qualityTestShouldFail() {
        return qualityShouldFail;
    },

    transferTestShould: function transferTestShould() {
        return transferShouldFail;
    },

    readyForSafeMode: function readyForSafeMode() {
        return _readyForSafeMode;
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {

        if (payload.action === MissionConstants.RECEIVED_APP_STATE) {
            qualityShouldFail = payload.appState.quality_test_should_fail;
            transferShouldFail = payload.appState.transfer_test_should_fail;
            _readyForSafeMode = payload.appState.ready_for_safe_mode;

            CommunicationQualityStore.emitChange();
        }
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/event-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MConstants = require('../constants/MissionConstants');
var BaseStore = require('./base-store');

var eventsCollection = {
    remaining: [],
    completed: [],
    overdue: []
};

var EventStore = module.exports = window.__eventStore = _Object$assign(new BaseStore(), {

    remaining: function remaining() {
        return eventsCollection.remaining;
    },

    completed: function completed() {
        return eventsCollection.completed;
    },

    overdue: function overdue() {
        return eventsCollection.overdue;
    },

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {

            case MConstants.RECEIVED_EVENTS:
                eventsCollection.remaining = payload.remaining;
                eventsCollection.overdue = payload.overdue;
                eventsCollection.completed = payload.completed;
                EventStore.emitChange();

                break;
        }

        return true;
    })
});

//window.__eventStore = module.exports;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/heart-rate-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MConstants = require('../constants/MissionConstants');
var AstConstants = require('../constants/AstroTeamConstants');
var BaseStore = require('./base-store');

var current = { min: 60, max: 70 };

var HeartRateStore = module.exports = _Object$assign(new BaseStore(), {

    // om vi vil backe opp verdier på server må vi bruke denne storen
    getState: function getState() {
        return current;
    },

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {
            case MConstants.RECEIVED_APP_STATE:
                var rate = payload.appState.heart_rate;
                if (rate && rate.min && rate.max) {
                    current = rate;
                    HeartRateStore.emitChange();
                }
                break;
        }

        return true;
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/introduction-store.js":[function(require,module,exports){
/* Holds the state of whether introductions have been read */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');
var MissionConstants = require('../constants/MissionConstants');
var RouteStore = require('./route-store');

var introRead = {};

var IntroductionStore = _Object$assign(new BaseStore(), {

    setIntroductionRead: function setIntroductionRead(team) {
        introRead['intro_' + team] = true;
        this.emitChange();
    },

    isIntroductionRead: function isIntroductionRead(team) {
        if (!team) {
            throw new Error('Missing argument "team"');
        }

        return introRead['intro_' + team];
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;

        switch (action) {
            case MissionConstants.INTRODUCTION_READ:
                IntroductionStore.setIntroductionRead(payload.teamName);
                break;

            case MissionConstants.RECEIVED_APP_STATE:
                var teamId = RouteStore.getTeamId();

                var teamState = payload.appState[teamId];

                if (teamState && teamState.introduction_read) {
                    IntroductionStore.setIntroductionRead(teamState.team);
                }
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__IntroductionStore = IntroductionStore;
module.exports = IntroductionStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","./route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/message-store.js":[function(require,module,exports){
/* A store that can be queried for the current path */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _require = require('events');

var Emitter = _require.Emitter;

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');

var _require2 = require('../constants/MessageConstants');

var REMOVE_MESSAGE = _require2.REMOVE_MESSAGE;
var MESSAGE_ADDED = _require2.MESSAGE_ADDED;

var messages = {};

var MessageStore = _Object$assign(new BaseStore(), {

    reset: function reset() {
        messages = {};
        this.emitChange();
    },

    handleAddedMessage: function handleAddedMessage(data) {
        data.dismissable = data.dismissable === undefined ? true : data.dismissable;
        messages[data.id] = data;
        this.emitChange();
    },

    handleRemoveMessage: function handleRemoveMessage(id) {
        delete messages[id];
        this.emitChange();
    },

    /**
     * A list of all messages matching filter
     * @param [filter]
     * @returns []Message a Message = { text, id, level }
     */
    getMessages: function getMessages(filter) {
        if (!filter) {
            return _Object$keys(messages).map(function (msgKey) {
                return messages[msgKey];
            });
        } else throw new Error('UNIMPLEMENTED "filter" feature');
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;
        var data = payload.data;

        switch (action) {
            case MESSAGE_ADDED:
                MessageStore.handleAddedMessage(data);
                break;
            case REMOVE_MESSAGE:
                MessageStore.handleRemoveMessage(data);
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__MessageStore = MessageStore;
module.exports = MessageStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MessageConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MessageConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","babel-runtime/core-js/object/keys":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/keys.js","events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/mission-state-store.js":[function(require,module,exports){
/* A store that can be queried for the current path */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _require = require('events');

var Emitter = _require.Emitter;

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');

var _require2 = require('../constants/MissionConstants');

var MISSION_STARTED_EVENT = _require2.MISSION_STARTED_EVENT;
var MISSION_STOPPED_EVENT = _require2.MISSION_STOPPED_EVENT;
var RECEIVED_APP_STATE = _require2.RECEIVED_APP_STATE;

var missionRunning = false,
    missionHasBeenStopped = false;
var currentChapter = null;
var chapterTime = 0;
var inSafeMode = false;

var MissionStateStore = _Object$assign(new BaseStore(), {

    handleMissionStarted: function handleMissionStarted() {
        missionRunning = true;
        this.emitChange();
    },

    handleMissionStopped: function handleMissionStopped() {
        missionRunning = false;
        this.emitChange();
    },

    isSatelliteInSafeMode: function isSatelliteInSafeMode() {
        return inSafeMode;
    },

    isMissionRunning: function isMissionRunning() {
        return missionRunning;
    },

    isMissionStopped: function isMissionStopped() {
        return missionHasBeenStopped;
    },

    currentChapter: (function (_currentChapter) {
        function currentChapter() {
            return _currentChapter.apply(this, arguments);
        }

        currentChapter.toString = function () {
            return _currentChapter.toString();
        };

        return currentChapter;
    })(function () {
        return currentChapter;
    }),

    chapterTime: (function (_chapterTime) {
        function chapterTime() {
            return _chapterTime.apply(this, arguments);
        }

        chapterTime.toString = function () {
            return _chapterTime.toString();
        };

        return chapterTime;
    })(function () {
        return chapterTime;
    }),

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;

        switch (action) {
            case MISSION_STARTED_EVENT:
                return MissionStateStore.handleMissionStarted();

            case MISSION_STOPPED_EVENT:
                return MissionStateStore.handleMissionStopped();

            case RECEIVED_APP_STATE:
                var appState = payload.appState;
                missionRunning = appState.mission_running;
                currentChapter = appState.current_chapter;
                chapterTime = appState.elapsed_chapter_time;
                inSafeMode = appState.satellite_in_safe_mode;
                return MissionStateStore.emitChange();
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__MissionStateStore = MissionStateStore;
module.exports = MissionStateStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/oxygen-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MissionConstants = require('../constants/MissionConstants');
var AstConstants = require('../constants/AstroTeamConstants');
var BaseStore = require('./base-store');

var _status = AstConstants.GOOD_OXYGEN;
var consumptionPerMinute = null;
var remaining = 100;

var OxygenStore = module.exports = _Object$assign(new BaseStore(), {

    status: function status() {
        return _status;
    },

    statusAsColor: function statusAsColor() {
        switch (_status) {
            case AstConstants.CRITICAL_OXYGEN:
                return 'red';
            case AstConstants.WARN_OXYGEN:
                return 'orange';
            case AstConstants.GOOD_OXYGEN:
                return 'green';
        }
    },

    getState: function getState() {
        return {
            colorIndicator: this.statusAsColor(),
            consumptionPerMinute: consumptionPerMinute,
            remaining: remaining
        };
    },

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {
            case MissionConstants.RECEIVED_APP_STATE:
                var appState = payload.appState;

                if (appState.oxygen_consumption) {
                    consumptionPerMinute = appState.oxygen_consumption;

                    if (consumptionPerMinute > 1 && _status !== AstConstants.CRITICAL_OXYGEN) {
                        _status = AstConstants.WARN_OXYGEN;
                    } else if (consumptionPerMinute < 2) {
                        _status = AstConstants.GOOD_OXYGEN;
                    }

                    OxygenStore.emitChange();
                }

                if (appState.oxygen) {
                    remaining = appState.oxygen;
                    OxygenStore.emitChange();
                }
                break;
        }

        return true;
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/radiation-store.js":[function(require,module,exports){
/* A singleton store that can be queried for remaining time */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');
var ScienceTeamConstants = require('../constants/ScienceTeamConstants');
var MissionConstants = require('../constants/MissionConstants');
var randomInt = require('../utils').randomInt;
var radiationRange = {
    min: 5,
    max: 20
};
var samples = [];
var totalRadiation = 0;
var lastCalculatedAverage = null;

var RadiationStore = _Object$assign(new BaseStore(), {

    _setRadiationLevel: function _setRadiationLevel(min, max) {
        radiationRange.min = min;
        radiationRange.max = max;
        this.emitChange();
    },

    _clearSamples: function _clearSamples() {
        samples = [];
        this.emitChange();
    },

    _takeSample: function _takeSample() {
        samples.push(this.getLevel());
        this.emitChange();
    },

    getLevel: function getLevel() {
        return randomInt(radiationRange.min, radiationRange.max);
    },

    getTotalLevel: function getTotalLevel() {
        return totalRadiation;
    },

    getSamples: function getSamples() {
        return samples.slice();
    },

    getState: function getState() {
        return {
            samples: samples.slice(0),
            total: totalRadiation,
            currentLevel: this.getLevel(),
            lastCalculatedAverage: lastCalculatedAverage
        };
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;
        var data = payload.data;

        switch (action) {
            case ScienceTeamConstants.SCIENCE_RADIATION_LEVEL_CHANGED:
                RadiationStore._setRadiationLevel(data.min, data.max);
                break;
            case ScienceTeamConstants.SCIENCE_TOTAL_RADIATION_LEVEL_CHANGED:
                totalRadiation = data.total;
                RadiationStore.emitChange();
                break;

            case ScienceTeamConstants.SCIENCE_TAKE_RADIATION_SAMPLE:
                RadiationStore._takeSample();
                break;
            case ScienceTeamConstants.SCIENCE_AVG_RADIATION_CALCULATED:
                lastCalculatedAverage = data.average;
                RadiationStore.emitChange();
                break;
            case ScienceTeamConstants.SCIENCE_CLEAR_RADIATION_SAMPLES:
                samples = [];
                RadiationStore.emitChange();
                break;

            case MissionConstants.RECEIVED_APP_STATE:
                var appState = payload.appState,
                    radiationLevel = appState.radiation_level;

                RadiationStore._setRadiationLevel(radiationLevel.low, radiationLevel.high);

                if (appState.science && appState.science.radiation) {
                    var radiationState = appState.science.radiation;
                    samples = radiationState.samples;
                    lastCalculatedAverage = radiationState.lastCalculatedAverage;
                    totalRadiation = radiationState.total;
                }

                RadiationStore.emitChange();
                break;

            case MissionConstants.MISSION_WAS_RESET:
                samples = [];
                lastCalculatedAverage = null;
                totalRadiation = 0;
                break;
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__RadiationStore = RadiationStore;
module.exports = RadiationStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js":[function(require,module,exports){
/* A store that can be queried for the current path */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');

var _require = require('../constants/RouterConstants');

var ROUTE_CHANGED_EVENT = _require.ROUTE_CHANGED_EVENT;

var _require2 = require('../utils');

var cleanRootPath = _require2.cleanRootPath;

var router = require('../router-container');

var RouteStore = _Object$assign(new BaseStore(), {

    handleRouteChanged: function handleRouteChanged(state) {
        this.emitChange();
    },

    getTeamId: function getTeamId() {
        return router.getTeamId();
    },

    getTaskId: function getTaskId() {
        return router.getTaskId();
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;

        switch (action) {
            case ROUTE_CHANGED_EVENT:
                RouteStore.handleRouteChanged(payload.state);
                break;
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__RouteStore = RouteStore;
module.exports = RouteStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/RouterConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/RouterConstants.js","../router-container":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/task-store.js":[function(require,module,exports){
/* A store that can be queried for the current path */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');
var RouteStore = require('./route-store');
var MissionConstants = require('../constants/MissionConstants');

var awaitingNewInstructions = {
    text: 'Venter på nye instruksjoner ...'
};

var assignments = {
    science: {
        current: null,
        sample: {
            text: 'Start klokka og ta fire målinger jevnt fordelt utover de 30 sekundene',
            next: 'average'
        },
        average: {
            text: 'Regn ut gjennomsnittsverdien av strålingsverdiene dere fant. Skriv den inn i tekstfeltet.',
            next: 'addtotal'
        },
        addtotal: {
            text: 'Basert på fargen som ble indikert ved evaluering av gjennomsnittsverdien ' + 'skal vi nå legge til et tall til totalt funnet strålingsmengde.' + ' For grønn status man legge til 0, ' + ' for oransj status man legge til 15, ' + ' for rød status man legge til 50.' + ' Den totale strålingsverdien i kroppen skal helst ikke gå over 50, og aldri over 75!',
            next: 'awaiting'
        },
        awaiting: awaitingNewInstructions
    },

    astronaut: {
        current: null,
        awaiting: awaitingNewInstructions,
        breathing_timer: {
            text: 'Start klokka, og tell antall innpust (topper) på pustegrafen.',
            next: 'breathing_calculate',
            plain_info: true
        },
        breathing_calculate: {
            text: 'Hvor mange innpust blir det på ett minutt? Bruk tallet du finner til å regne ut oksygenforbruket pr minutt. Gjennomsnittlig oksygenforbruk med 25 innpust i minuttet er 1 oksygenenhet.',
            next: 'heartrate_timer'
        },
        heartrate_timer: {
            text: 'Start klokka og tell antall hjerteslag på ti sekunder',
            next: 'heartrate_calculate',
            plain_info: true
        },
        heartrate_calculate: {
            text: 'Finn nå ut hvor mange slag det blir i minuttet. Evaluer resultatet ved å skrive det inn i tekstfeltet.',
            next: 'awaiting'
        }
    },

    security: {
        current: null,
        awaiting: awaitingNewInstructions,

        scrubber: {
            text: 'NOT SURE ABOUT THIS ONE. I THINK IT WILL BE TRIGGERED WITHOUT ANY NEED FOR INSTRUCTIONS',
            next: 'awaiting'
        },

        signal_test: {
            text: 'Sjekk om dataoverføringer lar seg gjøre. Om det går bra kan dere teste om datakvaliteten er tilfredsstillende',
            next: 'awaiting'
        }
    },

    communication: {
        current: null,
        awaiting: awaitingNewInstructions,

        comm_check: {
            text: 'Sjekk status på kommunikasjonslinken. Om signalet er svakt bør en annen satelitt velges. ' + 'Om dere velger en annen satelitt må dere også velge en frekvens fra frekvensbåndet. ' + 'Det beste valget av frekvens er vanligvis midt i frekvensbåndet. '
        }

    }
};

var TaskStore = _Object$assign(new BaseStore(), {

    getCurrentTask: function getCurrentTask() {
        var teamId = RouteStore.getTeamId();
        var assignmentsForTeam = assignments[teamId];
        return assignmentsForTeam && assignmentsForTeam[this.getCurrentTaskId(teamId)] || 'Ingen oppgave funnet';
    },

    getCurrentTaskId: function getCurrentTaskId() {
        var teamId = arguments[0] === undefined ? RouteStore.getTeamId() : arguments[0];

        if (!teamId.length) {
            return null;
        }return assignments[teamId].current || 'awaiting';
    },

    getState: function getState() {
        return {
            currentTaskId: this.getCurrentTaskId(),
            currentTask: this.getCurrentTask().text,
            nextTaskId: this.getCurrentTask().next,
            plainInfo: this.getCurrentTask().plain_info
        };
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var taskId;
        var teamId;
        var currentTask;
        var teamTasks;

        switch (payload.action) {

            case MissionConstants.START_TASK:
                teamId = payload.teamId;
                taskId = payload.taskId;

                teamTasks = assignments[teamId];
                teamTasks.current = taskId;
                TaskStore.emitChange();
                break;

            case MissionConstants.COMPLETED_TASK:
                teamId = payload.teamId;
                taskId = payload.taskId;

                teamTasks = assignments[teamId];
                currentTask = teamTasks[taskId];
                teamTasks.current = currentTask.next;
                TaskStore.emitChange();
                break;

            case MissionConstants.RECEIVED_APP_STATE:
                teamId = RouteStore.getTeamId();

                var teamState = payload.appState[teamId];

                if (teamState && teamState.current_task) {
                    currentTask = teamState.current_task;
                    teamTasks = assignments[teamId];
                    teamTasks.current = currentTask;
                    TaskStore.emitChange();
                }

        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__TaskStore = TaskStore;
module.exports = TaskStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","./route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js":[function(require,module,exports){
/* A singleton store that can be queried for remaining time */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var check = require('check-types');
var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');
var TimerConstants = require('../constants/TimerConstants');
var MissionConstants = require('../constants/MissionConstants');

// keeping state hidden in the module
var remainingTime = {},
    initialTime = {},
    intervalId = {},
    elapsedMissionTime = 0,
    missionTimer = null;

function reset(timerId) {
    stop(timerId);
    remainingTime[timerId] = initialTime[timerId];
}

function start(timerId) {
    assertExists(timerId);

    intervalId[timerId] = setInterval(function fn() {
        if (remainingTime[timerId] > 0) {
            remainingTime[timerId]--;
            TimerStore.emitChange();
        } else {
            stop(timerId);
        }
    }, 1000);
}

function stop(timerId) {
    assertExists(timerId);

    clearInterval(intervalId[timerId]);
    delete intervalId[timerId];
    TimerStore.emitChange();
}

function startMissionTimer() {
    stopMissionTimer();
    missionTimer = setInterval(function () {
        elapsedMissionTime++;
        TimerStore.emitChange();
    }, 1000);
}

function stopMissionTimer() {
    clearInterval(missionTimer);
}

/**
 * @param data.remainingTime {Number}
 * @param data.timerId {string}
 */
function handleRemainingTimeChanged(data) {
    var remaining = data.remainingTime;
    if (remaining <= 0) throw new TypeError('Got invalid remaining time :' + remaining);

    remainingTime[data.timerId] = remaining;
    initialTime[data.timerId] = remaining;
    TimerStore.emitChange();
}

function assertExists(timerId) {
    check.assert(timerId in remainingTime, 'No time set for timer with id ' + timerId);
}

var TimerStore = _Object$assign(new BaseStore(), {

    getRemainingTime: function getRemainingTime(timerId) {
        check.number(timerId);
        return remainingTime[timerId];
    },

    isRunning: function isRunning(timerId) {
        check.number(timerId);
        return !!intervalId[timerId];
    },

    /**
     * The timer is set (or has been reset), but not started
     * @param timerId
     * @returns true if ready, false if running or timed out
     */
    isReadyToStart: function isReadyToStart(timerId) {
        check.number(timerId);

        if (this.isRunning(timerId)) {
            return false;
        }return this.getRemainingTime(timerId) > 0;
    },

    getElapsedMissionTime: function getElapsedMissionTime() {
        return elapsedMissionTime;
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;
        var data = payload.data;

        switch (action) {

            case TimerConstants.SET_TIMER:
                handleRemainingTimeChanged(data);
                break;

            case TimerConstants.START_TIMER:
                assertExists(data.timerId);

                // avoid setting up more than one timer
                if (!TimerStore.isRunning(data.timerId)) {
                    start(data.timerId);
                }
                break;

            case TimerConstants.STOP_TIMER:
                stop(data.timerId);
                break;

            case TimerConstants.RESET_TIMER:
                reset(data.timerId);
                break;

            case MissionConstants.MISSION_STARTED_EVENT:
                startMissionTimer();
                break;

            case MissionConstants.MISSION_STOPPED_EVENT:
                stopMissionTimer();
                break;

            case MissionConstants.RECEIVED_APP_STATE:
                var appState = payload.appState;

                elapsedMissionTime = appState.elapsed_mission_time;

                if (appState.mission_running) {
                    startMissionTimer();
                } else {
                    stopMissionTimer();
                }

                TimerStore.emitChange();
                break;

            case MissionConstants.MISSION_TIME_SYNC:
                elapsedMissionTime = data.elapsedMissionTime;
                TimerStore.emitChange();
                break;
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__TimeStore = TimerStore;
module.exports = TimerStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","../constants/TimerConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/TimerConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","check-types":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/check-types/src/check-types.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/team-name-map.js":[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var teamMap = _Object$freeze({
    science: 'forskningsteam',
    communication: 'kommunikasjonsteam',
    security: 'sikkerhetsteam',
    astronaut: 'astronautteam'
});

function otherTeamNames(currentTeamId) {
    return _Object$keys(teamMap).filter(function (n) {
        return n !== currentTeamId && n !== 'leader';
    }).map(function (n) {
        return teamMap[n];
    }).join(', ');
}

module.exports = {
    nameMap: teamMap,
    otherTeamNames: otherTeamNames
};

},{"babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js","babel-runtime/core-js/object/keys":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/keys.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js":[function(require,module,exports){
'use strict';

function cleanRootPath(path) {
    // convert '/science/step1' => 'science'
    return path.replace(/\/?(\w+).*/, '$1');
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max + 1 - min)) + min;
}

/**
 * Standardize number parsing.
 * @param {string} str is a non-empty string
 * @returns {Number} - possibly NaN
 *
 * The standardization step of converting '1,23' -> '1.23' is strictly not needed when handling inputs from
 * input fields that have type='number', where this happens automatically.
 * The rest of the error handling is useful, none the less.
 */
function parseNumber(str) {
    if (! typeof str === 'string') {
        throw TypeError('This function expects strings. Got something else: ' + str);
    }

    // standardize the number format - removing Norwegian currency format
    var cleanedString = str.trim().replace(',', '.');

    if (!cleanedString.length) {
        throw TypeError('Got a blank string');
    }

    if (cleanedString.indexOf('.') !== -1) {
        return parseFloat(cleanedString, 10);
    } else {
        return parseInt(cleanedString, 10);
    }
}

// generates a UUID
// worlds smallest uuid lib. crazy shit :)
// @see https://gist.github.com/jed/982883
function b(a) {
    return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([10000000] + -1000 + -4000 + -8000 + -100000000000).replace(/[018]/g, b);
}

module.exports = {
    cleanRootPath: cleanRootPath, randomInt: randomInt, parseNumber: parseNumber, uuid: b
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js":[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js":[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/keys.js":[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/class-call-check.js":[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/create-class.js":[function(require,module,exports){
"use strict";

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/extends.js":[function(require,module,exports){
"use strict";

var _Object$assign = require("babel-runtime/core-js/object/assign")["default"];

exports["default"] = _Object$assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/inherits.js":[function(require,module,exports){
"use strict";

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js":[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/$').core.Object.assign;
},{"../../modules/$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js","../../modules/es6.object.assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/freeze.js":[function(require,module,exports){
require('../../modules/es6.object.statics-accept-primitives');
module.exports = require('../../modules/$').core.Object.freeze;
},{"../../modules/$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js","../../modules/es6.object.statics-accept-primitives":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.statics-accept-primitives.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js":[function(require,module,exports){
require('../../modules/es6.object.statics-accept-primitives');
module.exports = require('../../modules/$').core.Object.keys;
},{"../../modules/$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js","../../modules/es6.object.statics-accept-primitives":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.statics-accept-primitives.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.assign.js":[function(require,module,exports){
var $ = require('./$');
// 19.1.2.1 Object.assign(target, source, ...)
/*eslint-disable no-unused-vars */
module.exports = Object.assign || function assign(target, source){
/*eslint-enable no-unused-vars */
  var T = Object($.assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = $.ES5Object(arguments[i++])
      , keys   = $.getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
};
},{"./$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.def.js":[function(require,module,exports){
var $          = require('./$')
  , global     = $.g
  , core       = $.core
  , isFunction = $.isFunction;
function ctx(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
}
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
function $def(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {}).prototype
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    if(isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & $def.B && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & $def.W && target[key] == out)!function(C){
      exp = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      exp.prototype = C.prototype;
    }(out);
    else exp = type & $def.P && isFunction(out) ? ctx(Function.call, out) : out;
    // export
    $.hide(exports, key, exp);
  }
}
module.exports = $def;
},{"./$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.fw.js":[function(require,module,exports){
module.exports = function($){
  $.FW   = false;
  $.path = $.core;
  return $;
};
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js":[function(require,module,exports){
'use strict';
var global = typeof self != 'undefined' ? self : Function('return this')()
  , core   = {}
  , defineProperty = Object.defineProperty
  , hasOwnProperty = {}.hasOwnProperty
  , ceil  = Math.ceil
  , floor = Math.floor
  , max   = Math.max
  , min   = Math.min;
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
  try {
    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
  } catch(e){ /* empty */ }
}();
var hide = createDefiner(1);
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
}
function desc(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return $.setDesc(object, key, desc(bitmap, value)); // eslint-disable-line no-use-before-define
  } : simpleSet;
}

function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
function assertDefined(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
}

var $ = module.exports = require('./$.fw')({
  g: global,
  core: core,
  html: global.document && document.documentElement,
  // http://jsperf.com/core-js-isobject
  isObject:   isObject,
  isFunction: isFunction,
  it: function(it){
    return it;
  },
  that: function(){
    return this;
  },
  // 7.1.4 ToInteger
  toInteger: toInteger,
  // 7.1.15 ToLength
  toLength: function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  },
  toIndex: function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  },
  has: function(it, key){
    return hasOwnProperty.call(it, key);
  },
  create:     Object.create,
  getProto:   Object.getPrototypeOf,
  DESC:       DESC,
  desc:       desc,
  getDesc:    Object.getOwnPropertyDescriptor,
  setDesc:    defineProperty,
  getKeys:    Object.keys,
  getNames:   Object.getOwnPropertyNames,
  getSymbols: Object.getOwnPropertySymbols,
  // Dummy, fix for not array-like ES3 string in es5 module
  assertDefined: assertDefined,
  ES5Object: Object,
  toObject: function(it){
    return $.ES5Object(assertDefined(it));
  },
  hide: hide,
  def: createDefiner(0),
  set: global.Symbol ? simpleSet : hide,
  mix: function(target, src){
    for(var key in src)hide(target, key, src[key]);
    return target;
  },
  each: [].forEach
});
if(typeof __e != 'undefined')__e = core;
if(typeof __g != 'undefined')__g = global;
},{"./$.fw":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.fw.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js":[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');
$def($def.S, 'Object', {assign: require('./$.assign')});
},{"./$.assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.assign.js","./$.def":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.def.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.statics-accept-primitives.js":[function(require,module,exports){
var $        = require('./$')
  , $def     = require('./$.def')
  , isObject = $.isObject
  , toObject = $.toObject;
function wrapObjectMethod(METHOD, MODE){
  var fn  = ($.core.Object || {})[METHOD] || Object[METHOD]
    , f   = 0
    , o   = {};
  o[METHOD] = MODE == 1 ? function(it){
    return isObject(it) ? fn(it) : it;
  } : MODE == 2 ? function(it){
    return isObject(it) ? fn(it) : true;
  } : MODE == 3 ? function(it){
    return isObject(it) ? fn(it) : false;
  } : MODE == 4 ? function getOwnPropertyDescriptor(it, key){
    return fn(toObject(it), key);
  } : MODE == 5 ? function getPrototypeOf(it){
    return fn(Object($.assertDefined(it)));
  } : function(it){
    return fn(toObject(it));
  };
  try {
    fn('z');
  } catch(e){
    f = 1;
  }
  $def($def.S + $def.F * f, 'Object', o);
}
wrapObjectMethod('freeze', 1);
wrapObjectMethod('seal', 1);
wrapObjectMethod('preventExtensions', 1);
wrapObjectMethod('isFrozen', 2);
wrapObjectMethod('isSealed', 2);
wrapObjectMethod('isExtensible', 3);
wrapObjectMethod('getOwnPropertyDescriptor', 4);
wrapObjectMethod('getPrototypeOf', 5);
wrapObjectMethod('keys');
wrapObjectMethod('getOwnPropertyNames');
},{"./$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js","./$.def":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.def.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/browser-resolve/empty.js":[function(require,module,exports){

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding) {
  var self = this
  if (!(self instanceof Buffer)) return new Buffer(subject, encoding)

  var type = typeof subject
  var length

  if (type === 'number') {
    length = +subject
  } else if (type === 'string') {
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) {
    // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data)) subject = subject.data
    length = +subject.length
  } else {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (length > kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' +
      kMaxLength.toString(16) + ' bytes')
  }

  if (length < 0) length = 0
  else length >>>= 0 // coerce to uint32

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    self = Buffer._augment(new Uint8Array(length)) // eslint-disable-line consistent-this
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    self.length = length
    self._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    self._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++) {
        self[i] = subject.readUInt8(i)
      }
    } else {
      for (i = 0; i < length; i++) {
        self[i] = ((subject[i] % 256) + 256) % 256
      }
    }
  } else if (type === 'string') {
    self.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < length; i++) {
      self[i] = 0
    }
  }

  if (length > 0 && length <= Buffer.poolSize) self.parent = rootParent

  return self
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, totalLength) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function byteLength (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0

  if (length < 0 || offset < 0 || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, target_start, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (target_start >= target.length) target_start = target.length
  if (!target_start) target_start = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (target_start < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - target_start < end - start) {
    end = target.length - target_start + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/duplex.js":[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))

},{"./_stream_readable":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js","buffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js","isarray":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/isarray/index.js","stream":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js","string_decoder/":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/string_decoder/index.js","util":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))

},{"./_stream_duplex":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js","buffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js","stream":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js":[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)

},{"buffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/passthrough.js":[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/readable.js":[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","stream":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/transform.js":[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/writable.js":[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js","readable-stream/duplex.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/duplex.js","readable-stream/passthrough.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/passthrough.js","readable-stream/readable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/readable.js","readable-stream/transform.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/transform.js","readable-stream/writable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/writable.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/string_decoder/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/support/isBufferBrowser.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/check-types/src/check-types.js":[function(require,module,exports){
/**
 * This module exports functions for checking types
 * and throwing exceptions.
 */

/*globals define, module */

(function (globals) {
    'use strict';

    var messages, predicates, functions, assert, not, maybe, either;

    messages = {
        like: 'Invalid type',
        instance: 'Invalid type',
        emptyObject: 'Invalid object',
        object: 'Invalid object',
        assigned: 'Invalid value',
        undefined: 'Invalid value',
        null: 'Invalid value',
        hasLength: 'Invalid length',
        emptyArray: 'Invalid array',
        array: 'Invalid array',
        date: 'Invalid date',
        error: 'Invalid error',
        fn: 'Invalid function',
        match: 'Invalid string',
        contains: 'Invalid string',
        unemptyString: 'Invalid string',
        string: 'Invalid string',
        odd: 'Invalid number',
        even: 'Invalid number',
        between: 'Invalid number',
        greater: 'Invalid number',
        less: 'Invalid number',
        positive: 'Invalid number',
        negative: 'Invalid number',
        integer: 'Invalid number',
        zero: 'Invalid number',
        number: 'Invalid number',
        boolean: 'Invalid boolean'
    };

    predicates = {
        like: like,
        instance: instance,
        emptyObject: emptyObject,
        object: object,
        assigned: assigned,
        undefined: isUndefined,
        null: isNull,
        hasLength: hasLength,
        emptyArray: emptyArray,
        array: array,
        date: date,
        error: error,
        function: isFunction,
        match: match,
        contains: contains,
        unemptyString: unemptyString,
        string: string,
        odd: odd,
        even: even,
        between: between,
        greater: greater,
        less: less,
        positive: positive,
        negative: negative,
        integer : integer,
        zero: zero,
        number: number,
        boolean: boolean
    };

    functions = {
        apply: apply,
        map: map,
        all: all,
        any: any
    };

    functions = mixin(functions, predicates);
    assert = createModifiedPredicates(assertModifier, assertImpl);
    not = createModifiedPredicates(notModifier, notImpl);
    maybe = createModifiedPredicates(maybeModifier, maybeImpl);
    either = createModifiedPredicates(eitherModifier);
    assert.not = createModifiedFunctions(assertModifier, not);
    assert.maybe = createModifiedFunctions(assertModifier, maybe);
    assert.either = createModifiedFunctions(assertEitherModifier, predicates);

    exportFunctions(mixin(functions, {
        assert: assert,
        not: not,
        maybe: maybe,
        either: either
    }));

    /**
     * Public function `like`.
     *
     * Tests whether an object 'quacks like a duck'.
     * Returns `true` if the first argument has all of
     * the properties of the second, archetypal argument
     * (the 'duck'). Returns `false` otherwise.
     *
     */
    function like (data, duck) {
        var name;

        for (name in duck) {
            if (duck.hasOwnProperty(name)) {
                if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof duck[name]) {
                    return false;
                }

                if (object(data[name]) && like(data[name], duck[name]) === false) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Public function `instance`.
     *
     * Returns `true` if an object is an instance of a prototype,
     * `false` otherwise.
     *
     */
    function instance (data, prototype) {
        if (data && isFunction(prototype) && data instanceof prototype) {
            return true;
        }

        return false;
    }

    /**
     * Public function `emptyObject`.
     *
     * Returns `true` if something is an empty object,
     * `false` otherwise.
     *
     */
    function emptyObject (data) {
        return object(data) && Object.keys(data).length === 0;
    }

    /**
     * Public function `object`.
     *
     * Returns `true` if something is a plain-old JS object,
     * `false` otherwise.
     *
     */
    function object (data) {
        return Object.prototype.toString.call(data) === '[object Object]';
    }

    /**
     * Public function `assigned`.
     *
     * Returns `true` if something is not null or undefined,
     * `false` otherwise.
     *
     */
    function assigned (data) {
        return !isUndefined(data) && !isNull(data);
    }

    /**
     * Public function `undefined`.
     *
     * Returns `true` if something is undefined,
     * `false` otherwise.
     *
     */
    function isUndefined (data) {
        return data === undefined;
    }

    /**
     * Public function `null`.
     *
     * Returns `true` if something is null,
     * `false` otherwise.
     *
     */
    function isNull (data) {
        return data === null;
    }

    /**
     * Public function `hasLength`.
     *
     * Returns `true` if something is has a length property
     * that equals `value`, `false` otherwise.
     *
     */
    function hasLength (data, value) {
        return assigned(data) && data.length === value;
    }

    /**
     * Public function `emptyArray`.
     *
     * Returns `true` if something is an empty array,
     * `false` otherwise.
     *
     */
    function emptyArray (data) {
        return array(data) && data.length === 0;
    }

    /**
     * Public function `array`.
     *
     * Returns `true` something is an array,
     * `false` otherwise.
     *
     */
    function array (data) {
        return Array.isArray(data);
    }

    /**
     * Public function `date`.
     *
     * Returns `true` something is a valid date,
     * `false` otherwise.
     *
     */
    function date (data) {
        return Object.prototype.toString.call(data) === '[object Date]' &&
            !isNaN(data.getTime());
    }

    /**
     * Public function `error`.
     *
     * Returns `true` if something is a plain-old JS object,
     * `false` otherwise.
     *
     */
    function error (data) {
        return Object.prototype.toString.call(data) === '[object Error]';
    }

    /**
     * Public function `function`.
     *
     * Returns `true` if something is function,
     * `false` otherwise.
     *
     */
    function isFunction (data) {
        return typeof data === 'function';
    }

    /**
     * Public function `match`.
     *
     * Returns `true` if something is a string
     * that matches `regex`, `false` otherwise.
     *
     */
    function match (data, regex) {
        return string(data) && !!data.match(regex);
    }

    /**
     * Public function `contains`.
     *
     * Returns `true` if something is a string
     * that contains `substring`, `false` otherwise.
     *
     */
    function contains (data, substring) {
        return string(data) && data.indexOf(substring) !== -1;
    }

    /**
     * Public function `unemptyString`.
     *
     * Returns `true` if something is a non-empty string,
     * `false` otherwise.
     *
     */
    function unemptyString (data) {
        return string(data) && data !== '';
    }

    /**
     * Public function `string`.
     *
     * Returns `true` if something is a string, `false` otherwise.
     *
     */
    function string (data) {
        return typeof data === 'string';
    }

    /**
     * Public function `odd`.
     *
     * Returns `true` if something is an odd number,
     * `false` otherwise.
     *
     */
    function odd (data) {
        return integer(data) && !even(data);
    }

    /**
     * Public function `even`.
     *
     * Returns `true` if something is an even number,
     * `false` otherwise.
     *
     */
    function even (data) {
        return number(data) && data % 2 === 0;
    }

    /**
     * Public function `integer`.
     *
     * Returns `true` if something is an integer,
     * `false` otherwise.
     *
     */
    function integer (data) {
        return number(data) && data % 1 === 0;
    }

    /**
     * Public function `between`.
     *
     * Returns `true` if something is a number
     * between `a` and `b`, `false` otherwise.
     *
     */
    function between (data, a, b) {
        if (a < b) {
            return greater(data, a) && less(data, b);
        }

        return less(data, a) && greater(data, b);
    }

    /**
     * Public function `greater`.
     *
     * Returns `true` if something is a number
     * greater than `value`, `false` otherwise.
     *
     */
    function greater (data, value) {
        return number(data) && data > value;
    }

    /**
     * Public function `less`.
     *
     * Returns `true` if something is a number
     * less than `value`, `false` otherwise.
     *
     */
    function less (data, value) {
        return number(data) && data < value;
    }

    /**
     * Public function `positive`.
     *
     * Returns `true` if something is a positive number,
     * `false` otherwise.
     *
     */
    function positive (data) {
        return greater(data, 0);
    }

    /**
     * Public function `negative`.
     *
     * Returns `true` if something is a negative number,
     * `false` otherwise.
     *
     * @param data          The thing to test.
     */
    function negative (data) {
        return less(data, 0);
    }

    /**
     * Public function `number`.
     *
     * Returns `true` if data is a number,
     * `false` otherwise.
     *
     */
    function number (data) {
        return typeof data === 'number' && isNaN(data) === false &&
               data !== Number.POSITIVE_INFINITY &&
               data !== Number.NEGATIVE_INFINITY;
    }

    /**
     * Public function `zero`.
     *
     * Returns `true` if something is zero,
     * `false` otherwise.
     *
     * @param data          The thing to test.
     */
    function zero (data) {
        return data === 0;
    }

    /**
     * Public function `boolean`.
     *
     * Returns `true` if data is a boolean value,
     * `false` otherwise.
     *
     */
    function boolean (data) {
        return data === false || data === true;
    }

    /**
     * Public function `apply`.
     *
     * Maps each value from the data to the corresponding predicate and returns
     * the result array. If the same function is to be applied across all of the
     * data, a single predicate function may be passed in.
     *
     */
    function apply (data, predicates) {
        assert.array(data);

        if (isFunction(predicates)) {
            return data.map(function (value) {
                return predicates(value);
            });
        }

        assert.array(predicates);
        assert.hasLength(data, predicates.length);

        return data.map(function (value, index) {
            return predicates[index](value);
        });
    }

    /**
     * Public function `map`.
     *
     * Maps each value from the data to the corresponding predicate and returns
     * the result object. Supports nested objects. If the data is not nested and
     * the same function is to be applied across all of it, a single predicate
     * function may be passed in.
     *
     */
    function map (data, predicates) {
        assert.object(data);

        if (isFunction(predicates)) {
            return mapSimple(data, predicates);
        }

        assert.object(predicates);

        return mapComplex(data, predicates);
    }

    function mapSimple (data, predicate) {
        var result = {};

        Object.keys(data).forEach(function (key) {
            result[key] = predicate(data[key]);
        });

        return result;
    }

    function mapComplex (data, predicates) {
        var result = {};

        Object.keys(predicates).forEach(function (key) {
            var predicate = predicates[key];

            if (isFunction(predicate)) {
                result[key] = predicate(data[key]);
            } else if (object(predicate)) {
                result[key] = mapComplex(data[key], predicate);
            }
        });

        return result;
    }

    /**
     * Public function `all`
     *
     * Check that all boolean values are true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */
    function all (data) {
        if (array(data)) {
            return testArray(data, false);
        }

        assert.object(data);

        return testObject(data, false);
    }

    function testArray (data, result) {
        var i;

        for (i = 0; i < data.length; i += 1) {
            if (data[i] === result) {
                return result;
            }
        }

        return !result;
    }

    function testObject (data, result) {
        var key, value;

        for (key in data) {
            if (data.hasOwnProperty(key)) {
                value = data[key];

                if (object(value) && testObject(value, result) === result) {
                    return result;
                }

                if (value === result) {
                    return result;
                }
            }
        }

        return !result;
    }

    /**
     * Public function `any`
     *
     * Check that at least one boolean value is true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */
    function any (data) {
        if (array(data)) {
            return testArray(data, true);
        }

        assert.object(data);

        return testObject(data, true);
    }

    function mixin (target, source) {
        Object.keys(source).forEach(function (key) {
            target[key] = source[key];
        });

        return target;
    }

    /**
     * Public modifier `assert`.
     *
     * Throws if `predicate` returns `false`.
     */
    function assertModifier (predicate, defaultMessage) {
        return function () {
            assertPredicate(predicate, arguments, defaultMessage);
        };
    }

    function assertPredicate (predicate, args, defaultMessage) {
        var message = args[args.length - 1];
        assertImpl(predicate.apply(null, args), unemptyString(message) ? message : defaultMessage);
    }

    function assertImpl (value, message) {
        if (value === false) {
            throw new Error(message || 'Assertion failed');
        }
    }

    function assertEitherModifier (predicate, defaultMessage) {
        return function () {
            var error;

            try {
                assertPredicate(predicate, arguments, defaultMessage);
            } catch (e) {
                error = e;
            }

            return {
                or: Object.keys(predicates).reduce(delayedAssert, {})
            };

            function delayedAssert (result, key) {
                result[key] = function () {
                    if (error && !predicates[key].apply(null, arguments)) {
                        throw error;
                    }
                };

                return result;
            }
        };
    }

    /**
     * Public modifier `not`.
     *
     * Negates `predicate`.
     */
    function notModifier (predicate) {
        return function () {
            return notImpl(predicate.apply(null, arguments));
        };
    }

    function notImpl (value) {
        return !value;
    }

    /**
     * Public modifier `maybe`.
     *
     * Returns `true` if predicate argument is  `null` or `undefined`,
     * otherwise propagates the return value from `predicate`.
     */
    function maybeModifier (predicate) {
        return function () {
            if (!assigned(arguments[0])) {
                return true;
            }

            return predicate.apply(null, arguments);
        };
    }

    function maybeImpl (value) {
        if (assigned(value) === false) {
            return true;
        }

        return value;
    }

    /**
     * Public modifier `either`.
     *
     * Returns `true` if either predicate is true.
     */
    function eitherModifier (predicate) {
        return function () {
            var shortcut = predicate.apply(null, arguments);

            return {
                or: Object.keys(predicates).reduce(nopOrPredicate, {})
            };

            function nopOrPredicate (result, key) {
                result[key] = shortcut ? nop : predicates[key];
                return result;
            }
        };

        function nop () {
            return true;
        }
    }

    function createModifiedPredicates (modifier, object) {
        return createModifiedFunctions(modifier, predicates, object);
    }

    function createModifiedFunctions (modifier, functions, object) {
        var result = object || {};

        Object.keys(functions).forEach(function (key) {
            Object.defineProperty(result, key, {
                configurable: false,
                enumerable: true,
                writable: false,
                value: modifier(functions[key], messages[key])
            });
        });

        return result;
    }

    function exportFunctions (functions) {
        if (typeof define === 'function' && define.amd) {
            define(function () {
                return functions;
            });
        } else if (typeof module !== 'undefined' && module !== null && module.exports) {
            module.exports = functions;
        } else {
            globals.check = functions;
        }
    }
}(this));

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/index.js":[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher')

},{"./lib/Dispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/lib/Dispatcher.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/lib/Dispatcher.js":[function(require,module,exports){
/*
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * @typechecks
 */

"use strict";

var invariant = require('./invariant');

var _lastID = 1;
var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *    CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *
 *         case 'city-update':
 *           FlightPriceStore.price =
 *             FlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

  function Dispatcher() {
    this.$Dispatcher_callbacks = {};
    this.$Dispatcher_isPending = {};
    this.$Dispatcher_isHandled = {};
    this.$Dispatcher_isDispatching = false;
    this.$Dispatcher_pendingPayload = null;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   *
   * @param {function} callback
   * @return {string}
   */
  Dispatcher.prototype.register=function(callback) {
    var id = _prefix + _lastID++;
    this.$Dispatcher_callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   *
   * @param {string} id
   */
  Dispatcher.prototype.unregister=function(id) {
    invariant(
      this.$Dispatcher_callbacks[id],
      'Dispatcher.unregister(...): `%s` does not map to a registered callback.',
      id
    );
    delete this.$Dispatcher_callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   *
   * @param {array<string>} ids
   */
  Dispatcher.prototype.waitFor=function(ids) {
    invariant(
      this.$Dispatcher_isDispatching,
      'Dispatcher.waitFor(...): Must be invoked while dispatching.'
    );
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this.$Dispatcher_isPending[id]) {
        invariant(
          this.$Dispatcher_isHandled[id],
          'Dispatcher.waitFor(...): Circular dependency detected while ' +
          'waiting for `%s`.',
          id
        );
        continue;
      }
      invariant(
        this.$Dispatcher_callbacks[id],
        'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',
        id
      );
      this.$Dispatcher_invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   *
   * @param {object} payload
   */
  Dispatcher.prototype.dispatch=function(payload) {
    invariant(
      !this.$Dispatcher_isDispatching,
      'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'
    );
    this.$Dispatcher_startDispatching(payload);
    try {
      for (var id in this.$Dispatcher_callbacks) {
        if (this.$Dispatcher_isPending[id]) {
          continue;
        }
        this.$Dispatcher_invokeCallback(id);
      }
    } finally {
      this.$Dispatcher_stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   *
   * @return {boolean}
   */
  Dispatcher.prototype.isDispatching=function() {
    return this.$Dispatcher_isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @param {string} id
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_invokeCallback=function(id) {
    this.$Dispatcher_isPending[id] = true;
    this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);
    this.$Dispatcher_isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @param {object} payload
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_startDispatching=function(payload) {
    for (var id in this.$Dispatcher_callbacks) {
      this.$Dispatcher_isPending[id] = false;
      this.$Dispatcher_isHandled[id] = false;
    }
    this.$Dispatcher_pendingPayload = payload;
    this.$Dispatcher_isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_stopDispatching=function() {
    this.$Dispatcher_pendingPayload = null;
    this.$Dispatcher_isDispatching = false;
  };


module.exports = Dispatcher;

},{"./invariant":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/lib/invariant.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/lib/invariant.js":[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/global/document.js":[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/global/window.js":[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/printf/lib/printf.js":[function(require,module,exports){

var util = require('util');

var tokenize = function(/*String*/ str, /*RegExp*/ re, /*Function?*/ parseDelim, /*Object?*/ instance){
  // summary:
  //    Split a string by a regular expression with the ability to capture the delimeters
  // parseDelim:
  //    Each group (excluding the 0 group) is passed as a parameter. If the function returns
  //    a value, it's added to the list of tokens.
  // instance:
  //    Used as the "this' instance when calling parseDelim
  var tokens = [];
  var match, content, lastIndex = 0;
  while(match = re.exec(str)){
    content = str.slice(lastIndex, re.lastIndex - match[0].length);
    if(content.length){
      tokens.push(content);
    }
    if(parseDelim){
      var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
      if(typeof parsed != 'undefined'){
        if(parsed.specifier === '%'){
          tokens.push('%');
        }else{
          tokens.push(parsed);
        }
      }
    }
    lastIndex = re.lastIndex;
  }
  content = str.slice(lastIndex);
  if(content.length){
    tokens.push(content);
  }
  return tokens;
}

var Formatter = function(/*String*/ format){
  var tokens = [];
  this._mapped = false;
  this._format = format;
  this._tokens = tokenize(format, this._re, this._parseDelim, this);
}

Formatter.prototype._re = /\%(?:\(([\w_]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier){
  if(mapping){
    this._mapped = true;
  }
  return {
    mapping: mapping,
    intmapping: intmapping,
    flags: flags,
    _minWidth: minWidth, // May be dependent on parameters
    period: period,
    _precision: precision, // May be dependent on parameters
    specifier: specifier
  };
};
Formatter.prototype._specifiers = {
  b: {
    base: 2,
    isInt: true
  },
  o: {
    base: 8,
    isInt: true
  },
  x: {
    base: 16,
    isInt: true
  },
  X: {
    extend: ['x'],
    toUpper: true
  },
  d: {
    base: 10,
    isInt: true
  },
  i: {
    extend: ['d']
  },
  u: {
    extend: ['d'],
    isUnsigned: true
  },
  c: {
    setArg: function(token){
      if(!isNaN(token.arg)){
        var num = parseInt(token.arg);
        if(num < 0 || num > 127){
          throw new Error('invalid character code passed to %c in printf');
        }
        token.arg = isNaN(num) ? '' + num : String.fromCharCode(num);
      }
    }
  },
  s: {
    setMaxWidth: function(token){
      token.maxWidth = (token.period == '.') ? token.precision : -1;
    }
  },
  e: {
    isDouble: true,
    doubleNotation: 'e'
  },
  E: {
    extend: ['e'],
    toUpper: true
  },
  f: {
    isDouble: true,
    doubleNotation: 'f'
  },
  F: {
    extend: ['f']
  },
  g: {
    isDouble: true,
    doubleNotation: 'g'
  },
  G: {
    extend: ['g'],
    toUpper: true
  },
  O: {
    isObject: true
  },
};
Formatter.prototype.format = function(/*mixed...*/ filler){
  if(this._mapped && typeof filler != 'object'){
    throw new Error('format requires a mapping');
  }

  var str = '';
  var position = 0;
  for(var i = 0, token; i < this._tokens.length; i++){
    token = this._tokens[i];
    
    if(typeof token == 'string'){
      str += token;
    }else{
      if(this._mapped){
        if(typeof filler[token.mapping] == 'undefined'){
          throw new Error('missing key ' + token.mapping);
        }
        token.arg = filler[token.mapping];
      }else{
        if(token.intmapping){
          position = parseInt(token.intmapping) - 1;
        }
        if(position >= arguments.length){
          throw new Error('got ' + arguments.length + ' printf arguments, insufficient for \'' + this._format + '\'');
        }
        token.arg = arguments[position++];
      }

      if(!token.compiled){
        token.compiled = true;
        token.sign = '';
        token.zeroPad = false;
        token.rightJustify = false;
        token.alternative = false;

        var flags = {};
        for(var fi = token.flags.length; fi--;){
          var flag = token.flags.charAt(fi);
          flags[flag] = true;
          switch(flag){
            case ' ':
              token.sign = ' ';
              break;
            case '+':
              token.sign = '+';
              break;
            case '0':
              token.zeroPad = (flags['-']) ? false : true;
              break;
            case '-':
              token.rightJustify = true;
              token.zeroPad = false;
              break;
            case '#':
              token.alternative = true;
              break;
            default:
              throw Error('bad formatting flag \'' + token.flags.charAt(fi) + '\'');
          }
        }

        token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;
        token.maxWidth = -1;
        token.toUpper = false;
        token.isUnsigned = false;
        token.isInt = false;
        token.isDouble = false;
        token.isObject = false;
        token.precision = 1;
        if(token.period == '.'){
          if(token._precision){
            token.precision = parseInt(token._precision);
          }else{
            token.precision = 0;
          }
        }

        var mixins = this._specifiers[token.specifier];
        if(typeof mixins == 'undefined'){
          throw new Error('unexpected specifier \'' + token.specifier + '\'');
        }
        if(mixins.extend){
          var s = this._specifiers[mixins.extend];
          for(var k in s){
            mixins[k] = s[k]
          }
          delete mixins.extend;
        }
        for(var l in mixins){
          token[l] = mixins[l];
        }
      }

      if(typeof token.setArg == 'function'){
        token.setArg(token);
      }

      if(typeof token.setMaxWidth == 'function'){
        token.setMaxWidth(token);
      }

      if(token._minWidth == '*'){
        if(this._mapped){
          throw new Error('* width not supported in mapped formats');
        }
        token.minWidth = parseInt(arguments[position++]);
        if(isNaN(token.minWidth)){
          throw new Error('the argument for * width at position ' + position + ' is not a number in ' + this._format);
        }
        // negative width means rightJustify
        if (token.minWidth < 0) {
          token.rightJustify = true;
          token.minWidth = -token.minWidth;
        }
      }

      if(token._precision == '*' && token.period == '.'){
        if(this._mapped){
          throw new Error('* precision not supported in mapped formats');
        }
        token.precision = parseInt(arguments[position++]);
        if(isNaN(token.precision)){
          throw Error('the argument for * precision at position ' + position + ' is not a number in ' + this._format);
        }
        // negative precision means unspecified
        if (token.precision < 0) {
          token.precision = 1;
          token.period = '';
        }
      }
      if(token.isInt){
        // a specified precision means no zero padding
        if(token.period == '.'){
          token.zeroPad = false;
        }
        this.formatInt(token);
      }else if(token.isDouble){
        if(token.period != '.'){
          token.precision = 6;
        }
        this.formatDouble(token); 
      }else if(token.isObject){
        this.formatObject(token);
      }
      this.fitField(token);

      str += '' + token.arg;
    }
  }

  return str;
};
Formatter.prototype._zeros10 = '0000000000';
Formatter.prototype._spaces10 = '          ';
Formatter.prototype.formatInt = function(token) {
  var i = parseInt(token.arg);
  if(!isFinite(i)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not an integer; parseInt returned ' + i);
    }
    //return '' + i;
    i = 0;
  }

  // if not base 10, make negatives be positive
  // otherwise, (-10).toString(16) is '-a' instead of 'fffffff6'
  if(i < 0 && (token.isUnsigned || token.base != 10)){
    i = 0xffffffff + i + 1;
  } 

  if(i < 0){
    token.arg = (- i).toString(token.base);
    this.zeroPad(token);
    token.arg = '-' + token.arg;
  }else{
    token.arg = i.toString(token.base);
    // need to make sure that argument 0 with precision==0 is formatted as ''
    if(!i && !token.precision){
      token.arg = '';
    }else{
      this.zeroPad(token);
    }
    if(token.sign){
      token.arg = token.sign + token.arg;
    }
  }
  if(token.base == 16){
    if(token.alternative){
      token.arg = '0x' + token.arg;
    }
    token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
  }
  if(token.base == 8){
    if(token.alternative && token.arg.charAt(0) != '0'){
      token.arg = '0' + token.arg;
    }
  }
};
Formatter.prototype.formatDouble = function(token) {
  var f = parseFloat(token.arg);
  if(!isFinite(f)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not a float; parseFloat returned ' + f);
    }
    // C99 says that for 'f':
    //   infinity -> '[-]inf' or '[-]infinity' ('[-]INF' or '[-]INFINITY' for 'F')
    //   NaN -> a string  starting with 'nan' ('NAN' for 'F')
    // this is not commonly implemented though.
    //return '' + f;
    f = 0;
  }

  switch(token.doubleNotation) {
    case 'e': {
      token.arg = f.toExponential(token.precision); 
      break;
    }
    case 'f': {
      token.arg = f.toFixed(token.precision); 
      break;
    }
    case 'g': {
      // C says use 'e' notation if exponent is < -4 or is >= prec
      // ECMAScript for toPrecision says use exponential notation if exponent is >= prec,
      // though step 17 of toPrecision indicates a test for < -6 to force exponential.
      if(Math.abs(f) < 0.0001){
        //print('forcing exponential notation for f=' + f);
        token.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);
      }else{
        token.arg = f.toPrecision(token.precision); 
      }

      // In C, unlike 'f', 'gG' removes trailing 0s from fractional part, unless alternative format flag ('#').
      // But ECMAScript formats toPrecision as 0.00100000. So remove trailing 0s.
      if(!token.alternative){ 
        //print('replacing trailing 0 in \'' + s + '\'');
        token.arg = token.arg.replace(/(\..*[^0])0*e/, '$1e');
        // if fractional part is entirely 0, remove it and decimal point
        token.arg = token.arg.replace(/\.0*e/, 'e').replace(/\.0$/,'');
      }
      break;
    }
    default: throw new Error('unexpected double notation \'' + token.doubleNotation + '\'');
  }

  // C says that exponent must have at least two digits.
  // But ECMAScript does not; toExponential results in things like '1.000000e-8' and '1.000000e+8'.
  // Note that s.replace(/e([\+\-])(\d)/, 'e$10$2') won't work because of the '$10' instead of '$1'.
  // And replace(re, func) isn't supported on IE50 or Safari1.
  token.arg = token.arg.replace(/e\+(\d)$/, 'e+0$1').replace(/e\-(\d)$/, 'e-0$1');

  // if alt, ensure a decimal point
  if(token.alternative){
    token.arg = token.arg.replace(/^(\d+)$/,'$1.');
    token.arg = token.arg.replace(/^(\d+)e/,'$1.e');
  }

  if(f >= 0 && token.sign){
    token.arg = token.sign + token.arg;
  }

  token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
};
Formatter.prototype.formatObject = function(token) {
  // If no precision is specified, then reset it to null (infinite depth).
  var precision = (token.period === '.') ? token.precision : null;
  token.arg = util.inspect(token.arg, !token.alternative, precision);
};
Formatter.prototype.zeroPad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.precision;
  var negative = false;
  if(typeof token.arg != "string"){
    token.arg = "" + token.arg;
  }
  if (token.arg.substr(0,1) === '-') {
    negative = true;
    token.arg = token.arg.substr(1);
  }

  var tenless = length - 10;
  while(token.arg.length < tenless){
    token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
  if (negative) token.arg = '-' + token.arg;
};
Formatter.prototype.fitField = function(token) {
  if(token.maxWidth >= 0 && token.arg.length > token.maxWidth){
    return token.arg.substring(0, token.maxWidth);
  }
  if(token.zeroPad){
    this.zeroPad(token, token.minWidth);
    return;
  }
  this.spacePad(token);
};
Formatter.prototype.spacePad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.minWidth;
  if(typeof token.arg != 'string'){
    token.arg = '' + token.arg;
  }
  var tenless = length - 10;
  while(token.arg.length < tenless){
    token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;
};


module.exports = function(){
  var args = Array.prototype.slice.call(arguments),
    stream, format;
  if(args[0] instanceof require('stream').Stream){
    stream = args.shift();
  }
  format = args.shift();
  var formatter = new Formatter(format);
  var string = formatter.format.apply(formatter, args);
  if(stream){
    stream.write(string);
  }else{
    return string;
  }
};

module.exports.Formatter = Formatter;


},{"stream":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js","util":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/util.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/invariant.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))

},{"_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/keyMirror.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

'use strict';

var invariant = require("./invariant");

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  ("production" !== process.env.NODE_ENV ? invariant(
    obj instanceof Object && !Array.isArray(obj),
    'keyMirror(...): Argument must be an object.'
  ) : invariant(obj instanceof Object && !Array.isArray(obj)));
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

}).call(this,require('_process'))

},{"./invariant":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/invariant.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/server/EventConstants.js":[function(require,module,exports){
'use strict';

var keyMirror = require('react/lib/keyMirror');

module.exports = keyMirror({
    MISSION_STARTED: null,
    MISSION_STOPPED: null,
    MISSION_RESET: null,
    MISSION_COMPLETED: null,
    APP_STATE: null,

    ADD_MESSAGE: null,

    //ACTIONS
    GET_EVENTS: null,
    SET_EVENTS: null,
    TRIGGER_EVENT: null,
    ADVANCE_CHAPTER: null,
    COMPLETE_MISSION: null,

    // SCIENCE TEAM EVENTS
    SCIENCE_CHECK_RADIATION: null,

    // ASTRONAUT TEAM EVENTS
    AST_CHECK_VITALS: null,

    // COMMUNICATION TEAM EVENTS
    COMM_INFORM_ASTRONAUT: null,
    COMM_CHECK_SAT_LINK: null,

    // SECURITY TEAM EVENTS
    SET_HIGH_C02: null,
    SECURITY_CHECK_DATA_TRANSFER: null,

    SET_HEART_RATE_HIGH: null,
    SET_HEART_RATE_MEDIUM: null,
    SET_HEART_RATE_LOW: null
});

},{"react/lib/keyMirror":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/keyMirror.js"}]},{},["./app/main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9tYWluLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvYWN0aW9ucy9Bc3Ryb1RlYW1BY3Rpb25DcmVhdG9ycy5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2FjdGlvbnMvTWVzc2FnZUFjdGlvbkNyZWF0b3JzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9hY3Rpb25zL1NjaWVuY2VBY3Rpb25DcmVhdG9ycy5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2FjdGlvbnMvU2VjdXJpdHlUZWFtQWN0aW9uQ3JlYXRvcnMuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9hY3Rpb25zL1RpbWVyQWN0aW9uQ3JlYXRvcnMuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9hcHBkaXNwYXRjaGVyLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY2xpZW50LWFwaS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NsaWVudC1ib290c3RyYXAuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2FwcC5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvYXN0cm9uYXV0LXRhc2sucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2JyZWF0aC1yYXRlLWNoYXJ0LnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9jb21tdW5pY2F0aW9uLXRhc2sucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2RpYWxvZ3MucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2R1bW15LXJlbmRlci5taXhpbi5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvZnVsbC1zY3JlZW4tdmlkZW8uanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2hlYWRlci5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvaGVhcnQtcmF0ZS1jaGFydC5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvaW5kZXgtYXBwLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9pbnRyb2R1Y3Rpb24tc2NyZWVuLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9tZXNzYWdlLWxpc3QucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL21pc3Npb24tY29tbWFuZGVyLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9taXNzaW9uLXRpbWVyLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9ub3QtZm91bmQucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL292ZXJsYXkucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL3JhZGlhdGlvbi1jaGFydC5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvcmFkaWF0aW9uLXNhbXBsZXIucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL3JhZGlhdGlvbi10YWJsZS5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvc2NpZW5jZS10YXNrLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9zZWN1cml0eS10YXNrLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy90YXNrLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy90ZWFtLWRpc3BsYXllci5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvdGltZXItcGFuZWwucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL3RpbWVyLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29uc3RhbnRzL0FzdHJvVGVhbUNvbnN0YW50cy5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbnN0YW50cy9NZXNzYWdlQ29uc3RhbnRzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29uc3RhbnRzL01pc3Npb25Db25zdGFudHMuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb25zdGFudHMvUm91dGVyQ29uc3RhbnRzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29uc3RhbnRzL1NjaWVuY2VUZWFtQ29uc3RhbnRzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29uc3RhbnRzL1RpbWVyQ29uc3RhbnRzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvcm91dGVyLWNvbnRhaW5lci5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3JvdXRlcy5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9iYXNlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL2JyZWF0aC1yYXRlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL2NhcmJvbi1kaW94aWRlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL2NvbW11bmljYXRpb24tcXVhbGl0eS1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9ldmVudC1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9oZWFydC1yYXRlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL2ludHJvZHVjdGlvbi1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9tZXNzYWdlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL21pc3Npb24tc3RhdGUtc3RvcmUuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9zdG9yZXMvb3h5Z2VuLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL3JhZGlhdGlvbi1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9yb3V0ZS1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy90YXNrLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL3RpbWVyLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvdGVhbS1uYW1lLW1hcC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3MtY2FsbC1jaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlLWNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2ZyZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZWYuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mdy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc3RhdGljcy1hY2NlcHQtcHJpbWl0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY2hlY2stdHlwZXMvc3JjL2NoZWNrLXR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmx1eC9saWIvRGlzcGF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9pbnZhcmlhbnQuanMiLCJub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvcHJpbnRmL2xpYi9wcmludGYuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIva2V5TWlycm9yLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9zZXJ2ZXIvRXZlbnRDb25zdGFudHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUNBQSxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDL0IsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDNUMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3hDLElBQU0sbUJBQW1CLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdjdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFHQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNudEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuREEsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7O0FBRWpELE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO0FBQ3ZCLG1CQUFlLEVBQUcsSUFBSTtBQUN0QixtQkFBZSxFQUFHLElBQUk7QUFDdEIsaUJBQWEsRUFBRyxJQUFJO0FBQ3BCLHFCQUFpQixFQUFHLElBQUk7QUFDeEIsYUFBUyxFQUFHLElBQUk7O0FBRWhCLGVBQVcsRUFBRyxJQUFJOzs7QUFHbEIsY0FBVSxFQUFHLElBQUk7QUFDakIsY0FBVSxFQUFHLElBQUk7QUFDakIsaUJBQWEsRUFBRyxJQUFJO0FBQ3BCLG1CQUFlLEVBQUcsSUFBSTtBQUN0QixvQkFBZ0IsRUFBRyxJQUFJOzs7QUFHdkIsMkJBQXVCLEVBQUcsSUFBSTs7O0FBRzlCLG9CQUFnQixFQUFHLElBQUk7OztBQUd2Qix5QkFBcUIsRUFBRyxJQUFJO0FBQzVCLHVCQUFtQixFQUFFLElBQUk7OztBQUl6QixnQkFBWSxFQUFHLElBQUk7QUFDbkIsZ0NBQTRCLEVBQUcsSUFBSTs7QUFHbkMsdUJBQW1CLEVBQUcsSUFBSTtBQUMxQix5QkFBcUIsRUFBRyxJQUFJO0FBQzVCLHNCQUFrQixFQUFHLElBQUk7Q0FDNUIsQ0FBQyxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IGRvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50Jyk7XG5jb25zdCB3aW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93Jyk7XG5jb25zdCBzZXJ2ZXJDb21tdW5pY2F0aW9uID0gcmVxdWlyZSgnLi9jbGllbnQtYXBpJyk7XG5cbi8vIHRoZSBhY3R1YWwgcmlnZ2luZyBvZiB0aGUgYXBwbGljYXRpb24gaXMgZG9uZSBpbiB0aGUgcm91dGVyIVxuY29uc3Qgcm91dGVyID0gcmVxdWlyZSgnLi9yb3V0ZXItY29udGFpbmVyJyk7XG5cbmNvbnN0IEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL1JvdXRlckNvbnN0YW50cycpO1xuXG5zZXJ2ZXJDb21tdW5pY2F0aW9uLnNldHVwKCk7XG5cbi8vIHRoZSBtaXNzaW9uIHRpbWVyIGdldHMgb3V0IHN5bmMgaWYgbG9zaW5nIGZvY3VzLCBzbyByZXN5bmMgd2l0aCBzZXJ2ZXIgZXZlcnkgdGltZSB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXNcbndpbmRvdy5vbmZvY3VzPXNlcnZlckNvbW11bmljYXRpb24uYXNrRm9yTWlzc2lvblRpbWU7XG5cbi8vIHJ1biBzdGFydHVwIGFjdGlvbnMgLSB1c3VhbGx5IG9ubHkgcmVsZXZhbnQgd2hlbiBkZXZlbG9waW5nXG5yZXF1aXJlKCcuL2NsaWVudC1ib290c3RyYXAnKS5ydW4oKTtcblxucm91dGVyLnJ1bigoSGFuZGxlciwgc3RhdGUpID0+IHtcbiAgICAvLyBwYXNzIHRoZSBzdGF0ZSBkb3duIGludG8gdGhlIFJvdXRlSGFuZGxlcnMsIGFzIHRoYXQgd2lsbCBtYWtlXG4gICAgLy8gdGhlIHJvdXRlciByZWxhdGVkIHByb3BlcnRpZXMgYXZhaWxhYmxlIG9uIGVhY2ggUkguIFRha2VuIGZyb20gVXBncmFkZSB0aXBzIGZvciBSZWFjdCBSb3V0ZXJcbiAgICBSZWFjdC5yZW5kZXIoPEhhbmRsZXIgey4uLnN0YXRlfS8+LCBkb2N1bWVudC5ib2R5KTtcbn0pO1xuXG4iLCJjb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgTUNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5jb25zdCBBc3RDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvQXN0cm9UZWFtQ29uc3RhbnRzJyk7XG5jb25zdCBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL01lc3NhZ2VBY3Rpb25DcmVhdG9ycycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vLyBsYXp5IGxvYWQgZHVlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuZnVuY3Rpb24gbGF6eVJlcXVpcmUocGF0aCkge1xuICAgIGxldCB0bXAgPSBudWxsO1xuICAgIHJldHVybiAoKT0+IHtcbiAgICAgICAgaWYgKCF0bXApIHRtcCA9IHJlcXVpcmUocGF0aCk7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgfVxufVxuY29uc3QgZ2V0U2VydmVyQVBJID0gbGF6eVJlcXVpcmUoJy4uL2NsaWVudC1hcGknKTtcbmNvbnN0IGdldE1pc3Npb25BQyA9IGxhenlSZXF1aXJlKCcuL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuLy8gZm9yIGJyb3dzZXJpZnkgdG8gd29yayBpdCBuZWVkcyB0byBmaW5kIHRoZXNlIG1hZ2ljIHN0cmluZ3NcbnJlcXVpcmUoJy4vTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG5yZXF1aXJlKCcuLi9jbGllbnQtYXBpJyk7XG5jb25zdCBUaW1lckFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9UaW1lckFjdGlvbkNyZWF0b3JzJyk7XG5cbndpbmRvdy5fX2FzdEFjdGlvbnMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8qIGluIHVuaXRzIHBlciBtaW51dGUgKi9cbiAgICBzZXRPeHlnZW5Db25zdW1wdGlvbih1bml0cykge1xuICAgICAgICBnZXRTZXJ2ZXJBUEkoKS5zZXRPeHlnZW5Db25zdW1wdGlvbih1bml0cyk7XG4gICAgfSxcblxuICAgIGhlYXJ0UmF0ZVJlYWQocmF0ZSl7XG4gICAgICAgIHZhciB0ZXh0LCBsZXZlbDtcbiAgICAgICAgaWYgKHJhdGUgPCA5MCkge1xuICAgICAgICAgICAgbGV2ZWwgPSAnaW5mbyc7XG4gICAgICAgICAgICB0ZXh0ID0gJ0ZpbmUgdmVyZGllcic7XG4gICAgICAgIH0gZWxzZSBpZiAocmF0ZSA+IDEyMCkge1xuICAgICAgICAgICAgdGV4dCA9ICdWZWxkaWcgaMO4eWUgdmVyZGllciEnO1xuICAgICAgICAgICAgbGV2ZWwgPSAnZGFuZ2VyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSAnR2Fuc2tlIGjDuHkgaGplcnRlcnl0bWUuIEdydW5uIHRpbCBiZWt5bXJpbmc/JztcbiAgICAgICAgICAgIGxldmVsID0gJ3dhcm5pbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgTWVzc2FnZUFjdGlvbkNyZWF0b3JzLmFkZE1lc3NhZ2Uoe3RleHQsIGxldmVsLCBkdXJhdGlvbjogMjB9KTtcbiAgICB9LFxuXG4gICAgc3RhcnRNb25pdG9yVGFzaygpe1xuXG4gICAgICAgIFRpbWVyQWN0aW9uQ3JlYXRvcnMucmVzZXRUaW1lcihBc3RDb25zdGFudHMuSEVBUlRfUkFURV9USU1FUik7XG4gICAgICAgIFRpbWVyQWN0aW9uQ3JlYXRvcnMucmVzZXRUaW1lcihBc3RDb25zdGFudHMuUkVTUElSQVRJT05fVElNRVIpO1xuICAgICAgICBnZXRNaXNzaW9uQUMoKS5zdGFydFRhc2soJ2FzdHJvbmF1dCcsICdicmVhdGhpbmdfdGltZXInKVxuICAgIH1cblxufTtcbiIsImNvbnN0IEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyksXG4gICAgdXVpZCA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKS51dWlkLFxuICAgIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NZXNzYWdlQ29uc3RhbnRzJyk7XG5cbmNvbnN0IGFjdGlvbnMgPSB7XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtc2cudGV4dCB0aGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBbbXNnLmlkXSB0aGUgbWVzc2FnZSBpZC4gaWYgbm90IGdpdmVuLCBvbmUgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIFttc2cubGV2ZWxdIHNhbWUgYXMgYm9vdHN0cmFwJ3MgYWxlcnQgY2xhc3NlczogW3N1Y2Nlc3MsIGluZm8sIHdhcm5pbmcsIGRhbmdlcl1cbiAgICAgKiBAcGFyYW0gW21zZy5kdXJhdGlvbl0ge051bWJlcn0gb3B0aW9uYWwgZHVyYXRpb24gZm9yIHRyYW5zaWVudCBtZXNzYWdlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIG1lc3NhZ2UgaWRcbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKG1zZykge1xuICAgICAgICB2YXIgaWQgPSBtc2cuaWQ7XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgaWQgPSB1dWlkKCk7XG4gICAgICAgICAgICBtc2cuaWQgPSBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbXNnLmxldmVsKSB7XG4gICAgICAgICAgICBtc2cubGV2ZWwgPSAnc3VjY2Vzcyc7XG4gICAgICAgIH1cblxuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGNvbnN0YW50cy5NRVNTQUdFX0FEREVELFxuICAgICAgICAgICAgICAgIGRhdGE6IG1zZ1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtc2cuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYWN0aW9ucy5yZW1vdmVNZXNzYWdlKG1zZy5pZCksIG1zZy5kdXJhdGlvbiAqIDEwMDApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1zZyB3aXRoIGRlZmF1bHQgZHVyYXRpb24gb2YgNSBzZWNvbmRzXG4gICAgICogQHBhcmFtIG1zZ1xuICAgICAqIEBwYXJhbSBbZHVyYXRpb25dIGRlZmF1bHQgb2YgNSBzZWNvbmRzXG4gICAgICpcbiAgICAgKiBAc2VlICNhZGRNZXNzYWdlKCkgZm9yIG1vcmUgcGFyYW1zXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIG1lc3NhZ2UgaWRcbiAgICAgKi9cbiAgICBhZGRUcmFuc2llbnRNZXNzYWdlKG1zZywgZHVyYXRpb24gPSA1KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25zLmFkZE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7ZHVyYXRpb259LCBtc2cpKVxuICAgIH0sXG5cbiAgICByZW1vdmVNZXNzYWdlKGlkKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogY29uc3RhbnRzLlJFTU9WRV9NRVNTQUdFLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlkXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG59O1xuXG4vLyBwcmV2ZW50IG5ldyBwcm9wZXJ0aWVzIGZyb20gYmVpbmcgYWRkZWQgb3IgcmVtb3ZlZFxuT2JqZWN0LmZyZWV6ZShhY3Rpb25zKTtcbndpbmRvdy5fX01lc3NhZ2VBY3Rpb25zID0gYWN0aW9ucztcbm1vZHVsZS5leHBvcnRzID0gYWN0aW9uczsiLCJjb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpLFxuICAgIE1pc3Npb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpLFxuICAgIHJvdXRlciA9IHJlcXVpcmUoJy4vLi4vcm91dGVyLWNvbnRhaW5lcicpO1xuXG4vLyBsYXp5IGxvYWQgZHVlIHRvIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuY29uc3Qgc2VydmVyQVBJID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXBpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcGkpIHtcbiAgICAgICAgICAgIGFwaSA9IHJlcXVpcmUoJy4uL2NsaWVudC1hcGknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH1cbn0pKCk7XG5cbnZhciB0bXAgPSB7XG5cbiAgICBzdGFydE1pc3Npb24oKXtcbiAgICAgICAgc2VydmVyQVBJKCkuc3RhcnRNaXNzaW9uKCk7XG4gICAgfSxcblxuICAgIHN0b3BNaXNzaW9uKCl7XG4gICAgICAgIHNlcnZlckFQSSgpLnN0b3BNaXNzaW9uKCk7XG4gICAgfSxcblxuICAgIHJlc2V0TWlzc2lvbigpe1xuICAgICAgICBzZXJ2ZXJBUEkoKS5yZXNldE1pc3Npb24oKTtcbiAgICB9LFxuXG4gICAgbWlzc2lvblN0YXJ0ZWQoKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5NSVNTSU9OX1NUQVJURURfRVZFTlR9KTtcbiAgICB9LFxuXG4gICAgbWlzc2lvblN0b3BwZWQoKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5NSVNTSU9OX1NUT1BQRURfRVZFTlR9KTtcbiAgICB9LFxuXG4gICAgbWlzc2lvbldhc1Jlc2V0KCl7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5NSVNTSU9OX1dBU19SRVNFVH0pO1xuICAgICAgICBzZXJ2ZXJBUEkoKS5hc2tGb3JBcHBTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBtaXNzaW9uQ29tcGxldGVkKCkge1xuICAgICAgICAvL0FwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5NSVNTSU9OX0NPTVBMRVRFRF9FVkVOVH0pO1xuICAgICAgICByb3V0ZXIudHJhbnNpdGlvblRvKCcvY29tcGxldGVkJyk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlTWlzc2lvbigpe1xuICAgICAgICBzZXJ2ZXJBUEkoKS5jb21wbGV0ZU1pc3Npb24oKTtcbiAgICB9LFxuXG4gICAgcmVjZWl2ZWRFdmVudHMoZXZlbnRzQ29sbGVjdGlvbil7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzQ29sbGVjdGlvbiwge2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5SRUNFSVZFRF9FVkVOVFN9KSk7XG4gICAgfSxcblxuICAgIGFza0ZvckV2ZW50cygpe1xuICAgICAgICBzZXJ2ZXJBUEkoKS5hc2tGb3JFdmVudHMoKTtcbiAgICB9LFxuXG4gICAgaW50cm9XYXNSZWFkKHRlYW1JZCkge1xuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHthY3Rpb246IE1pc3Npb25Db25zdGFudHMuSU5UUk9EVUNUSU9OX1JFQUQsIHRlYW1OYW1lOiB0ZWFtSWR9KTtcbiAgICAgICAgc2VydmVyQVBJKCkuc2VuZFRlYW1TdGF0ZUNoYW5nZSgpO1xuICAgIH0sXG5cbiAgICBjaGFuZ2VTY3J1YmJlcigpe1xuICAgICAgICBzZXJ2ZXJBUEkoKS5hc2tUb0NoYW5nZVNjcnViRmlsdGVyKCk7XG4gICAgfSxcblxuICAgIHN0YXJ0VGFzayh0ZWFtSWQsIHRhc2tJZCl7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5TVEFSVF9UQVNLLCB0ZWFtSWQsIHRhc2tJZH0pO1xuICAgICAgICBzZXJ2ZXJBUEkoKS5zZW5kVGVhbVN0YXRlQ2hhbmdlKCk7XG4gICAgfSxcblxuICAgIHRhc2tDb21wbGV0ZWQodGVhbUlkLCB0YXNrSWQpICAge1xuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHthY3Rpb246IE1pc3Npb25Db25zdGFudHMuQ09NUExFVEVEX1RBU0ssIHRhc2tJZCwgdGVhbUlkfSk7XG4gICAgICAgIHNlcnZlckFQSSgpLnNlbmRUZWFtU3RhdGVDaGFuZ2UoKTtcblxuICAgICAgICAvLyBhbHNvIHB1Ymxpc2ggdGhpcyB0byBzZXJ2ZXIgYXMgc2VwYXJhdGUgZXZlbnQ/IC0gbWF5YmUgdG8gdHJpZ2dlciBzb21ldGhpbmcgYXQgY2VydGFpbiBwb2ludD9cbiAgICB9LFxuXG4gICAgYXNrVG9TdGFydE5leHRDaGFwdGVyKCl7XG4gICAgICAgIHNlcnZlckFQSSgpLmFza1RvU3RhcnROZXh0Q2hhcHRlcigpO1xuICAgIH0sXG5cbiAgICBhc2tUb1RyaWdnZXJFdmVudCh1dWlkKXtcbiAgICAgICAgc2VydmVyQVBJKCkudHJpZ2dlckV2ZW50KHV1aWQpO1xuICAgIH0sXG5cbiAgICBzZXRNaXNzaW9uVGltZShlbGFwc2VkU2Vjb25kcyl7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgYWN0aW9uOiBNaXNzaW9uQ29uc3RhbnRzLk1JU1NJT05fVElNRV9TWU5DLFxuICAgICAgICAgICAgZGF0YToge2VsYXBzZWRNaXNzaW9uVGltZTogZWxhcHNlZFNlY29uZHN9XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59O1xuXG53aW5kb3cuX19NaXNzaW9uQUMgPSB0bXA7XG5tb2R1bGUuZXhwb3J0cyA9IHRtcDtcbiIsImNvbnN0IEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBSYWRpYXRpb25TdG9yZSA9IHJlcXVpcmUoJy4vLi4vc3RvcmVzL3JhZGlhdGlvbi1zdG9yZScpO1xuY29uc3QgU2NpZW5jZVRlYW1Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvU2NpZW5jZVRlYW1Db25zdGFudHMnKTtcbmNvbnN0IE1pc3Npb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgTWVzc2FnZUFjdGlvbnNDcmVhdG9ycyA9IHJlcXVpcmUoJy4vTWVzc2FnZUFjdGlvbkNyZWF0b3JzJyk7XG5jb25zdCBUaW1lckFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9UaW1lckFjdGlvbkNyZWF0b3JzJyk7XG5jb25zdCBhcGkgPSByZXF1aXJlKCcuLi9jbGllbnQtYXBpJyk7XG5cbnZhciBtaXNzaW9uQWN0aW9uQ3JlYXRvcnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRtcDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdG1wKSB0bXAgPSByZXF1aXJlKCcuLi9hY3Rpb25zL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgIH1cbn0pKCk7XG5cblxuY29uc3QgYWN0aW9ucyA9IHtcblxuICAgIHN0YXJ0U2FtcGxlVGFzaygpe1xuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHthY3Rpb246IFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfQ0xFQVJfUkFESUFUSU9OX1NBTVBMRVN9KTtcbiAgICAgICAgbWlzc2lvbkFjdGlvbkNyZWF0b3JzKCkuc3RhcnRUYXNrKCdzY2llbmNlJywgJ3NhbXBsZScpO1xuICAgICAgICB0aGlzLnJlc2V0U2FtcGxpbmdUaW1lcigpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZVRhc2sodGFza0lkKXtcbiAgICAgICAgbWlzc2lvbkFjdGlvbkNyZWF0b3JzKCkudGFza0NvbXBsZXRlZCgnc2NpZW5jZScsIHRhc2tJZCk7XG4gICAgfSxcblxuICAgIHJlc2V0U2FtcGxpbmdUaW1lcigpIHtcbiAgICAgICAgVGltZXJBY3Rpb25DcmVhdG9ycy5yZXNldFRpbWVyKFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfVElNRVJfMSk7XG4gICAgfSxcblxuICAgIHRha2VSYWRpYXRpb25TYW1wbGUoKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgYWN0aW9uOiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1RBS0VfUkFESUFUSU9OX1NBTVBMRVxuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICBhdmVyYWdlUmFkaWF0aW9uQ2FsY3VsYXRlZChhdmVyYWdlKXtcbiAgICAgICAgbGV0IHNhbXBsZXMgPSBSYWRpYXRpb25TdG9yZS5nZXRTYW1wbGVzKCk7XG5cbiAgICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgc3VtID0gc2FtcGxlcy5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHByZXYgKyBjdXJyZW50LCAwKSxcbiAgICAgICAgICAgICAgICB0cnVlQ2FsY3VsYXRlZEF2ZXJhZ2UgPSBzdW0gLyBzYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkaWZmSW5QZXJjZW50ID0gMTAwICogTWF0aC5hYnMoKHRydWVDYWxjdWxhdGVkQXZlcmFnZSAtIGF2ZXJhZ2UpIC8gdHJ1ZUNhbGN1bGF0ZWRBdmVyYWdlKTtcblxuICAgICAgICAgICAgaWYgKGRpZmZJblBlcmNlbnQgPiAxNSkge1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25zQ3JlYXRvcnMuYWRkVHJhbnNpZW50TWVzc2FnZSh7dGV4dDogJ011bGlnIGRldCBnamVubm9tc25pdHRldCBibGUgbGl0dCBmZWlsLid9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gICAgICAgICAgICBhY3Rpb246IFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfQVZHX1JBRElBVElPTl9DQUxDVUxBVEVELFxuICAgICAgICAgICAgZGF0YToge2F2ZXJhZ2V9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhdmVyYWdlID4gU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9BVkdfUkFEX1JFRF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25zQ3JlYXRvcnMuYWRkVHJhbnNpZW50TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdGV4dDogJ1ZlbGRpZyBow7h5dCByYWRpb2FrdGl2dCBuaXbDpSBkZXRla3RlcnQuIFZhcnNsZSBzaWtrZXJoZXRzdGVhbWV0IHVtaWRkZWxiYXJ0IScsXG4gICAgICAgICAgICAgICAgbGV2ZWw6ICdkYW5nZXInLFxuICAgICAgICAgICAgICAgIGlkOiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1JBRElBVElPTl9XQVJOSU5HX01TR1xuICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICB9IGVsc2UgaWYgKGF2ZXJhZ2UgPiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX0FWR19SQURfT1JBTkdFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgTWVzc2FnZUFjdGlvbnNDcmVhdG9ycy5hZGRUcmFuc2llbnRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnSMO4eWUgdmVyZGllciBhdiByYWRpb2FrdGl2aXRldC4gRsO4bGcgbWVkIHDDpSBvbSBkZXQgZ8OlciBuZWRvdmVyIGlnamVuJyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIGlkOiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1JBRElBVElPTl9XQVJOSU5HX01TR1xuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wbGV0ZVRhc2soJ2F2ZXJhZ2UnKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJhZGlhdGlvbiBsZXZlbCB0aGF0IHdpbGwgYmUgcmVwb3J0ZWQgdG8gdGhlIHZpZXcgbGF5ZXJcbiAgICAgKiBUaGUgcmVwb3J0ZWQgcmFkaWF0aW9uIHdpbGwgZ2VuZXJhdGVkIHZhbHVlcyBpbiB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhlIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIFdlIGFyZSBub3QgYWN0dWFsbHkgcmVjZWl2aW5nIGEgc3RyZWFtIG9mIHZhbHVlcyBmcm9tIHRoZSBzZXJ2ZXIsIGFzIHRoYXQgY291bGRcbiAgICAgKiBiZSB2ZXJ5IHJlc291cmNlIGhlYXZ5LiBJbnN0ZWFkIHdlIGdlbmVyYXRlIHJhbmRvbSB2YWx1ZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gdmFsdWVzLFxuICAgICAqIHdoaWNoIHRvIHRoZSB1c2VyIHdpbGwgbG9vayB0aGUgc2FtZS5cbiAgICAgKiBAcGFyYW0gbWluXG4gICAgICogQHBhcmFtIG1heFxuICAgICAqL1xuICAgICAgICBzZXRSYWRpYXRpb25MZXZlbChtaW4sIG1heCkge1xuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGFjdGlvbjogU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9SQURJQVRJT05fTEVWRUxfQ0hBTkdFRCxcbiAgICAgICAgICAgIGRhdGE6IHttaW4sIG1heH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZFRvVG90YWxSYWRpYXRpb25MZXZlbChhbW91bnQpe1xuXG4gICAgICAgIHZhciB0b3RhbCA9IGFtb3VudCArIFJhZGlhdGlvblN0b3JlLmdldFRvdGFsTGV2ZWwoKTtcblxuICAgICAgICBpZiAodG90YWwgPiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1RPVEFMX1JBRElBVElPTl9WRVJZX1NFUklPVVNfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICBNZXNzYWdlQWN0aW9uc0NyZWF0b3JzLmFkZFRyYW5zaWVudE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiAnc2NpZW5jZV9oaWdoX3JhZGlhdGlvbl9sZXZlbCcsXG4gICAgICAgICAgICAgICAgdGV4dDogJ0ZhcmV0cnVlbmRlIGjDuHl0IHN0csOlbGluZ3NuaXbDpSEnLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnZGFuZ2VyJ1xuICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICB9IGVsc2UgaWYgKHRvdGFsID4gU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9UT1RBTF9SQURJQVRJT05fU0VSSU9VU19USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25zQ3JlYXRvcnMuYWRkVHJhbnNpZW50TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6ICdzY2llbmNlX2hpZ2hfcmFkaWF0aW9uX2xldmVsJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnSMO4eXQgc3Ryw6VsaW5nc25pdsOlIScsXG4gICAgICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJ1xuICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICB9XG5cbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gICAgICAgICAgICBhY3Rpb246IFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfVE9UQUxfUkFESUFUSU9OX0xFVkVMX0NIQU5HRUQsXG4gICAgICAgICAgICBkYXRhOiB7dG90YWwsIGFkZGVkOiBhbW91bnR9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29tcGxldGVUYXNrKCdhZGR0b3RhbCcpO1xuICAgIH1cblxufTtcblxud2luZG93Ll9fU2NpZW5jZUFjdGlvbnMgPSBhY3Rpb25zO1xubW9kdWxlLmV4cG9ydHMgPSBhY3Rpb25zOyIsImNvbnN0IE1lc3NhZ2VBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTWVzc2FnZUFjdGlvbkNyZWF0b3JzJyk7XG5cbi8vIGxhenkgbG9hZCBkdWUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5mdW5jdGlvbiBsYXp5UmVxdWlyZShwYXRoKSB7XG4gICAgbGV0IHRtcCA9IG51bGw7XG4gICAgcmV0dXJuICgpPT4ge1xuICAgICAgICBpZiAoIXRtcCkgdG1wID0gcmVxdWlyZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICB9XG59XG5jb25zdCBnZXRNaXNzaW9uQUMgPSBsYXp5UmVxdWlyZSgnLi9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IGdldFNlcnZlckFQSSA9IGxhenlSZXF1aXJlKCcuLi9jbGllbnQtYXBpJyk7XG4vLyBmb3IgYnJvd3NlcmlmeSB0byB3b3JrIGl0IG5lZWRzIHRvIGZpbmQgdGhlc2UgbWFnaWMgc3RyaW5nc1xucmVxdWlyZSgnLi9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcbnJlcXVpcmUoJy4uL2NsaWVudC1hcGknKTtcblxudmFyIGFjdGlvbnMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzdGFydERhdGFUcmFuc2ZlckNoZWNrKCl7XG4gICAgICAgIGdldE1pc3Npb25BQygpLnN0YXJ0VGFzaygnc2VjdXJpdHknLCAnc2lnbmFsX3Rlc3QnKVxuICAgIH0sXG5cbiAgICBlbmREYXRhUXVhbGl0eVRlc3QoZ29vZE91dGNvbWUpe1xuICAgICAgICBpZiAoIWdvb2RPdXRjb21lKSB7XG4gICAgICAgICAgICBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdGV4dDogJ0t2YWxpdGV0ZW4gcMOlIGtvbW11bmlrYXNqb25zc2lnbmFsZXQgZXIgZm9yIGTDpXJsaWcuIEVyIHJlcGFyYXNqb25lbiBmdWxsZsO4cnQ/JyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdGV4dDogJ1RFU1QgT0snLCBkdXJhdGlvbjogMiwgbGV2ZWw6ICdpbmZvJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhY3Rpb25zLnNlbmRSZWFkeUZvclNhZmVNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWlzc2lvbkFDKCkudGFza0NvbXBsZXRlZCgnc2VjdXJpdHknLCAnc2lnbmFsX3Rlc3QnKVxuICAgIH0sXG5cbiAgICBlbmREYXRhVHJhbnNmZXJUZXN0KGdvb2RPdXRjb21lKXtcbiAgICAgICAgaWYgKCFnb29kT3V0Y29tZSkge1xuICAgICAgICAgICAgTWVzc2FnZUFjdGlvbkNyZWF0b3JzLmFkZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHRleHQ6ICdPdmVyZsO4cmluZ2VuIGF2IGRhdGEgdmFyIGZvciB1c3RhYmlsLiBUZXN0ZW4gZmVpbGV0LicsXG4gICAgICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ2V0TWlzc2lvbkFDKCkudGFza0NvbXBsZXRlZCgnc2VjdXJpdHknLCAnc2lnbmFsX3Rlc3QnKVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdGV4dDogJ1RFU1QgT0snLCBkdXJhdGlvbjogMiwgbGV2ZWw6ICdpbmZvJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VuZFJlYWR5Rm9yU2FmZU1vZGUoKXtcbiAgICAgICAgZ2V0U2VydmVyQVBJKCkuc2V0UmVhZHlGb3JTYWZlTW9kZSgpO1xuICAgIH0sXG5cbiAgICBzZXRJblNhZmVNb2RlKCl7XG4gICAgICAgIGdldFNlcnZlckFQSSgpLnNldEluU2FmZU1vZGUoKTtcbiAgICB9XG59O1xuXG53aW5kb3cuX19TZWNUZWFtQWN0aW9ucyA9IGFjdGlvbnM7IiwiY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9UaW1lckNvbnN0YW50cycpO1xuXG5jb25zdCBhY3Rpb25zID0ge1xuXG4gICAgc3RhcnRUaW1lcihpZCkge1xuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHthY3Rpb246IGNvbnN0YW50cy5TVEFSVF9USU1FUiwgZGF0YToge3RpbWVySWQ6IGlkfX0pO1xuICAgIH0sXG5cbiAgICByZXNldFRpbWVyKGlkKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogY29uc3RhbnRzLlJFU0VUX1RJTUVSLCBkYXRhOiB7dGltZXJJZDogaWR9fSk7XG4gICAgfSxcblxuICAgIHN0b3BUaW1lcihpZCkge1xuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHthY3Rpb246IGNvbnN0YW50cy5TVE9QX1RJTUVSLCBkYXRhOiB7dGltZXJJZDogaWR9fSk7XG4gICAgfSxcblxuICAgIHNldFRpbWVyKHRpbWVySWQsIHRpbWUpIHtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gICAgICAgICAgICBhY3Rpb246IGNvbnN0YW50cy5TRVRfVElNRVIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nVGltZTogdGltZSxcbiAgICAgICAgICAgICAgICB0aW1lcklkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhY3Rpb25zOyIsIi8qXG4gKiBEaXNwYXRjaGVyIC0gYSBzaW5nbGV0b25cbiAqXG4gKiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBtYWluIGRyaXZlciBpbiB0aGUgRmx1eCBhcmNoaXRlY3R1cmVcbiAqIEBzZWUgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9mbHV4L2RvY3Mvb3ZlcnZpZXcuaHRtbFxuKi9cblxuY29uc3QgeyBEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCdmbHV4Jyk7XG5cbmNvbnN0IEFwcERpc3BhdGNoZXIgPSBPYmplY3QuYXNzaWduKG5ldyBEaXNwYXRjaGVyKCksIHtcblxuICAgIC8vIG9wdGlvbmFsIG1ldGhvZHNcblxufSk7XG5cbndpbmRvdy5fX0FwcERpc3BhdGNoZXI9IEFwcERpc3BhdGNoZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEFwcERpc3BhdGNoZXI7IiwiY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8nKTtcbmNvbnN0IHNvY2tldCA9IGlvKCk7XG5jb25zdCBNaXNzaW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgTWlzc2lvbkFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9hY3Rpb25zL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuY29uc3QgTWVzc2FnZUFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9hY3Rpb25zL01lc3NhZ2VBY3Rpb25DcmVhdG9ycycpO1xuY29uc3QgU2NpZW5jZVRlYW1BY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYWN0aW9ucy9TY2llbmNlQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IFNlY3VyaXR5VGVhbUFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9hY3Rpb25zL1NlY3VyaXR5VGVhbUFjdGlvbkNyZWF0b3JzJyk7XG5jb25zdCBBc3Ryb1RlYW1UZWFtQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2FjdGlvbnMvQXN0cm9UZWFtQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IFJhZGlhdGlvblN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZXMvcmFkaWF0aW9uLXN0b3JlJyk7XG5jb25zdCBUaW1lclN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZXMvdGltZXItc3RvcmUnKTtcbmNvbnN0IFRhc2tTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmVzL3Rhc2stc3RvcmUnKTtcbmNvbnN0IEludHJvZHVjdGlvblN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZXMvaW50cm9kdWN0aW9uLXN0b3JlJyk7XG5jb25zdCBSb3V0ZXIgPSByZXF1aXJlKCcuL3JvdXRlci1jb250YWluZXInKTtcbmNvbnN0IEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi4vc2VydmVyL0V2ZW50Q29uc3RhbnRzJyk7XG5cbnZhciBhcGkgPSB7XG5cbiAgICBzZXR1cCgpIHtcblxuICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RlZCB0byBzZXJ2ZXIgV2ViU29ja2V0XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBc2tpbmcgc2VydmVyIGZvciBhcHAgc3RhdGVcIik7XG4gICAgICAgICAgICBhcGkuYXNrRm9yQXBwU3RhdGUoKTtcbiAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25DcmVhdG9ycy5yZW1vdmVNZXNzYWdlKCdkaXNjb25uZWN0IG1lc3NhZ2UnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVzc2FnZUFjdGlvbkNyZWF0b3JzLmFkZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiAnZGlzY29ubmVjdCBtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnTWlzdGV0IGtvbnRha3QgbWVkIHNlcnZlcmVuLiBMYXN0IHNpZGVuIHDDpSBueXR0JyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ2RhbmdlcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oRXZlbnRDb25zdGFudHMuTUlTU0lPTl9TVEFSVEVELCAoYXBwU3RhdGUpID0+IHtcbiAgICAgICAgICAgIE1pc3Npb25BY3Rpb25DcmVhdG9ycy5taXNzaW9uU3RhcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy5fYXBwU3RhdGVSZWNlaXZlZChhcHBTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQub24oRXZlbnRDb25zdGFudHMuTUlTU0lPTl9TVE9QUEVELCAoKSA9PiBNaXNzaW9uQWN0aW9uQ3JlYXRvcnMubWlzc2lvblN0b3BwZWQoKSk7XG4gICAgICAgIHNvY2tldC5vbihFdmVudENvbnN0YW50cy5NSVNTSU9OX0NPTVBMRVRFRCwgKCk9PiBNaXNzaW9uQWN0aW9uQ3JlYXRvcnMubWlzc2lvbkNvbXBsZXRlZCgpKTtcbiAgICAgICAgc29ja2V0Lm9uKEV2ZW50Q29uc3RhbnRzLk1JU1NJT05fUkVTRVQsICgpPT4gTWlzc2lvbkFjdGlvbkNyZWF0b3JzLm1pc3Npb25XYXNSZXNldCgpKTtcblxuICAgICAgICBzb2NrZXQub24oRXZlbnRDb25zdGFudHMuU0VUX0VWRU5UUywgTWlzc2lvbkFjdGlvbkNyZWF0b3JzLnJlY2VpdmVkRXZlbnRzKTtcbiAgICAgICAgc29ja2V0Lm9uKEV2ZW50Q29uc3RhbnRzLkFERF9NRVNTQUdFLCAoc2VydmVyTXNnKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VydmVyTXNnLmF1ZGllbmNlICYmIHNlcnZlck1zZy5hdWRpZW5jZSAhPT0gUm91dGVyLmdldFRlYW1JZCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25DcmVhdG9ycy5hZGRNZXNzYWdlKHNlcnZlck1zZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignbWlzc2lvbiB0aW1lJywgTWlzc2lvbkFjdGlvbkNyZWF0b3JzLnNldE1pc3Npb25UaW1lKTtcblxuICAgICAgICBzb2NrZXQub24oRXZlbnRDb25zdGFudHMuQVBQX1NUQVRFLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FwcFN0YXRlUmVjZWl2ZWQoc3RhdGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiB0aGUgY2xpZW50IG1pc3NlcyB0aGUgbWVzc2FnZS9ldmVudCBpdCBpcyBsb3N0IC4uLiBhbmQgdGhlIGN1cnJlbnRfZXZlbnQgd2lsbCBiZSB1bmNoYW5nZWQgOi0oXG4gICAgICAgIC8vIFRPRE86IHN0b3JlIGl0IHNlcnZlcl9zaWRlIGluIHRoZSB0ZWFtU3RhdGUgYmVmb3JlIHNlbmRpbmdcbiAgICAgICAgc29ja2V0Lm9uKEV2ZW50Q29uc3RhbnRzLkFTVF9DSEVDS19WSVRBTFMsICgpPT4ge1xuICAgICAgICAgICAgQXN0cm9UZWFtVGVhbUFjdGlvbkNyZWF0b3JzLnN0YXJ0TW9uaXRvclRhc2soKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKEV2ZW50Q29uc3RhbnRzLlNDSUVOQ0VfQ0hFQ0tfUkFESUFUSU9OLCAoKT0+IHtcbiAgICAgICAgICAgIFNjaWVuY2VUZWFtQWN0aW9uQ3JlYXRvcnMuc3RhcnRTYW1wbGVUYXNrKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbihFdmVudENvbnN0YW50cy5TRUNVUklUWV9DSEVDS19EQVRBX1RSQU5TRkVSLCAoKT0+IHtcbiAgICAgICAgICAgIFNlY3VyaXR5VGVhbUFjdGlvbkNyZWF0b3JzLnN0YXJ0RGF0YVRyYW5zZmVyQ2hlY2soKTtcbiAgICAgICAgfSk7XG5cblxuICAgIH0sXG5cbiAgICBzdGFydE1pc3Npb24oKXtcbiAgICAgICAgc29ja2V0LmVtaXQoJ3N0YXJ0IG1pc3Npb24nKTtcbiAgICB9LFxuXG4gICAgc3RvcE1pc3Npb24oKXtcbiAgICAgICAgc29ja2V0LmVtaXQoJ3N0b3AgbWlzc2lvbicpO1xuICAgIH0sXG5cbiAgICByZXNldE1pc3Npb24oKXtcbiAgICAgICAgc29ja2V0LmVtaXQoJ3Jlc2V0IG1pc3Npb24nKTtcbiAgICB9LFxuXG4gICAgYXNrVG9TdGFydE5leHRDaGFwdGVyKCl7XG4gICAgICAgIHNvY2tldC5lbWl0KEV2ZW50Q29uc3RhbnRzLkFEVkFOQ0VfQ0hBUFRFUik7XG4gICAgfSxcblxuICAgIHRyaWdnZXJFdmVudCh1dWlkKXtcbiAgICAgICAgc29ja2V0LmVtaXQoRXZlbnRDb25zdGFudHMuVFJJR0dFUl9FVkVOVCwgdXVpZCk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogU2VuZCB0aGUgY2xpZW50IGhlbGQgc3RhdGUgKGZvciB0aGUgY3VycmVudCB0ZWFtKSB0byBzZXJ2ZXIgb24gY2hhbmdlXG4gICAgICogVGhlIG1vc3QgaW1wb3J0YW50IGJpdHMgYXJlIGhlbGQgb24gc2VydmVyLCBhbmQgaXMgbm90IHRyYW5zZmVycmVkIGJhY2ssXG4gICAgICogc3VjaCBhcyBpZiB0aGUgbWlzc2lvbiBpcyBydW5uaW5nLCB0aGUgY3VycmVudCBjaGFwdGVyLCBldGMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGltcG9ydGFudCB0byBzdG9yZSBvbiB0aGUgc2VydmVyIGluIGNhc2Ugd2UgZHJvcCB0aGUgY29ubmVjdGlvbiBhbmQgcmVjb25uZWN0IGluIG90aGVyIHNlc3Npb25cbiAgICAgKi9cbiAgICBzZW5kVGVhbVN0YXRlQ2hhbmdlKHRlYW1JZCA9IFJvdXRlci5nZXRUZWFtSWQoKSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB7fTtcblxuICAgICAgICBzdGF0ZS50ZWFtID0gdGVhbUlkO1xuICAgICAgICBzdGF0ZS5pbnRyb2R1Y3Rpb25fcmVhZCA9IEludHJvZHVjdGlvblN0b3JlLmlzSW50cm9kdWN0aW9uUmVhZCh0ZWFtSWQpO1xuICAgICAgICBzdGF0ZS5jdXJyZW50X3Rhc2sgPSBUYXNrU3RvcmUuZ2V0Q3VycmVudFRhc2tJZCh0ZWFtSWQpO1xuXG4gICAgICAgIGlmICh0ZWFtSWQgPT09ICdzY2llbmNlJykge1xuICAgICAgICAgICAgc3RhdGUucmFkaWF0aW9uID0gUmFkaWF0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvY2tldC5lbWl0KCdzZXQgdGVhbSBzdGF0ZScsIHN0YXRlKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGVNaXNzaW9uKCl7XG4gICAgICAgIHNvY2tldC5lbWl0KEV2ZW50Q29uc3RhbnRzLkNPTVBMRVRFX01JU1NJT04pO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIFRoaXMgaXMgb25seSBzdHViYmVkIG91dCB1bnRpbCBzZXJ2ZXIgY29tbXVuaWNhdGlvbiBpcyB1cCBhbmQgcnVubmluZ1xuICAgICAqL1xuICAgIGFza0ZvckFwcFN0YXRlKCkge1xuICAgICAgICBzb2NrZXQuZW1pdCgnZ2V0IGFwcCBzdGF0ZScpO1xuICAgIH0sXG5cbiAgICBhc2tGb3JNaXNzaW9uVGltZSgpe1xuICAgICAgICBzb2NrZXQuZW1pdCgnZ2V0IG1pc3Npb24gdGltZScpO1xuICAgIH0sXG5cbiAgICBhc2tUb0NoYW5nZVNjcnViRmlsdGVyKCl7XG4gICAgICAgIHNvY2tldC5lbWl0KCdzZXQgc2NydWIgZmlsdGVyIGNoYW5nZWQnKVxuICAgIH0sXG5cbiAgICBfYXBwU3RhdGVSZWNlaXZlZChhcHBTdGF0ZSkge1xuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHthY3Rpb246IE1pc3Npb25Db25zdGFudHMuUkVDRUlWRURfQVBQX1NUQVRFLCBhcHBTdGF0ZX0pO1xuICAgIH0sXG5cbiAgICBhc2tGb3JFdmVudHMoKXtcbiAgICAgICAgc29ja2V0LmVtaXQoRXZlbnRDb25zdGFudHMuR0VUX0VWRU5UUyk7XG4gICAgfSxcblxuICAgIHNldE94eWdlbkNvbnN1bXB0aW9uKHVuaXRzKSB7XG4gICAgICAgIHNvY2tldC5lbWl0KCdzZXQgb3h5Z2VuIGNvbnN1bXB0aW9uJywgdW5pdHMpO1xuICAgIH0sXG5cbiAgICBzZXRSZWFkeUZvclNhZmVNb2RlKCl7XG4gICAgICAgIHNvY2tldC5lbWl0KCdyZWFkeSBmb3Igc2FmZSBtb2RlJyk7XG4gICAgfSxcblxuICAgIHNldEluU2FmZU1vZGUoKXtcbiAgICAgICAgc29ja2V0LmVtaXQoJ3NldCBpbiBzYWZlIG1vZGUnKTtcbiAgICB9LFxuXG4gICAgLy8gbWVhbnQgZm9yIHRlc3RpbmcgLSBub3QgYWN0dWFsIGNsaWVudCB1c2VcbiAgICBzZXRPeHlnZW5MZXZlbCh1bml0cykge1xuICAgICAgICBzb2NrZXQuZW1pdCgnc2V0IG94eWdlbiByZW1haW5pbmcnLCB1bml0cyk7XG4gICAgfVxuXG59O1xuXG53aW5kb3cuX19hcGkgPSBhcGk7XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcbiIsIi8qIFNjcmlwdCB0byBib290c3RyYXAgdGhlIGFwcGxpY2F0aW9uICovXG5cbnZhciBNaXNzaW9uQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyksXG4gICAgTWVzc2FnZUFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9hY3Rpb25zL01lc3NhZ2VBY3Rpb25DcmVhdG9ycycpLFxuICAgIFNjaWVuY2VBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYWN0aW9ucy9TY2llbmNlQWN0aW9uQ3JlYXRvcnMnKSxcbiAgICBTY2llbmNlQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMvU2NpZW5jZVRlYW1Db25zdGFudHMnKSxcbiAgICBUaW1lckFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9hY3Rpb25zL1RpbWVyQWN0aW9uQ3JlYXRvcnMnKSxcbiAgICBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9hcHBkaXNwYXRjaGVyJyk7XG5cbkFwcERpc3BhdGNoZXIucmVnaXN0ZXIoKHBheWxvYWQpPT4ge1xuICAgIGNvbnNvbGUubG9nKCdERUJVRyBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoJywgcGF5bG9hZCk7XG59KTtcblxuZnVuY3Rpb24gcnVuKCkge1xuXG4gICAgLy8gU0VUVElOR1NcbiAgICBNaXNzaW9uQWN0aW9uQ3JlYXRvcnMuc3RhcnRNaXNzaW9uKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge3J1bn07IiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgUm91dGVyID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyk7XG5cbmNvbnN0IFJvdXRlSGFuZGxlciA9IFJvdXRlci5Sb3V0ZUhhbmRsZXI7XG5cbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLnJlYWN0Jyk7XG5cbmNvbnN0IE1lc3NhZ2VMaXN0ID0gcmVxdWlyZSgnLi9tZXNzYWdlLWxpc3QucmVhY3QnKTtcbmNvbnN0IE1pc3Npb25TdGF0ZVN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL21pc3Npb24tc3RhdGUtc3RvcmUnKTtcblxuY29uc3QgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgbWl4aW5zOiBbXSxcblxuICAgIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtpc01pc3Npb25SdW5uaW5nOiBNaXNzaW9uU3RhdGVTdG9yZS5pc01pc3Npb25SdW5uaW5nKCl9O1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIE1pc3Npb25TdGF0ZVN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX2hhbmRsZU1pc3Npb25TdGF0ZUNoYW5nZSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBcHAuY29tcG9uZW50RGlkTW91bnQnKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIE1pc3Npb25TdGF0ZVN0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuX2hhbmRsZU1pc3Npb25TdGF0ZUNoYW5nZSk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVNaXNzaW9uU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2lzTWlzc2lvblJ1bm5pbmc6IE1pc3Npb25TdGF0ZVN0b3JlLmlzTWlzc2lvblJ1bm5pbmcoKX0pO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbnRhaW5lcic+XG5cbiAgICAgICAgICAgICAgICA8SGVhZGVyLz5cblxuICAgICAgICAgICAgICAgIHsvKiB0aGlzIGlzIHRoZSBpbXBvcnRhbnQgcGFydCAqL31cbiAgICAgICAgICAgICAgICA8Um91dGVIYW5kbGVyIHsuLi50aGlzLnByb3BzfSB7Li4udGhpcy5zdGF0ZX0gLz5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgIDxmb290ZXIgaWQ9J21haW4tZm9vdGVyJz48L2Zvb3Rlcj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcDsiLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBIZWFydFJhdGVDaGFydCA9IHJlcXVpcmUoJy4vaGVhcnQtcmF0ZS1jaGFydC5yZWFjdCcpO1xuY29uc3QgQnJlYXRoUmF0ZUNoYXJ0ID0gcmVxdWlyZSgnLi9icmVhdGgtcmF0ZS1jaGFydC5yZWFjdCcpO1xuY29uc3QgVGltZXJQYW5lbCA9IHJlcXVpcmUoJy4vdGltZXItcGFuZWwucmVhY3QnKTtcbmNvbnN0IFRpbWVyQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL1RpbWVyQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IE94eWdlblN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL294eWdlbi1zdG9yZScpO1xuY29uc3QgQXN0cm9uYXV0Q29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL0FzdHJvVGVhbUNvbnN0YW50cycpO1xuY29uc3QgQXN0cm9uYXV0QWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL0FzdHJvVGVhbUFjdGlvbkNyZWF0b3JzJyk7XG5jb25zdCB7IHBhcnNlTnVtYmVyIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5UaW1lckFjdGlvbkNyZWF0b3JzLnNldFRpbWVyKEFzdHJvbmF1dENvbnN0YW50cy5SRVNQSVJBVElPTl9USU1FUiwgMTUpO1xuVGltZXJBY3Rpb25DcmVhdG9ycy5zZXRUaW1lcihBc3Ryb25hdXRDb25zdGFudHMuSEVBUlRfUkFURV9USU1FUiwgMTApO1xuXG4vLyBsYXp5IGxvYWQgZHVlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuZnVuY3Rpb24gbGF6eVJlcXVpcmUocGF0aCkge1xuICAgIGxldCB0bXAgPSBudWxsO1xuICAgIHJldHVybiAoKT0+IHtcbiAgICAgICAgaWYgKCF0bXApIHRtcCA9IHJlcXVpcmUocGF0aCk7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgfVxufVxuY29uc3QgZ2V0TWlzc2lvbkFDID0gbGF6eVJlcXVpcmUoJy4uL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG4vLyBmb3IgYnJvd3NlcmlmeSB0byB3b3JrIGl0IG5lZWRzIHRvIGZpbmQgdGhlc2UgbWFnaWMgc3RyaW5nc1xucmVxdWlyZSgnLi4vYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBzdGF0aWNzOiB7fSxcblxuICAgIHByb3BUeXBlczoge30sXG5cbiAgICBtaXhpbnM6IFtdLFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICB9LFxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgT3h5Z2VuU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIoKCkgPT4gdGhpcy5fdXBkYXRlU3RhdGUoKSk7XG4gICAgfSxcblxuICAgIF9pbmRpY2F0b3JDb2xvcigpe1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5veHlnZW5TdG9yZS5jb2xvckluZGljYXRvcjtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVN0YXRlKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuX2dldFN0YXRlKCkpXG4gICAgfSxcblxuICAgIF9nZXRTdGF0ZSgpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3h5Z2VuU3RvcmU6IE94eWdlblN0b3JlLmdldFN0YXRlKClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZUJyZWF0aFJhdGUoZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGVsID0gUmVhY3QuZmluZERPTU5vZGUodGhpcy5yZWZzWydicmVhdGgtcmF0ZSddKTtcbiAgICAgICAgQXN0cm9uYXV0QWN0aW9uQ3JlYXRvcnMuc2V0T3h5Z2VuQ29uc3VtcHRpb24ocGFyc2VOdW1iZXIoZWwudmFsdWUpKVxuICAgICAgICBnZXRNaXNzaW9uQUMoKS50YXNrQ29tcGxldGVkKCdhc3Ryb25hdXQnLCAnYnJlYXRoaW5nX2NhbGN1bGF0ZScpXG4gICAgfSxcblxuICAgIF9oYW5kbGVIZWFydFJhdGUoZSl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGVsID0gUmVhY3QuZmluZERPTU5vZGUodGhpcy5yZWZzWydoZWFydC1yYXRlLWlucHV0J10pO1xuICAgICAgICBBc3Ryb25hdXRBY3Rpb25DcmVhdG9ycy5oZWFydFJhdGVSZWFkKHBhcnNlTnVtYmVyKGVsLnZhbHVlKSk7XG4gICAgICAgIGdldE1pc3Npb25BQygpLnRhc2tDb21wbGV0ZWQoJ2FzdHJvbmF1dCcsICdoZWFydHJhdGVfY2FsY3VsYXRlJylcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuXG4gICAgICAgIHJldHVybiAoIDxkaXYgPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuXG4gICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgICAgICBMdWZ0c3RhdHVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNpcmNsZSBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXsgeyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJywgYmFja2dyb3VuZENvbG9yIDogdGhpcy5faW5kaWNhdG9yQ29sb3IoKSB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgPGxpPkZvcmJydWsgOiB7IHRoaXMuc3RhdGUub3h5Z2VuU3RvcmUuY29uc3VtcHRpb25QZXJNaW51dGUgfTwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDxsaT5HamVuc3TDpWVuZGUgb2tzeWdlbjogeyB0aGlzLnN0YXRlLm94eWdlblN0b3JlLnJlbWFpbmluZ30gZW5oZXRlcjwvbGk+XG4gICAgICAgICAgICAgICAgPC91bD5cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuXG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29sLW1kLTYnPlxuICAgICAgICAgICAgICAgICAgICA8aDI+UHVzdDwvaDI+XG4gICAgICAgICAgICAgICAgICAgIDxCcmVhdGhSYXRlQ2hhcnQgaGVpZ2h0PXsyNDB9Lz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb2wtbWQtNic+XG4gICAgICAgICAgICAgICAgICAgIDxoMj5IamVydGVzbGFnPC9oMj5cbiAgICAgICAgICAgICAgICAgICAgPEhlYXJ0UmF0ZUNoYXJ0IGhlaWdodD17MjQwfS8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8VGltZXJQYW5lbCB0aW1lcklkPXtBc3Ryb25hdXRDb25zdGFudHMuUkVTUElSQVRJT05fVElNRVJ9IGNsYXNzTmFtZT0nY29sLW1kLTYnLz5cbiAgICAgICAgICAgICAgICA8VGltZXJQYW5lbCB0aW1lcklkPXtBc3Ryb25hdXRDb25zdGFudHMuSEVBUlRfUkFURV9USU1FUn0gY2xhc3NOYW1lPSdjb2wtbWQtNicvPlxuXG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTZcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0IGRpc2FibGVkPXsgZmFsc2UgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMz5CZXJlZ25ldCBsdWZ0Zm9yYnJ1azwvaDM+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXt0aGlzLl9oYW5kbGVCcmVhdGhSYXRlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHJlZj0nYnJlYXRoLXJhdGUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXsxfT4xIGVuaGV0IHBlciBtaW51dHQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT17Mn0+MiBlbmhldGVyIHBlciBtaW51dHQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5Jz5FdmFsdWVyPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC14cy02XCI+XG4gICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldCBkaXNhYmxlZD17IGZhbHNlIH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDM+QmVyZWduZXQgaGplcnRlcnl0bWU8L2gzPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17dGhpcy5faGFuZGxlSGVhcnRSYXRlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcmVmPSdoZWFydC1yYXRlLWlucHV0JyB0eXBlPVwibnVtYmVyXCIgbWluPVwiNTBcIiBtYXg9XCIyMDBcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9J2J0biBidG4tcHJpbWFyeSc+RXZhbHVlcjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Rpdj4gKTtcbiAgICB9XG5cbn0pO1xuXG4iLCIvKipcbiAqIFRISVMgREVTSUdOIE9OTFkgU1VQUE9SVFMgT05FIENIQVJUIEFTIFRIRVkgKlNIQVJFKiBTVEFURVxuICogRm9yIGEgbm9uLXN0dXBpZCBkZXNpZ24sIGRvIHNvbWV0aGluZyBsaWtlIHRoZVxuICogaW1wbGVtZW50YXRpb24gaW4gdGhlIGFydGljbGUgYnkgTmljb2xhcyBIZXJ5OlxuICogaHR0cDovL25pY29sYXNoZXJ5LmNvbS9pbnRlZ3JhdGluZy1kM2pzLXZpc3VhbGl6YXRpb25zLWluLWEtcmVhY3QtYXBwXG4gKlxuICogQ2hhcnQgY29kZSBtb3JlIG9yIGxlc3MgY29waWVkIGZyb20gdGhlIHByb3RvdHlwZSBieSBMZW8gTWFydGluIFdlc3RieVxuICovXG5jb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBBbUNoYXJ0cyA9IHJlcXVpcmUoJ2FtY2hhcnRzJyk7XG52YXIgQnJlYXRoUmF0ZVN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL2JyZWF0aC1yYXRlLXN0b3JlJyk7XG5jb25zdCB7IHJhbmRvbUludCB9ID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLy9MdW5nIHZvbHVtZSBpbiBtbCBiZWZvcmUgYW5kIGFmdGVyIGluaGFsYXRpb25cbnZhciBsb3dWb2x1bWUgPSAyMDAwO1xudmFyIGhpZ2hWb2x1bWUgPSAzMDAwO1xuXG4vL01pbGxpdm9sdHMgZGlzcGxheWVkIG9uIHRoZSBZIGF4aXMgb2YgdGhlIEVDRyBncmFwaFxudmFyIGhpZ2hNViA9IDE7XG52YXIgbG93TVYgPSAwO1xuXG52YXIgYnJlYXRoUmF0ZVNhbXBsZXMgPSBbXTtcbnZhciBjaGFydDtcblxuLy9Db25maWd1cmUgdGhlIGNoYXJ0c1xuZnVuY3Rpb24gaW5pdENoYXJ0KGRvbUVsZW1lbnQpIHtcbiAgICBjaGFydCA9IG5ldyBBbUNoYXJ0cy5BbVNlcmlhbENoYXJ0KCk7XG5cbiAgICBjaGFydC5tYXJnaW5Ub3AgPSAyMDtcbiAgICBjaGFydC5tYXJnaW5SaWdodCA9IDEwO1xuICAgIGNoYXJ0LmF1dG9NYXJnaW5PZmZzZXQgPSA1O1xuICAgIGNoYXJ0LmRhdGFQcm92aWRlciA9IGJyZWF0aFJhdGVTYW1wbGVzO1xuICAgIGNoYXJ0LmNhdGVnb3J5RmllbGQgPSBcInRpbWVzdGFtcFwiO1xuXG4gICAgLy9YIEF4aXNcbiAgICB2YXIgY2F0ZWdvcnlBeGlzID0gY2hhcnQuY2F0ZWdvcnlBeGlzO1xuICAgIGNhdGVnb3J5QXhpcy5kYXNoTGVuZ3RoID0gMTtcbiAgICBjYXRlZ29yeUF4aXMuZ3JpZEFscGhhID0gMC4xMFxuICAgIGNhdGVnb3J5QXhpcy5heGlzQ29sb3IgPSBcIiNEQURBREFcIjtcbiAgICBjYXRlZ29yeUF4aXMuYXV0b0dyaWRDb3VudCA9IGZhbHNlO1xuICAgIGNhdGVnb3J5QXhpcy5ncmlkQ291bnQgPSAxNTtcbiAgICBjYXRlZ29yeUF4aXMuZm9yY2VTaG93RmllbGQgPSBcImZvcmNlU2hvd1wiO1xuICAgIC8vY2F0ZWdvcnlBeGlzLnRpdGxlID0gXCJTZWNvbmRzXCI7XG5cbiAgICAvL0hpZGUgZXZlcnkgbGFiZWwgdGhhdCBpcyBub3QgZXhwbGljaXRseSBzaG93blxuICAgIGNhdGVnb3J5QXhpcy5sYWJlbEZ1bmN0aW9uID0gZnVuY3Rpb24odmFsdWVUZXh0LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5mb3JjZVNob3cpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9ZIEF4aXNcbiAgICB2YXIgdmFsdWVBeGlzID0gbmV3IEFtQ2hhcnRzLlZhbHVlQXhpcygpO1xuICAgIHZhbHVlQXhpcy5heGlzQWxwaGEgPSAwLjI7XG4gICAgdmFsdWVBeGlzLmRhc2hMZW5ndGggPSAxO1xuICAgIHZhbHVlQXhpcy5taW5pbXVtID0gbG93Vm9sdW1lO1xuICAgIHZhbHVlQXhpcy5tYXhpbXVtID0gaGlnaFZvbHVtZSAqIDEuMTtcbiAgICB2YWx1ZUF4aXMudGl0bGUgPSBcIkx1bmdldm9sdW0gKG1sKVwiO1xuICAgIGNoYXJ0LmFkZFZhbHVlQXhpcyh2YWx1ZUF4aXMpO1xuXG4gICAgLy9MaW5lXG4gICAgdmFyIGdyYXBoID0gbmV3IEFtQ2hhcnRzLkFtR3JhcGgoKTtcbiAgICBncmFwaC50eXBlID0gXCJzbW9vdGhlZExpbmVcIjtcbiAgICBncmFwaC52YWx1ZUZpZWxkID0gXCJ2b2x1bWVcIjtcbiAgICBncmFwaC5saW5lVGhpY2tuZXNzID0gMS41O1xuICAgIGdyYXBoLmxpbmVDb2xvciA9IFwiI2I1MDMwZFwiO1xuICAgIGNoYXJ0LmFkZEdyYXBoKGdyYXBoKTtcblxuICAgIGNoYXJ0LndyaXRlKGRvbUVsZW1lbnQpO1xufVxuXG52YXIgYnJlYXRoUmF0ZUJ1ZmZlcjtcbnZhciBicmVhdGhSYXRlQnVmZmVySW5kZXg7XG52YXIgbXNVbnRpbE5leHRCcmVhdGhSYXRlQnVmZmVyRnJhbWU7XG5cbi8vRmlsbHMgdGhlIGJyZWF0aCByYXRlIGJ1ZmZlciB3aXRoIHNhbXBsZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHJhbmdlXG4vL1RoZSBicmVhdGggcmF0ZSBidWZmZXIgY29udGFpbnMgdHdpY2UgYXMgbWFueSBzYW1wbGVzIGFzIHRoZSBicmVhdGggcmF0ZSBjaGFydCBhbmQgaXMgdXNlZCB0byBhbmltYXRlIHRoZSBjaGFydFxuZnVuY3Rpb24gY3JlYXRlQnJlYXRoUmF0ZVNhbXBsZXMobWluLCBtYXgpIHtcbiAgICBicmVhdGhSYXRlQnVmZmVyID0gW107XG4gICAgYnJlYXRoUmF0ZUJ1ZmZlckluZGV4ID0gMDtcbiAgICBtc1VudGlsTmV4dEJyZWF0aFJhdGVCdWZmZXJGcmFtZSA9IDA7XG5cbiAgICB2YXIgYnJlYXRoc1Blck1pbnV0ZSA9IHJhbmRvbUludChtaW4sIG1heCk7XG4gICAgdmFyIG1zQmV0d2VlbkJyZWF0aHMgPSA2MCAqIDEwMDAgLyBicmVhdGhzUGVyTWludXRlO1xuICAgIHZhciBtc1VudGlsTmV4dEJyZWF0aCA9IG1zQmV0d2VlbkJyZWF0aHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAxMjA7IGkrKykge1xuICAgICAgICB2YXIgbHVuZ1ZvbHVtZTtcblxuICAgICAgICBpZiAobXNVbnRpbE5leHRCcmVhdGggPD0gMCkge1xuICAgICAgICAgICAgbHVuZ1ZvbHVtZSA9IGhpZ2hWb2x1bWU7XG4gICAgICAgICAgICBtc1VudGlsTmV4dEJyZWF0aCA9IG1zQmV0d2VlbkJyZWF0aHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsdW5nVm9sdW1lID0gbG93Vm9sdW1lICogMS4wNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVGhlIHJlc29sdXRpb24gb2YgdGhlIGNoYXJ0IGlzIHR3byBzYW1wbGVzIHBlciBzZWNvbmRcbiAgICAgICAgYnJlYXRoUmF0ZUJ1ZmZlci5wdXNoKHt0aW1lc3RhbXA6IGkgLyAyLCB2b2x1bWU6IGx1bmdWb2x1bWV9KTtcbiAgICAgICAgbXNVbnRpbE5leHRCcmVhdGggLT0gNTAwO1xuICAgIH1cbn1cblxudmFyIGNoYXJ0VXBkYXRlcjtcblxuLy9BbmltYXRlcyB0aGUgYnJlYXRoIHJhdGUgYW5kIGhlYXJ0IHJhdGUgY2hhcnRzXG5mdW5jdGlvbiBzdGFydEV2ZW50TG9vcCgpIHtcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgbXNTaW5jZUxhc3RVcGRhdGUgPSAwO1xuICAgIHZhciBtc1NpbmNlU3RhcnQgPSAwO1xuICAgIHZhciB1cGRhdGVGcmVxdWVuY3kgPSA0MDA7XG4gICAgc3RvcEV2ZW50TG9vcCgpO1xuXG4gICAgY2hhcnRVcGRhdGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIG1zU2luY2VMYXN0VXBkYXRlID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSAtIG1zU2luY2VTdGFydDtcbiAgICAgICAgbXNVbnRpbE5leHRCcmVhdGhSYXRlQnVmZmVyRnJhbWUgLT0gbXNTaW5jZUxhc3RVcGRhdGU7XG4gICAgICAgIG1zU2luY2VTdGFydCA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgaWYgKG1zVW50aWxOZXh0QnJlYXRoUmF0ZUJ1ZmZlckZyYW1lIDw9IDApIHtcbiAgICAgICAgICAgIHZhciBmcmFtZXNNaXNzZWQgPSBNYXRoLmZsb29yKChtc1VudGlsTmV4dEJyZWF0aFJhdGVCdWZmZXJGcmFtZSAqIC0xKSAvIDUwMCArIDEpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lc01pc3NlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnJlYXRoUmF0ZUJ1ZmZlckluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICBpZiAoYnJlYXRoUmF0ZUJ1ZmZlckluZGV4ID49IGJyZWF0aFJhdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWF0aFJhdGVCdWZmZXJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYXRoUmF0ZVNhbXBsZXMucHVzaChicmVhdGhSYXRlQnVmZmVyW2JyZWF0aFJhdGVCdWZmZXJJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgLy9XaGVuIHRoZSBjaGFydCBncm93cyB0byAzMCBzZWNvbmRzLCBzdGFydCBjdXR0aW5nIG9mZiB0aGUgb2xkZXN0IHNhbXBsZSB0byBnaXZlIHRoZSBjaGFydCBhIHNsaWRpbmcgZWZmZWN0XG4gICAgICAgICAgICAgICAgaWYgKGJyZWF0aFJhdGVTYW1wbGVzLmxlbmd0aCA+IDYwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWF0aFJhdGVTYW1wbGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtc1VudGlsTmV4dEJyZWF0aFJhdGVCdWZmZXJGcmFtZSA9IDI1MDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQWx3YXlzIHNob3cgZnJvbSAwIHRvIDMwIHNlY29uZHMgb24gdGhlIFggYXhpc1xuICAgICAgICBpZiAoYnJlYXRoUmF0ZVNhbXBsZXMubGVuZ3RoID49IDYwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyZWF0aFJhdGVTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnJlYXRoUmF0ZVNhbXBsZXNbaV0udGltZXN0YW1wID0gTWF0aC5mbG9vcihpIC8gKGJyZWF0aFJhdGVTYW1wbGVzLmxlbmd0aCAtIDEpICogMzApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9Pbmx5IHNob3cgZXZlcnkgNXRoIHRpbWVzdGFtcFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyZWF0aFJhdGVTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBicmVhdGhSYXRlU2FtcGxlc1tpXS5mb3JjZVNob3cgPSBicmVhdGhSYXRlU2FtcGxlc1tpXS50aW1lc3RhbXAgJSA1ID09IDAgJiYgKGkgPT0gMCB8fCBicmVhdGhSYXRlU2FtcGxlc1tpIC0gMV0udGltZXN0YW1wICUgNSAhPSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0LnZhbGlkYXRlRGF0YSgpO1xuICAgIH0sIHVwZGF0ZUZyZXF1ZW5jeSk7XG59XG5cbmZ1bmN0aW9uIHN0b3BFdmVudExvb3AoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChjaGFydFVwZGF0ZXIpO1xuICAgIGJyZWF0aFJhdGVTYW1wbGVzLmxlbmd0aCA9IDA7XG4gICAgY2hhcnQudmFsaWRhdGVEYXRhKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgc3RhdGljczoge30sXG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgaGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIHdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgfSxcblxuICAgIG1peGluczogW10sXG5cbiAgICBnZXRJbml0aWFsU3RhdGUoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENoYXJ0U3RhdGUoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB0aGlzLl91cGRhdGVDaGFydCgpO1xuICAgICAgICBCcmVhdGhSYXRlU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIoKCkgPT4gdGhpcy5fdXBkYXRlQ2hhcnQoKSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgZWwgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaW5pdENoYXJ0KGVsKTtcbiAgICAgICAgc3RhcnRFdmVudExvb3AoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNoYXJ0ICYmIGNoYXJ0LmNsZWFyKCk7XG4gICAgICAgIHN0b3BFdmVudExvb3AoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVW5tb3VudCgpIHtcbiAgICAgICAgY2hhcnQgPSBudWxsO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgfSxcblxuICAgIC8vIHRoaXMgY2hhcnQgaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgaXRzZWxmXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kc1xuICAgIF91cGRhdGVDaGFydCgpe1xuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuX2dldENoYXJ0U3RhdGUoKSk7XG4gICAgICAgIGNyZWF0ZUJyZWF0aFJhdGVTYW1wbGVzKHRoaXMuc3RhdGUubWluLCB0aGlzLnN0YXRlLm1heCk7XG4gICAgfSxcblxuICAgIF9nZXRDaGFydFN0YXRlKCl7XG4gICAgICAgIHJldHVybiBCcmVhdGhSYXRlU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB9LFxuXG4gICAgX29uQ2hhbmdlKCl7XG5cbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuXG4gICAgICAgIC8vIGlmIHlvdSBkb24ndCBzcGVjaWZ5IHdpZHRoIGl0IHdpbGwgbWF4IG91dCB0byAxMDAlICh3aGljaCBpcyBvaylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBzdHlsZT17e3dpZHRoOiB0aGlzLnByb3BzLndpZHRoICsgJ3B4JywgaGVpZ2h0IDogdGhpcy5wcm9wcy5oZWlnaHQrICdweCd9fVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgKTtcbiAgICB9XG5cbn0pO1xuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgT3h5Z2VuU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvb3h5Z2VuLXN0b3JlJyk7XG5jb25zdCB7IHBhcnNlTnVtYmVyIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgeyByYW5kb21JbnQgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8vIGxhenkgbG9hZCBkdWUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5mdW5jdGlvbiBsYXp5UmVxdWlyZShwYXRoKSB7XG4gICAgbGV0IHRtcCA9IG51bGw7XG4gICAgcmV0dXJuICgpPT4ge1xuICAgICAgICBpZiAoIXRtcCkgdG1wID0gcmVxdWlyZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICB9XG59XG5jb25zdCBnZXRNaXNzaW9uQUMgPSBsYXp5UmVxdWlyZSgnLi4vYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcbi8vIGZvciBicm93c2VyaWZ5IHRvIHdvcmsgaXQgbmVlZHMgdG8gZmluZCB0aGVzZSBtYWdpYyBzdHJpbmdzXG5yZXF1aXJlKCcuLi9hY3Rpb25zL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgbG93VGhyZXNob2xkID0gMzAsIG1lZGl1bVRocmVzaG9sZCA9IDcwO1xuXG52YXIgc2F0ZWxsaXRlcyA9IFtcbiAgICB7bmFtZTogJ1NhdGVsaXR0IDEnLCBmcmVxOiB7bWluOiAyLjgsIG1heDogMy40fSwgcmVjZXB0aW9uOiA5MCwgY29sb3I6ICdncmVlbid9LFxuICAgIHtuYW1lOiAnU2F0ZWxpdHQgMicsIGZyZXE6IHttaW46IDIuMSwgbWF4OiAyLjV9LCByZWNlcHRpb246IDMwLCBjb2xvcjogJ3JlZCd9LFxuICAgIHtuYW1lOiAnU2F0ZWxpdHQgMycsIGZyZXE6IHttaW46IDMuNiwgbWF4OiA0LjB9LCByZWNlcHRpb246IDYwLCBjb2xvcjogJ29yYW5nZSd9XG5dO1xuXG5mdW5jdGlvbiBjb2xvcihyZWNlcHRpb24pIHtcbiAgICBpZiAocmVjZXB0aW9uID4gbWVkaXVtVGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiAnZ3JlZW4nO1xuICAgIH1cbiAgICBpZiAocmVjZXB0aW9uID4gbG93VGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiAnb3JhbmdlJztcbiAgICB9XG4gICAgcmV0dXJuICdyZWQnO1xufVxuXG52YXIgaT0wO1xuZnVuY3Rpb24gbmV3VmFsdWVzKCl7XG4gICAgc2F0ZWxsaXRlc1soaSswKSUzXS5yZWNlcHRpb24gPSByYW5kb21JbnQoMjUsNjUpO1xuICAgIHNhdGVsbGl0ZXNbKGkrMSklM10ucmVjZXB0aW9uID0gcmFuZG9tSW50KDQ1LDg1KTtcbiAgICBzYXRlbGxpdGVzWyhpKzIpJTNdLnJlY2VwdGlvbiA9IHJhbmRvbUludCgyNSw2NSk7XG4gICAgaSsrO1xuXG4gICAgY2hhcnQudmFsaWRhdGVEYXRhKCk7XG59XG5cbnNldEludGVydmFsKG5ld1ZhbHVlcywgMTAwMCo2MCo0KTtcblxudmFyIGNoYXJ0O1xuZnVuY3Rpb24gaW5pdEdyYXBoKGRvbUVsZW1lbnQpIHtcbiAgICBjaGFydCA9IG5ldyBBbUNoYXJ0cy5BbVNlcmlhbENoYXJ0KCk7XG5cbiAgICBjaGFydC5kYXRhUHJvdmlkZXIgPSBzYXRlbGxpdGVzO1xuICAgIGNoYXJ0LmNhdGVnb3J5RmllbGQgPSBcIm5hbWVcIjtcblxuICAgIC8vWCBheGlzXG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IGNoYXJ0LmNhdGVnb3J5QXhpcztcbiAgICBjYXRlZ29yeUF4aXMuZ3JpZFBvc2l0aW9uID0gXCJzdGFydFwiO1xuXG4gICAgLy9ZIGF4aXNcbiAgICB2YXIgdmFsdWVBeGlzID0gbmV3IEFtQ2hhcnRzLlZhbHVlQXhpcygpO1xuICAgIHZhbHVlQXhpcy5heGlzQWxwaGEgPSAwO1xuICAgIHZhbHVlQXhpcy5taW5pbXVtID0gMDtcbiAgICB2YWx1ZUF4aXMubWF4aW11bSA9IDEwMDtcbiAgICB2YWx1ZUF4aXMudGl0bGUgPSBcIk1vdHRha1wiO1xuICAgIHZhbHVlQXhpcy5wb3NpdGlvbiA9IFwibGVmdFwiO1xuICAgIGNoYXJ0LmFkZFZhbHVlQXhpcyh2YWx1ZUF4aXMpO1xuXG4gICAgLy9MaW5lXG4gICAgdmFyIGdyYXBoID0gbmV3IEFtQ2hhcnRzLkFtR3JhcGgoKTtcbiAgICBncmFwaC52YWx1ZUZpZWxkID0gXCJyZWNlcHRpb25cIjtcbiAgICBncmFwaC5jb2xvckZpZWxkID0gXCJjb2xvclwiO1xuICAgIGdyYXBoLmxpbmVBbHBoYSA9IDAuMjtcbiAgICBncmFwaC5maWxsQWxwaGFzID0gMC44O1xuICAgIGdyYXBoLnR5cGUgPSBcImNvbHVtblwiO1xuICAgIGdyYXBoLnNob3dCYWxsb29uID0gZmFsc2U7XG4gICAgY2hhcnQuYWRkR3JhcGgoZ3JhcGgpO1xuXG4gICAgY2hhcnQud3JpdGUoZG9tRWxlbWVudCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59XG5cbmNvbnN0IFNhdGVsbGl0ZVJlY2VwdGlvbkNoYXJ0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgcHJvcFR5cGVzOiB7fSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCl7XG4gICAgICAgIHZhciBlbCA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBpbml0R3JhcGgoZWwpO1xuICAgIH0sXG5cbiAgICByZW5kZXIoKXtcbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX0gc3R5bGU9e3RoaXMucHJvcHMuc3R5bGV9Lz5cbiAgICB9XG5cbn0pO1xuXG5jb25zdCBTYXRlbGxpdGVUYWJsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBzYXRlbGxpdGVzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxuICAgIH0sXG5cblxuICAgIHJlbmRlcigpe1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IHsuLi50aGlzLnByb3BzfSA+XG5cbiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPXtcInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLXN0cmlwZWQgXCJ9PlxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5TYXRlbGl0dDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+RnJla3ZlbnNvbXLDpWRlPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cblxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2F0ZWxsaXRlcy5tYXAoKHNhdCwgaSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIga2V5PXtpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntzYXQubmFtZX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3NhdC5mcmVxLm1pbn0gLSB7c2F0LmZyZXEubWF4fTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj4pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHN0YXRpY3M6IHt9LFxuXG4gICAgcHJvcFR5cGVzOiB7fSxcblxuICAgIG1peGluczogW10sXG5cbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaG9zZW5TYXRlbGxpdGU6IHNhdGVsbGl0ZXNbMF1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgfSxcblxuICAgIF9nZXRTdGF0ZSgpe1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncm93Jz5cblxuICAgICAgICAgICAgICAgICAgICA8U2F0ZWxsaXRlVGFibGUgc2F0ZWxsaXRlcz17c2F0ZWxsaXRlc30gY2xhc3NOYW1lPSdjb2wtc20tNicvPlxuXG4gICAgICAgICAgICAgICAgICAgIDxTYXRlbGxpdGVSZWNlcHRpb25DaGFydCBzdHlsZT17eyBoZWlnaHQgOiAnMjUwcHgnfX0gY2xhc3NOYW1lPSdjb2wtc20tNicvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgIDxoMz5WZWxnIHNhdGVsaXR0IG9nIHRpbGjDuHJlbmRlIGZyZWt2ZW5zb21yw6VkZTwvaDM+XG4gICAgICAgICAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHNhdGVsbGl0ZXMubWFwKChzYXQpID0+ICA8b3B0aW9uIGtleT17c2F0Lm5hbWV9IHZhbHVlPXtzYXQubmFtZX0+e3NhdC5uYW1lfTwvb3B0aW9uPikgfVxuICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cblxuICAgICAgICAgICAgICAgICAgICA8aDQ+VmVsZyBmcmVrdmVuczo8L2g0PlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0nbnVtYmVyJyAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+ICk7XG5cbiAgICB9XG5cbn0pO1xuXG4iLCIvLyBuZWVkZWQgdG8gYXZvaWQgY29tcGlsYXRpb24gZXJyb3JcbmNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2NpZW5jZV9pbnRybzogPGRpdj5cbiAgICAgICAgPHA+XG4gICAgICAgICAgICBEZXJlIHNrYWwgb3ZlcnbDpWtlIHN0csOlbGluZ3NuaXbDpWV0IGFzdHJvbmF0dWVuIHV0c2V0dGVzIGZvci5cbiAgICAgICAgICAgIERlcmUgbcOlIGRhIHBhc3NlIHDDpSBhdCBhc3Ryb25hdXRlbiBpa2tlIGJsaXIgdXRzYXR0XG4gICAgICAgICAgICBmb3Igc3Ryw6VsaW5nc25pdsOlZXIgc29tIGVyIHNrYWRlbGlnLlxuICAgICAgICA8L3A+XG5cbiAgICAgICAgPHA+VmVkIGhqZWxwIGF2IGluc3RydW1lbnRlbmUgc29tIGVyIHRpbGdqZW5nZWxpZyBtw6UgZGVyZSBqZXZubGlnXG4gICAgICAgICAgICB0YSBwcsO4dmVyIG9nIHJlZ25lIHV0IHZlcmRpZW5lIGZvciBnamVubm9tc25pdHRsaWcgb2cgdG90YWx0XG4gICAgICAgICAgICBzdHLDpWxpbmdzbml2w6UuIEZpbm5lciBkZXJlIHV0IGF0IG5pdsOlZW5lIGVyIGJsaXR0IGZhcmxpZ1xuICAgICAgICAgICAgaMO4eWUgPGVtPm3DpTwvZW0+IGRlcmUgc2kgZnJhIHRpbCBvcHBkcmFnc2xlZGVyZW4gc8OlIHZpIGthblxuICAgICAgICAgICAgZsOlIHV0IGFzdHJvbmF1dGVuIVxuICAgICAgICA8L3A+XG5cblxuICAgICAgICA8cD5cbiAgICAgICAgICAgIEVyIG9wcGRyYWdldCBmb3JzdMOldHQ/XG4gICAgICAgIDwvcD5cbiAgICA8L2Rpdj4sXG5cbiAgICBhc3Ryb25hdXRfaW50cm86IDxkaXY+XG4gICAgICAgIDxwPlxuICAgICAgICAgICAgRGVyZXMgam9iYiBlciDDpSBzaWtyZSBhdCBkZXQgZXIgbm9rIG9rc3lnZW4gZm9yIMOlIGdqZW5ub21mw7hyZSBvcHBkcmFnZXQuIEhlciBlciBkZXQgdmlrdGlnIMOlIGpldm5saWdcbiAgICAgICAgICAgIHNqZWtrZSBodm9yIGZvcnQgYXN0cm9uYXV0IFN0ZWlnZW4gcHVzdGVyIG9nIGh2b3IgZm9ydCBoamVydGV0IGhlbm5lcyBzbMOlci5cbiAgICAgICAgPC9wPlxuXG4gICAgICAgIDxwPkZpbm5lciBkZXJlIHV0IGF0IGFzdHJvbmF1dCBTdGVpZ2VuIGlra2UgdmlsIGhhIG5vayBsdWZ0IHRpbFxuICAgICAgICAgICAgw6UgZ2plbm5vbWbDuHJlIG9wcGRyYWdldCA8ZW0+bcOlPC9lbT4gZGVyZSBzaSBmcmEgdGlsXG4gICAgICAgICAgICBvcHBkcmFnc2xlZGVyZW4gc8OlIHZpIGthbiBhdmJyeXRlIGkgdGlkZS5cbiAgICAgICAgPC9wPlxuICAgIDwvZGl2PixcblxuICAgIGNvbW11bmljYXRpb25faW50cm86IDxkaXY+XG4gICAgICAgIDxwPkRlcmVzIG3DpWwgZXIgw6UgaG9sZGUga29tbXVuaWthc2pvbmVuIG9wcGUsIG9nIGtvbW11bmlzZXJlIG1lZCBvcHBkcmFnc2tvb3JkaW5hdG9yIG9nIGFzdHJvbmF1dGVuLiBPbVxuICAgICAgICAgICAgbsO4ZHZlbmRpZyBtw6UgZGVyZSBrYW5za2plIGJ5dHRlIHRpbCBlbiBhbm5lbiBrb21tdW5pa2Fzam9uc3NhdGVsaXR0LlxuICAgICAgICA8L3A+XG5cbiAgICAgICAgPHA+RGVyZSBza2FsIG9nc8OlIGluZm9ybWVyZSBhc3Ryb25hdXRlbiBvbSBldmVudHVlbGxlIGJlc2tqZWRlciBmcmEgQW5kYcO4eWEgU3BhY2UgQ2VudGVyIChBU0MpLCBvZ1xuICAgICAgICAgICAgbGlrZWxlZGVzIGluZm9ybWVyZSBBU0Mgb20gaGVuZGVsc2VyIGVsbGVyIGJlc2tqZWRlciBmcmEgYXN0cm9uYXV0ZW4uPC9wPlxuXG4gICAgPC9kaXY+LFxuXG4gICAgc2VjdXJpdHlfaW50cm86IDxkaXY+XG4gICAgICAgIDxwPlxuICAgICAgICAgICAgRGVyZXMgaG92ZWRvcHBnYXZlIGVyIMOlIGlubmhlbnRlIGluZm9ybWFzam9uIGZyYSBkZSBmb3Jza2plbGxpZ2UgZ3J1cHBlbmUgb2cgYmVzdGVtbWUgZGVyZSBmb3IgaHZhXG4gICAgICAgICAgICBzb20gc2thbCBnasO4cmVzLiBIZXIgbcOlIGRlcmUgc2FtYXJiZWlkZSBnb2R0IG1lZCBvcHBkcmFnc2tvb3JkaW5hdG9yZW4gKDxlbT5taXNzaW9uIGNvbW1hbmRlcjwvZW0+KSFcbiAgICAgICAgPC9wPlxuXG4gICAgICAgIDxwPlxuICAgICAgICAgICAgRGVyZSBtw6Ugb2dzw6UgaG9sZGUgZXQgw7h5ZSBww6UgaW5kaWthdG9yZW4gc29tIHNpZXIgb20gZGV0IGVyIG5vayBsdWZ0IHRpbCDDpSBnamVubm9tZsO4cmUgb3BwZHJhZ2V0LCBzYW10XG4gICAgICAgICAgICBzamVra2Ugb20ga2FyYm9uZGlva3NpZHNrcnViYmVyZW4gbcOlIHNraWZ0ZXMgc2xpayBhdCBhc3Ryb25hdXRlbiBpa2tlIGt2ZWxlcy5cbiAgICAgICAgPC9wPlxuXG4gICAgICAgIDxwPlxuICAgICAgICAgICAgRGVyZXMgbcOlIG9nc8OlIHNqZWtrZSBhdCBrb21tdW5pa2Fzam9uc3N0YXR1c2VuIG9nIGRhdGFrdmFsaXRldGVuIGVyIGdvZCBuw6VyIHJlcGFyYXNqb25lbiBlciB1dGbDuHJ0LlxuICAgICAgICA8L3A+XG4gICAgPC9kaXY+XG5cblxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZW5kZXIoKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEVU1NWV9SRU5ERVIuIFRoaXMgcmVhY3QgY29tcG9uZW50IGlzIG5vdCBmb3IgcHJlc2VudGF0aW9uYWwgcHVycG9zZXMnKTtcbiAgICB9XG59O1xuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgcGxheWVyO1xuZnVuY3Rpb24gb25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkoKSB7XG4gICAgY29uc29sZS5sb2coJ29uWW91VHViZUlmcmFtZUFQSVJlYWR5Jyk7XG4gICAgcGxheWVyID0gbmV3IFlULlBsYXllcigncGxheWVyJywge1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgICdvblJlYWR5Jzogb25QbGF5ZXJSZWFkeVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBsYXlWaWRlbygpe1xuICAgIHBsYXllci5zZWVrVG8oOTYpO1xuICAgIHBsYXllci5wbGF5VmlkZW8oKTtcblxuICAgIC8vIHN0b3AgdmlkZW8gYWZ0ZXIgdGVuIHNlY29uZHNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcGxheWVyLnN0b3BWaWRlbyhwbGF5ZXIpXG4gICAgICAgIHBsYXlWaWRlbygpO1xuICAgIH0sMTBFMyk7XG59XG5cbmZ1bmN0aW9uIG9uUGxheWVyUmVhZHkoZXZlbnQpIHtcbiAgICAvL2V2ZW50LnRhcmdldC5tdXRlKCk7XG4gICAgcGxheWVyLm11dGUoKTtcbiAgICBwbGF5VmlkZW8oKTtcbn1cblxuXG53aW5kb3cub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkgPSBvbllvdVR1YmVJZnJhbWVBUElSZWFkeTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICAvKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL2lmcmFtZV9hcGlfcmVmZXJlbmNlI0dldHRpbmdfU3RhcnRlZCAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zb2xlLmxvZygnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgICAgICAgdmFyIHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgICAgIHRhZy5zcmMgPSBcImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2lmcmFtZV9hcGlcIjtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0YWcpO1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciByaWNrUm9sbGVkID0gJ2h0dHA6Ly93d3cueW91dHViZS5jb20vZW1iZWQvb0hnNVNKWVJIQTA/YXV0b3BsYXk9MSc7XG4gICAgICAgIHZhciBvcmlnaW4gPSBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0XG4gICAgICAgIHZhciBzb2xhclN0b3JtID0gJ2h0dHA6Ly93d3cueW91dHViZS5jb20vZW1iZWQvRFU0aHBzaXN0RGs/JnN0YXJ0PTk2JmVuYWJsZWpzYXBpPTEmb3JpZ2luPScgKyBvcmlnaW47XG4gICAgICAgIHZhciB2aWRlbyA9IHNvbGFyU3Rvcm07XG5cbiAgICAgICAgLy9yZXR1cm4gPGRpdiAvPlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICA8aWZyYW1lIGlkPSdwbGF5ZXInXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IHBvc2l0aW9uOidhYnNvbHV0ZScsIHRvcDogMCwgcmlnaHQ6IDAsIHdpZHRoOlwiMTAwJVwiLCBoZWlnaHQ6XCIxMDAlXCJ9fVxuICAgICAgICAgICAgICAgICAgICBzcmM9e3ZpZGVvfVxuICAgICAgICAgICAgICAgICAgICBmcmFtZUJvcmRlcj1cIjBcIiBhbGxvd0Z1bGxTY3JlZW4gLz5cbiAgICAgICAgKTtcbiAgICB9XG5cbn0pOyIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xuY29uc3QgTGluayA9IFJvdXRlci5MaW5rO1xuXG52YXIgSGVhZGVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncm93Jz5cblxuICAgICAgICAgICAgICAgICAgICA8aGVhZGVyIGlkPSduYXJvbS1oZWFkZXInID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzc05hbWUgPSAnbmFyb20tbG9nby1pbWcnICBzcmM9Jy9pbWFnZXMvbG9nby5wbmcnIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTkFST00gZS1NaXNzaW9uIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvaGVhZGVyPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdiBpZD0nbWFpbi1oZWFkZXInIGNsYXNzTmFtZT0ncm93JyA+XG4gICAgICAgICAgICAgICAgICAgIDxMaW5rIHRvPScvJyA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aGVhZGVyID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDEgY2xhc3NOYW1lID0gJyc+VW5kZXIgZW4gc29sc3Rvcm08L2gxPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9oZWFkZXI+XG4gICAgICAgICAgICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhZGVyOyIsIi8qKlxuICogVEhJUyBERVNJR04gT05MWSBTVVBQT1JUUyBPTkUgQ0hBUlQgQVMgVEhFWSAqU0hBUkUqIFNUQVRFXG4gKiBGb3IgYSBub24tc3R1cGlkIGRlc2lnbiwgZG8gc29tZXRoaW5nIGxpa2UgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgYXJ0aWNsZSBieSBOaWNvbGFzIEhlcnk6XG4gKiBodHRwOi8vbmljb2xhc2hlcnkuY29tL2ludGVncmF0aW5nLWQzanMtdmlzdWFsaXphdGlvbnMtaW4tYS1yZWFjdC1hcHBcbiAqXG4gKiBDaGFydCBjb2RlIG1vcmUgb3IgbGVzcyBjb3BpZWQgZnJvbSB0aGUgcHJvdG90eXBlIGJ5IExlbyBNYXJ0aW4gV2VzdGJ5XG4gKi9cbmNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IEFtQ2hhcnRzID0gcmVxdWlyZSgnYW1jaGFydHMnKTtcbmNvbnN0IHsgcmFuZG9tSW50IH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgSGVhcnRTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9oZWFydC1yYXRlLXN0b3JlJyk7XG5cbnZhciBjaGFydDtcbnZhciBoZWFydFJhdGVTYW1wbGVzID0gW107XG5cbnZhciBoZWFydFJhdGVCdWZmZXI7XG52YXIgaGVhcnRSYXRlQnVmZmVySW5kZXg7XG52YXIgbXNVbnRpbE5leHRIZWFydFJhdGVCdWZmZXJGcmFtZTtcblxuLy9NaWxsaXZvbHRzIGRpc3BsYXllZCBvbiB0aGUgWSBheGlzIG9mIHRoZSBFQ0cgZ3JhcGhcbnZhciBoaWdoTVYgPSAxO1xudmFyIGxvd01WID0gMDtcblxudmFyIGNoYXJ0VXBkYXRlcjtcblxuZnVuY3Rpb24gaW5pdENoYXJ0KGRvbUVsZW1lbnQpIHtcblxuICAgIGNoYXJ0ID0gbmV3IEFtQ2hhcnRzLkFtU2VyaWFsQ2hhcnQoKTtcblxuICAgIGNoYXJ0Lm1hcmdpblRvcCA9IDIwO1xuICAgIGNoYXJ0Lm1hcmdpblJpZ2h0ID0gMTA7XG4gICAgY2hhcnQuYXV0b01hcmdpbk9mZnNldCA9IDU7XG4gICAgY2hhcnQuZGF0YVByb3ZpZGVyID0gaGVhcnRSYXRlU2FtcGxlcztcbiAgICBjaGFydC5jYXRlZ29yeUZpZWxkID0gXCJ0aW1lc3RhbXBcIjtcblxuICAgIC8vWCBBeGlzXG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IGNoYXJ0LmNhdGVnb3J5QXhpcztcbiAgICBjYXRlZ29yeUF4aXMuZGFzaExlbmd0aCA9IDE7XG4gICAgY2F0ZWdvcnlBeGlzLmdyaWRBbHBoYSA9IDAuMTA7XG4gICAgY2F0ZWdvcnlBeGlzLmF4aXNDb2xvciA9IFwiI0RBREFEQVwiO1xuICAgIGNhdGVnb3J5QXhpcy5mb3JjZVNob3dGaWVsZCA9IFwiZm9yY2VTaG93XCI7XG4gICAgLy9jYXRlZ29yeUF4aXMudGl0bGUgPSBcIlNlY29uZHNcIjtcblxuICAgIC8vSGlkZSBldmVyeSBsYWJlbCB0aGF0IGlzIG5vdCBleHBsaWNpdGx5IHNob3duXG4gICAgY2F0ZWdvcnlBeGlzLmxhYmVsRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWVUZXh0LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5mb3JjZVNob3cpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9ZIEF4aXNcbiAgICB2YXIgdmFsdWVBeGlzID0gbmV3IEFtQ2hhcnRzLlZhbHVlQXhpcygpO1xuICAgIHZhbHVlQXhpcy5heGlzQWxwaGEgPSAwLjI7XG4gICAgdmFsdWVBeGlzLmRhc2hMZW5ndGggPSAxO1xuICAgIHZhbHVlQXhpcy5taW5pbXVtID0gbG93TVY7XG4gICAgdmFsdWVBeGlzLm1heGltdW0gPSBoaWdoTVYgKiAxLjE7XG4gICAgdmFsdWVBeGlzLnRpdGxlID0gXCJtVlwiO1xuICAgIGNoYXJ0LmFkZFZhbHVlQXhpcyh2YWx1ZUF4aXMpO1xuXG4gICAgLy9MaW5lXG4gICAgdmFyIGdyYXBoID0gbmV3IEFtQ2hhcnRzLkFtR3JhcGgoKTtcblxuICAgIGdyYXBoLnZhbHVlRmllbGQgPSBcIm1WXCI7XG4gICAgZ3JhcGgudHlwZSA9IFwic21vb3RoZWRMaW5lXCI7XG4gICAgZ3JhcGgubGluZVRoaWNrbmVzcyA9IDE7XG4gICAgZ3JhcGgubGluZUNvbG9yID0gXCIjYjUwMzBkXCI7XG4gICAgY2hhcnQuYWRkR3JhcGgoZ3JhcGgpO1xuXG4gICAgY2hhcnQud3JpdGUoZG9tRWxlbWVudCk7XG59XG5cbi8vRmlsbHMgdGhlIGhlYXJ0IHJhdGUgYnVmZmVyIHdpdGggc2FtcGxlcyBmcm9tIHRoZSBzcGVjaWZpZWQgcmFuZ2Vcbi8vVGhlIGhlYXJ0IHJhdGUgYnVmZmVyIGNvbnRhaW5zIHR3aWNlIGFzIG1hbnkgc2FtcGxlcyBhcyB0aGUgaGVhcnQgcmF0ZSBjaGFydCBhbmQgaXMgdXNlZCB0byBhbmltYXRlIHRoZSBjaGFydFxuZnVuY3Rpb24gY3JlYXRlSGVhcnRSYXRlU2FtcGxlcyhtaW4sIG1heCkge1xuICAgIGhlYXJ0UmF0ZUJ1ZmZlciA9IFtdO1xuICAgIGhlYXJ0UmF0ZUJ1ZmZlckluZGV4ID0gMDtcbiAgICBtc1VudGlsTmV4dEhlYXJ0UmF0ZUJ1ZmZlckZyYW1lID0gMDtcblxuICAgIHZhciBiZWF0c1Blck1pbnV0ZSA9IHJhbmRvbUludChtaW4sIG1heCk7XG4gICAgdmFyIG1zQmV0d2VlbkJlYXRzID0gNjAgKiAxMDAwIC8gYmVhdHNQZXJNaW51dGU7XG4gICAgdmFyIG1zVW50aWxOZXh0QmVhdCA9IG1zQmV0d2VlbkJlYXRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMjAwOyBpKyspIHtcbiAgICAgICAgdmFyIG1WO1xuXG4gICAgICAgIGlmIChtc1VudGlsTmV4dEJlYXQgPD0gMCkge1xuICAgICAgICAgICAgbVYgPSBoaWdoTVY7XG4gICAgICAgICAgICBtc1VudGlsTmV4dEJlYXQgPSBtc0JldHdlZW5CZWF0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1WID0gTWF0aC5yYW5kb20oKSAqIDAuMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVGhlIHJlc29sdXRpb24gb2YgdGhlIGNoYXJ0IGlzIHRlbiBzYW1wbGVzIHBlciBzZWNvbmRcbiAgICAgICAgaGVhcnRSYXRlQnVmZmVyLnB1c2goe3RpbWVzdGFtcDogaSAvIDEwLCBtVjogbVZ9KTtcbiAgICAgICAgbXNVbnRpbE5leHRCZWF0IC09IDUwO1xuICAgIH1cbn1cblxuLy9BbmltYXRlcyB0aGUgIGhlYXJ0IHJhdGUgY2hhcnRzXG5mdW5jdGlvbiBzdGFydEV2ZW50TG9vcCgpIHtcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgbXNTaW5jZUxhc3RVcGRhdGUgPSAwO1xuICAgIHZhciBtc1NpbmNlU3RhcnQgPSAwO1xuICAgIHZhciB1cGRhdGVGcmVxdWVuY3kgPSA0MDA7XG4gICAgc3RvcEV2ZW50TG9vcCgpO1xuXG4gICAgY2hhcnRVcGRhdGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBtc1NpbmNlTGFzdFVwZGF0ZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWUgLSBtc1NpbmNlU3RhcnQ7XG4gICAgICAgIG1zVW50aWxOZXh0SGVhcnRSYXRlQnVmZmVyRnJhbWUgLT0gbXNTaW5jZUxhc3RVcGRhdGU7XG4gICAgICAgIG1zU2luY2VTdGFydCA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgaWYgKG1zVW50aWxOZXh0SGVhcnRSYXRlQnVmZmVyRnJhbWUgPD0gMCkge1xuICAgICAgICAgICAgdmFyIGZyYW1lc01pc3NlZCA9IE1hdGguZmxvb3IoKG1zVW50aWxOZXh0SGVhcnRSYXRlQnVmZmVyRnJhbWUgKiAtMSkgLyAxMDAgKyAxKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXNNaXNzZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGhlYXJ0UmF0ZUJ1ZmZlckluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGVhcnRSYXRlQnVmZmVySW5kZXggPj0gaGVhcnRSYXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFydFJhdGVCdWZmZXJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGVhcnRSYXRlU2FtcGxlcy5wdXNoKGhlYXJ0UmF0ZUJ1ZmZlcltoZWFydFJhdGVCdWZmZXJJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgLy9XaGVuIHRoZSBjaGFydCBncm93cyB0byAxMCBzZWNvbmRzLCBzdGFydCBjdXR0aW5nIG9mZiB0aGUgb2xkZXN0IHNhbXBsZSB0byBnaXZlIHRoZSBjaGFydCBhIHNsaWRpbmcgZWZmZWN0XG4gICAgICAgICAgICAgICAgaWYgKGhlYXJ0UmF0ZVNhbXBsZXMubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYXJ0UmF0ZVNhbXBsZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1zVW50aWxOZXh0SGVhcnRSYXRlQnVmZmVyRnJhbWUgPSAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICAvL0Fsd2F5cyBzaG93IGZyb20gMCB0byAxMCBzZWNvbmRzIG9uIHRoZSBYIGF4aXNcbiAgICAgICAgaWYgKGhlYXJ0UmF0ZVNhbXBsZXMubGVuZ3RoID49IDEwMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFydFJhdGVTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGVhcnRSYXRlU2FtcGxlc1tpXS50aW1lc3RhbXAgPSBNYXRoLmZsb29yKGkgLyAoaGVhcnRSYXRlU2FtcGxlcy5sZW5ndGggLSAxKSAqIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vT25seSBzaG93IGV2ZXJ5IDV0aCB0aW1lc3RhbXBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFydFJhdGVTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBoZWFydFJhdGVTYW1wbGVzW2ldLmZvcmNlU2hvdyA9IGhlYXJ0UmF0ZVNhbXBsZXNbaV0udGltZXN0YW1wICUgNSA9PSAwICYmIChpID09IDAgfHwgaGVhcnRSYXRlU2FtcGxlc1tpIC0gMV0udGltZXN0YW1wICUgNSAhPSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0LnZhbGlkYXRlRGF0YSgpO1xuICAgIH0sIHVwZGF0ZUZyZXF1ZW5jeSk7XG59XG5cbmZ1bmN0aW9uIHN0b3BFdmVudExvb3AoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChjaGFydFVwZGF0ZXIpO1xuICAgIGhlYXJ0UmF0ZVNhbXBsZXMubGVuZ3RoID0gMDtcbiAgICBjaGFydC52YWxpZGF0ZURhdGEoKTtcbn1cblxuY29uc3QgSGVhcnRSYXRlQ2hhcnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBzdGF0aWNzOiB7fSxcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBoZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgd2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXSxcblxuICAgIGdldEluaXRpYWxTdGF0ZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2hhcnRTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoYXJ0KCk7XG4gICAgICAgIEhlYXJ0U3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIoKCk9PiB0aGlzLl91cGRhdGVDaGFydCgpKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBlbCA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBpbml0Q2hhcnQoZWwpO1xuICAgICAgICBzdGFydEV2ZW50TG9vcCgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgY2hhcnQgJiYgY2hhcnQuY2xlYXIoKTtcbiAgICAgICAgc3RvcEV2ZW50TG9vcCgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVbm1vdW50KCkge1xuICAgICAgICBjaGFydCA9IG51bGw7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB9LFxuXG4gICAgLy8gdGhpcyBjaGFydCBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBpdHNlbGZcbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgX3VwZGF0ZUNoYXJ0KCl7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fZ2V0Q2hhcnRTdGF0ZSgpKTtcbiAgICAgICAgY3JlYXRlSGVhcnRSYXRlU2FtcGxlcyh0aGlzLnN0YXRlLm1pbiwgdGhpcy5zdGF0ZS5tYXgpO1xuICAgIH0sXG5cbiAgICBfZ2V0Q2hhcnRTdGF0ZSgpe1xuICAgICAgICByZXR1cm4gSGVhcnRTdG9yZS5nZXRTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfb25DaGFuZ2UoKXtcblxuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgLy8gaWYgeW91IGRvbid0IHNwZWNpZnkgd2lkdGggaXQgd2lsbCBtYXggb3V0IHRvIDEwMCUgKHdoaWNoIGlzIG9rKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7d2lkdGg6IHRoaXMucHJvcHMud2lkdGggKyAncHgnLCBoZWlnaHQgOiB0aGlzLnByb3BzLmhlaWdodCsgJ3B4J319XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICApO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhcnRSYXRlQ2hhcnQ7XG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbmNvbnN0IExpbmsgPSBSb3V0ZXIuTGluaztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgcmVuZGVyICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGgzPlZlbGcgbGFnPC9oMz5cbiAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgIDxsaT48TGluayB0bz1cInRlYW0tcm9vdFwiIHBhcmFtcz17eyB0ZWFtSWQgOiAnc2NpZW5jZSd9fT5Gb3Jza25pbmdzZ3J1cHBhPC9MaW5rPjwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDxsaT48TGluayB0bz1cInRlYW0tcm9vdFwiIHBhcmFtcz17eyB0ZWFtSWQgOiAnYXN0cm9uYXV0J319PkFzdHJvbmF1dGdydXBwYTwvTGluaz48L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+PExpbmsgdG89XCJ0ZWFtLXJvb3RcIiBwYXJhbXM9e3sgdGVhbUlkIDogJ3NlY3VyaXR5J319PlNpa2tlcmhldHNncnVwcGE8L0xpbms+PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPGxpPjxMaW5rIHRvPVwidGVhbS1yb290XCIgcGFyYW1zPXt7IHRlYW1JZCA6ICdjb21tdW5pY2F0aW9uJ319PktvbW11bmlrYXNqb25zZ3J1cHBhPC9MaW5rPjwvbGk+XG4gICAgICAgICAgICAgICAgPC91bD5cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cblxuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgZGlhbG9ncyA9IHJlcXVpcmUoJy4vZGlhbG9ncy5yZWFjdCcpO1xuY29uc3QgeyBjbGVhblJvb3RQYXRoIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBSb3V0ZVN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL3JvdXRlLXN0b3JlJyk7XG52YXIgSW50cm9TdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9pbnRyb2R1Y3Rpb24tc3RvcmUnKTtcblxuIGNvbnN0IEludHJvZHVjdGlvblNjcmVlbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIG1peGluczogW10sXG5cbiAgICAgY29udGV4dFR5cGVzOiB7XG4gICAgICAgICByb3V0ZXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIHdpbGxUcmFuc2l0aW9uVG8odHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdmFyIHRlYW1JZCA9IGNsZWFuUm9vdFBhdGgodHJhbnNpdGlvbi5wYXRoKTtcblxuICAgICAgICAgICAgaWYgKEludHJvU3RvcmUuaXNJbnRyb2R1Y3Rpb25SZWFkKHRlYW1JZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW50cm9kdWN0aW9uIHJlYWQgZWFybGllcicpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24ucmVkaXJlY3QoJ3RlYW0tdGFzaycsIHt0YXNrSWQ6ICdzYW1wbGUnLCB0ZWFtSWQgOiB0ZWFtSWR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIGNvbnN0IE1pc3Npb25BY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG5cbiAgICAgICAgdmFyIHRlYW1JZCA9IFJvdXRlU3RvcmUuZ2V0VGVhbUlkKCk7XG4gICAgICAgIE1pc3Npb25BY3Rpb25DcmVhdG9ycy5pbnRyb1dhc1JlYWQodGVhbUlkKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJvdXRlci50cmFuc2l0aW9uVG8oJ3RlYW0tdGFzaycsIHt0YXNrSWQgOiAnc2FtcGxlJywgdGVhbUlkIDogdGVhbUlkIH0pXG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHRlYW1JZD0gUm91dGVTdG9yZS5nZXRUZWFtSWQoKTtcbiAgICAgICAgdmFyIGludHJvVGV4dCA9IGRpYWxvZ3NbdGVhbUlkICsgJ19pbnRybyddIHx8IDxwPk1hbmdsZXIgb3BwZHJhZzwvcD47XG5cbiAgICAgICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZSA9ICdyb3cganVtYm90cm9uIGludHJvc2NyZWVuJz5cbiAgICAgICAgICAgIDxoMj5Nw6VsIGZvciBvcHBkcmFnZXQ8L2gyPlxuXG4gICAgICAgICAgICB7IGludHJvVGV4dCB9XG5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSAnYnRuIGJ0bi1wcmltYXJ5IGJ0bi1sZydcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9oYW5kbGVDbGlja31cbiAgICAgICAgICAgID5KZWcgZm9yc3TDpXI8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+KVxuXG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50cm9kdWN0aW9uU2NyZWVuO1xuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgYWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTWVzc2FnZUFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBMaXN0TWVzc2FnZVdyYXBwZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgbGV2ZWw6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgdGV4dDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgICBpZDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkXG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGJ1dHRvbjtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXNtaXNzYWJsZSkge1xuICAgICAgICAgICAgYnV0dG9uID0gKFxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNsb3NlXCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gYWN0aW9ucy5yZW1vdmVNZXNzYWdlKHRoaXMucHJvcHMuaWQpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+w5c8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9eyAnYWxlcnQgYWxlcnQtZGlzbWlzc2libGUgYWxlcnQtJyArIHRoaXMucHJvcHMubGV2ZWx9ID5cbiAgICAgICAgICAgIHsgYnV0dG9uIH1cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLnRleHR9XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG52YXIgTWVzc2FnZUxpc3QgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBoaWRkZW4gPSB0aGlzLnByb3BzLm1lc3NhZ2VzLmxlbmd0aCA9PT0gMCA/ICdoaWRlJyA6ICcnO1xuICAgICAgICB2YXIgY2xhc3NlcyA9ICh0aGlzLnByb3BzLmNsYXNzTmFtZSB8fCAnJykgKyAnIG1lc3NhZ2Vib3ggJyArIGhpZGRlbjtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHVsIGNsYXNzTmFtZSA9IHsgY2xhc3NlcyB9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubWVzc2FnZXMubWFwKChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICg8TGlzdE1lc3NhZ2VXcmFwcGVyIGtleT17bXNnLmlkfSB7Li4ubXNnfSAvPik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlTGlzdDtcbiIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IExpbmsgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKS5MaW5rO1xuY29uc3QgTWlzc2lvblN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL21pc3Npb24tc3RhdGUtc3RvcmUnKTtcbmNvbnN0IE1pc3Npb25UaW1lciA9IHJlcXVpcmUoJy4vbWlzc2lvbi10aW1lci5yZWFjdCcpO1xuY29uc3QgRXZlbnRTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9ldmVudC1zdG9yZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgZ2V0TWlzc2lvbkFDID0gKGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgdG1wID0gbnVsbDtcbiAgICByZXR1cm4gKCk9PiB7XG4gICAgICAgIGlmICghdG1wKSB0bXAgPSByZXF1aXJlKCcuLi9hY3Rpb25zL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgIH1cbn0pKCk7XG5cbmNvbnN0IEV2ZW50VGFibGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgZXZlbnRzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgICAgICAgdHJpZ2dlckRpc2FibGVkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPSd0YWJsZSc+XG4gICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgPHRoPlRpbWU8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGg+VmFsdWU8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGg+VHJpZ2dlcjwvdGg+XG4gICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxuXG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgIHsgIHRoaXMucHJvcHMuZXZlbnRzLm1hcCgoZXYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDx0ciBrZXk9e2V2LmlkfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57ZXYudHJpZ2dlclRpbWV9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57ZXYuc2hvcnRfZGVzY3JpcHRpb259PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57SlNPTi5zdHJpbmdpZnkoZXYudmFsdWUgfHwgJycpfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9eyAnYnRuIGJ0bi1wcmltYXJ5ICcgKyAodGhpcy5wcm9wcy50cmlnZ2VyRGlzYWJsZWQgJiYgJ2Rpc2FibGVkJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBnZXRNaXNzaW9uQUMoKS5hc2tUb1RyaWdnZXJFdmVudChldi5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5UcmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG52YXIgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCl7XG4gICAgICAgIHZhciBhYyA9IGdldE1pc3Npb25BQygpO1xuICAgICAgICBhYy5hc2tGb3JFdmVudHMoKTtcblxuICAgICAgICBFdmVudFN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgICAgTWlzc2lvblN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKVxuXG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCl7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Y2hhcHRlclRpbWU6IHRoaXMuc3RhdGUuY2hhcHRlclRpbWUgKyAxfSlcbiAgICAgICAgfSwxMDAwKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKXtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIEV2ZW50U3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgICBNaXNzaW9uU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpXG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXBsZXRlZEV2ZW50czogW10sXG4gICAgICAgICAgICBvdmVyZHVlRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJlbWFpbmluZ0V2ZW50czogW10sXG4gICAgICAgICAgICBydW5uaW5nOiBNaXNzaW9uU3RvcmUuaXNNaXNzaW9uUnVubmluZygpLFxuICAgICAgICAgICAgY2hhcHRlcjogTWlzc2lvblN0b3JlLmN1cnJlbnRDaGFwdGVyKCksXG4gICAgICAgICAgICBjaGFwdGVyVGltZTogTWlzc2lvblN0b3JlLmNoYXB0ZXJUaW1lKClcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY29tcGxldGVkRXZlbnRzOiBFdmVudFN0b3JlLmNvbXBsZXRlZCgpLFxuICAgICAgICAgICAgb3ZlcmR1ZUV2ZW50czogRXZlbnRTdG9yZS5vdmVyZHVlKCksXG4gICAgICAgICAgICByZW1haW5pbmdFdmVudHM6IEV2ZW50U3RvcmUucmVtYWluaW5nKCksXG4gICAgICAgICAgICBydW5uaW5nOiBNaXNzaW9uU3RvcmUuaXNNaXNzaW9uUnVubmluZygpLFxuICAgICAgICAgICAgY2hhcHRlcjogTWlzc2lvblN0b3JlLmN1cnJlbnRDaGFwdGVyKCksXG4gICAgICAgICAgICBjaGFwdGVyVGltZTogTWlzc2lvblN0b3JlLmNoYXB0ZXJUaW1lKCksXG4gICAgICAgICAgICBzYWZlTW9kZSA6IE1pc3Npb25TdG9yZS5pc1NhdGVsbGl0ZUluU2FmZU1vZGUoKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuXG4gICAgICAgIHZhciBzdGF0dXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IDxwIGlkPVwibWlzc2lvblRpbWVcIj5PcHBkcmFnZXQgaGFyIGlra2Ugc3RhcnRldDwvcD47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cblxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxoMz5TdGF0dXM8L2gzPlxuICAgICAgICAgICAgICAgICAgICB7c3RhdHVzfVxuXG4gICAgICAgICAgICAgICAgICAgIDxkbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkdD5Ow6V2w6ZyZW5kZSBrYXBpdHRlbDo8L2R0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRkPnt0aGlzLnN0YXRlLmNoYXB0ZXJ9PC9kZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkdD5UaWQgYnJ1a3QgaSBrYXBpdHRlbDwvZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGQ+e3RoaXMuc3RhdGUuY2hhcHRlclRpbWV9PC9kZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkdD5Ub3RhbCB0aWQ8L2R0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRkPjxNaXNzaW9uVGltZXIgLz48L2RkPlxuICAgICAgICAgICAgICAgICAgICA8L2RsPlxuICAgICAgICAgICAgICAgICAgICBTYXRlbGxpdGUgaW4gc2FmZSBtb2RlPyB7dGhpcy5zdGF0ZS5zYWZlTW9kZT8gXCJZZXNcIiA6IFwiTm9cIiB9XG5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPSdidG4gYnRuLXByaW1hcnknIG9uQ2xpY2s9e2dldE1pc3Npb25BQygpLnN0YXJ0TWlzc2lvbn0+U3RhcnQgb3BwZHJhZzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5JyBvbkNsaWNrPXtnZXRNaXNzaW9uQUMoKS5zdG9wTWlzc2lvbn0+U3RvcDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5JyBvbkNsaWNrPXtnZXRNaXNzaW9uQUMoKS5hc2tUb1N0YXJ0TmV4dENoYXB0ZXJ9Pk5lc3RlIGthcGl0dGVsXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5JyBvbkNsaWNrPXtnZXRNaXNzaW9uQUMoKS5yZXNldE1pc3Npb259PkJlZ3lubiBww6Ugbnl0dDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9J2J0biBidG4tcHJpbWFyeScgb25DbGljaz17Z2V0TWlzc2lvbkFDKCkuY29tcGxldGVNaXNzaW9ufT5PcHBkcmFnIHV0ZsO4cnQ8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5JyBvbkNsaWNrPXtnZXRNaXNzaW9uQUMoKS5jaGFuZ2VTY3J1YmJlcn0+Qnl0dCBzY3J1YmJlcjwvYnV0dG9uPlxuXG5cbiAgICAgICAgICAgICAgICA8aDI+Q2hhcHRlciBldmVudHM8L2gyPlxuXG4gICAgICAgICAgICAgICAgPGgzPnJlbWFpbmluZzwvaDM+XG4gICAgICAgICAgICAgICAgPEV2ZW50VGFibGUga2V5PVwiZm9vXCIgZXZlbnRzPXt0aGlzLnN0YXRlLnJlbWFpbmluZ0V2ZW50c30vPlxuXG4gICAgICAgICAgICAgICAgPGgzPm92ZXJkdWU8L2gzPlxuICAgICAgICAgICAgICAgIDxFdmVudFRhYmxlIGV2ZW50cz17dGhpcy5zdGF0ZS5vdmVyZHVlRXZlbnRzfS8+XG5cbiAgICAgICAgICAgICAgICA8aDM+Y29tcGxldGVkPC9oMz5cbiAgICAgICAgICAgICAgICA8RXZlbnRUYWJsZSB0cmlnZ2VyRGlzYWJsZWQ9e3RydWV9IGV2ZW50cz17dGhpcy5zdGF0ZS5jb21wbGV0ZWRFdmVudHN9Lz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwO1xuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpLFxuICAgIFRpbWVyU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvdGltZXItc3RvcmUnKSxcbiAgICBUaW1lciA9IHJlcXVpcmUoJy4vdGltZXIucmVhY3QnKTtcblxuXG5jb25zdCBNaXNzaW9uVGltZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBnZXRJbml0aWFsU3RhdGUoKXtcbiAgICAgICAgcmV0dXJuIHsgZWxhcHNlZCA6IFRpbWVyU3RvcmUuZ2V0RWxhcHNlZE1pc3Npb25UaW1lKCkgfTtcbiAgICB9LFxuICAgIFxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFRpbWVyU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlVGltZUNoYW5nZSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFRpbWVyU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlVGltZUNoYW5nZSk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVUaW1lQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGVsYXBzZWQgOiBUaW1lclN0b3JlLmdldEVsYXBzZWRNaXNzaW9uVGltZSgpXG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuICA8VGltZXIgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX0gdGltZUluU2Vjb25kcz17dGhpcy5zdGF0ZS5lbGFwc2VkIH0gLz5cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaXNzaW9uVGltZXI7XG5cbiIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuY29uc3QgTm90Rm91bmQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J2NvbnRhaW5lcic+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyBqdW1ib3Ryb25cIj5cbiAgICAgICAgICAgICAgICA8ZGl2Pk9qc2Fubi4gVHJvciBkdSBoYXIgZ8OldHQgZGVnIHZpbGwsIGplZzwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vdEZvdW5kO1xuIiwiLypcbiAqIFNpbXBsZSBjb21wb25lbnQgdGhhdCBvdmVybGF5cyBhIHNlY3Rpb24sIHNpZ25hbGxpbmcgYSBkaXNhYmxlZCBzdGF0ZVxuICpcbiAqIERlcGVuZGFudCBvbiB3b3JraW5nIENTUywgb2YgY291cnNlOiB0aGUgcGFyZW50IG11c3QgYmUgcG9zaXRpb25lZCAocmVsYXRpdmUsIGFic29sdXRlLCAuLi4pXG4gKiBMb29zZWx5IGJhc2VkIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzYyNzI4My9ob3ctdG8tZGltLW90aGVyLWRpdi1vbi1jbGlja2luZy1pbnB1dC1ib3gtdXNpbmctanF1ZXJ5XG4gKi9cbmNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgYWN0aXZlIDogUmVhY3QuUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9wcy5hY3RpdmU/IDxkaXYgY2xhc3NOYW1lPVwib3ZlcmxheVwiLz4gOiBudWxsKTtcbiAgICB9XG5cbn0pOyIsIi8qKlxuICogVEhJUyBERVNJR04gT05MWSBTVVBQT1JUUyBPTkUgQ0hBUlQgQVMgVEhFWSAqU0hBUkUqIFNUQVRFXG4gKiBGb3IgYSBub24tc3R1cGlkIGRlc2lnbiwgZG8gc29tZXRoaW5nIGxpa2UgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgYXJ0aWNsZSBieSBOaWNvbGFzIEhlcnk6XG4gKiBodHRwOi8vbmljb2xhc2hlcnkuY29tL2ludGVncmF0aW5nLWQzanMtdmlzdWFsaXphdGlvbnMtaW4tYS1yZWFjdC1hcHBcbiAqXG4gKiBDaGFydCBjb2RlIG1vcmUgb3IgbGVzcyBjb3BpZWQgZnJvbSB0aGUgcHJvdG90eXBlIGJ5IExlbyBNYXJ0aW4gV2VzdGJ5XG4gKi9cbmNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IEFtQ2hhcnRzID0gcmVxdWlyZSgnYW1jaGFydHMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9TY2llbmNlVGVhbUNvbnN0YW50cycpO1xuXG52YXIgY2hhcnQsIGNoYXJ0VXBkYXRlciwgZ2V0TmV3VmFsdWUsIHVwZGF0ZUZyZXF1ZW5jeSwgbWF4U2Vjb25kcztcbnZhciByYWRpYXRpb25TYW1wbGVzID0gW107XG5cbmNvbnN0IHsgcmFuZG9tSW50IH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBpbml0Q2hhcnQoZG9tRWxlbWVudCkge1xuXG4gICAgY2hhcnQgPSBuZXcgQW1DaGFydHMuQW1TZXJpYWxDaGFydCgpO1xuXG4gICAgY2hhcnQubWFyZ2luVG9wID0gMjA7XG4gICAgY2hhcnQubWFyZ2luUmlnaHQgPSAwO1xuICAgIGNoYXJ0Lm1hcmdpbkxlZnQgPSAwO1xuICAgIGNoYXJ0LmF1dG9NYXJnaW5PZmZzZXQgPSAwO1xuICAgIGNoYXJ0LmRhdGFQcm92aWRlciA9IHJhZGlhdGlvblNhbXBsZXM7XG4gICAgY2hhcnQuY2F0ZWdvcnlGaWVsZCA9IFwidGltZXN0YW1wXCI7XG5cbiAgICAvL1ggYXhpc1xuICAgIHZhciBjYXRlZ29yeUF4aXMgPSBjaGFydC5jYXRlZ29yeUF4aXM7XG4gICAgY2F0ZWdvcnlBeGlzLmRhc2hMZW5ndGggPSAxO1xuICAgIGNhdGVnb3J5QXhpcy5ncmlkQWxwaGEgPSAwLjE1O1xuICAgIGNhdGVnb3J5QXhpcy5heGlzQ29sb3IgPSBcIiNEQURBREFcIjtcbiAgICBjYXRlZ29yeUF4aXMudGl0bGUgPSBcIlNlY29uZHNcIjtcblxuICAgIC8vWSBheGlzXG4gICAgdmFyIHZhbHVlQXhpcyA9IG5ldyBBbUNoYXJ0cy5WYWx1ZUF4aXMoKTtcbiAgICB2YWx1ZUF4aXMuYXhpc0FscGhhID0gMC4yO1xuICAgIHZhbHVlQXhpcy5kYXNoTGVuZ3RoID0gMTtcbiAgICB2YWx1ZUF4aXMudGl0bGUgPSBcIs68U3YvaFwiO1xuICAgIHZhbHVlQXhpcy5taW5pbXVtID0gY29uc3RhbnRzLlNDSUVOQ0VfUkFESUFUSU9OX01JTjtcbiAgICB2YWx1ZUF4aXMubWF4aW11bSA9IGNvbnN0YW50cy5TQ0lFTkNFX1JBRElBVElPTl9NQVg7XG4gICAgY2hhcnQuYWRkVmFsdWVBeGlzKHZhbHVlQXhpcyk7XG5cbiAgICAvL0xpbmVcbiAgICB2YXIgZ3JhcGggPSBuZXcgQW1DaGFydHMuQW1HcmFwaCgpO1xuICAgIGdyYXBoLnZhbHVlRmllbGQgPSBcInJhZGlhdGlvblwiO1xuICAgIGdyYXBoLmJ1bGxldCA9IFwicm91bmRcIjtcbiAgICBncmFwaC5idWxsZXRCb3JkZXJDb2xvciA9IFwiI0ZGRkZGRlwiO1xuICAgIGdyYXBoLmJ1bGxldEJvcmRlclRoaWNrbmVzcyA9IDI7XG4gICAgZ3JhcGgubGluZVRoaWNrbmVzcyA9IDI7XG4gICAgZ3JhcGgubGluZUNvbG9yID0gXCIjYjUwMzBkXCI7XG4gICAgZ3JhcGgubmVnYXRpdmVMaW5lQ29sb3IgPSBcIiMyMjhCMjJcIjtcbiAgICBncmFwaC5uZWdhdGl2ZUJhc2UgPSA2MDtcbiAgICBncmFwaC5oaWRlQnVsbGV0c0NvdW50ID0gNTA7XG4gICAgY2hhcnQuYWRkR3JhcGgoZ3JhcGgpO1xuXG4gICAgLy9Nb3VzZW92ZXJcbiAgICBjb25zdCBjaGFydEN1cnNvciA9IG5ldyBBbUNoYXJ0cy5DaGFydEN1cnNvcigpO1xuICAgIGNoYXJ0Q3Vyc29yLmN1cnNvclBvc2l0aW9uID0gXCJtb3VzZVwiO1xuICAgIGNoYXJ0LmFkZENoYXJ0Q3Vyc29yKGNoYXJ0Q3Vyc29yKTtcbiAgICBjaGFydC53cml0ZShkb21FbGVtZW50KTtcbn1cblxuLy9BZGRzIGEgbmV3IHJhZGlhdGlvbiBzYW1wbGUgdG8gdGhlIGNoYXJ0IGV2ZXJ5IGZldyBzZWNvbmRzXG5mdW5jdGlvbiBzdGFydEV2ZW50TG9vcCgpIHtcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBzdG9wRXZlbnRMb29wKCk7XG5cbiAgICBjaGFydFVwZGF0ZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWNvbmRzUGFzc2VkID0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMDtcblxuICAgICAgICByYWRpYXRpb25TYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKHNlY29uZHNQYXNzZWQgKyAwLjUpLFxuICAgICAgICAgICAgcmFkaWF0aW9uOiBnZXROZXdWYWx1ZSgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vV2hlbiB0aGUgY2hhcnQgZ3Jvd3MsIHN0YXJ0IGN1dHRpbmcgb2ZmIHRoZSBvbGRlc3Qgc2FtcGxlIHRvIGdpdmUgdGhlIGNoYXJ0IGEgc2xpZGluZyBlZmZlY3RcbiAgICAgICAgaWYgKHJhZGlhdGlvblNhbXBsZXMubGVuZ3RoID4gKG1heFNlY29uZHMgLyB1cGRhdGVGcmVxdWVuY3kpKSB7XG4gICAgICAgICAgICByYWRpYXRpb25TYW1wbGVzLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydC52YWxpZGF0ZURhdGEoKTtcbiAgICB9LCB1cGRhdGVGcmVxdWVuY3kgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gc3RvcEV2ZW50TG9vcCgpIHtcbiAgICBjbGVhckludGVydmFsKGNoYXJ0VXBkYXRlcik7XG59XG5cbmNvbnN0IFJhZGlhdGlvbkNoYXJ0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgc3RhdGljczoge30sXG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgdXBkYXRlRnJlcXVlbmN5U2Vjb25kczogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICBtYXhTZWNvbmRzU2hvd246IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgZ2V0TmV3VmFsdWU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICB3aWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtdLFxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB1cGRhdGVGcmVxdWVuY3kgPSB0aGlzLnByb3BzLnVwZGF0ZUZyZXF1ZW5jeVNlY29uZHM7XG4gICAgICAgIG1heFNlY29uZHMgPSB0aGlzLnByb3BzLm1heFNlY29uZHNTaG93bjtcbiAgICAgICAgZ2V0TmV3VmFsdWUgPSB0aGlzLnByb3BzLmdldE5ld1ZhbHVlO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIGVsID0gUmVhY3QuZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgIGluaXRDaGFydChlbCk7XG4gICAgICAgIHN0YXJ0RXZlbnRMb29wKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjaGFydCAmJiBjaGFydC5jbGVhcigpO1xuICAgICAgICBzdG9wRXZlbnRMb29wKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVubW91bnQoKSB7XG4gICAgICAgIGNoYXJ0ID0gbnVsbDtcbiAgICAgICAgLy9yYWRpYXRpb25TYW1wbGVzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB9LFxuXG4gICAgLy8gdGhpcyBjaGFydCBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBpdHNlbGZcbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzXG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgLy8gaWYgeW91IGRvbid0IHNwZWNpZnkgd2lkdGggaXQgd2lsbCBtYXggb3V0IHRvIDEwMCUgKHdoaWNoIGlzIG9rKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7d2lkdGg6IHRoaXMucHJvcHMud2lkdGggKyAncHgnLCBoZWlnaHQgOiB0aGlzLnByb3BzLmhlaWdodCsgJ3B4J319XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICApO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFkaWF0aW9uQ2hhcnQ7XG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0JyksXG4gICAgVGltZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy90aW1lci1zdG9yZScpLFxuICAgIE1pc3Npb25BY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyksXG4gICAgVGltZXJBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvVGltZXJBY3Rpb25DcmVhdG9ycycpLFxuICAgIFNjaWVuY2VBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvU2NpZW5jZUFjdGlvbkNyZWF0b3JzJyksXG4gICAgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL1NjaWVuY2VUZWFtQ29uc3RhbnRzJyk7XG5cbnZhciBSYWRpYXRpb25TYW1wbGVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIHJlcXVpcmVkU2FtcGxlczogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICByYWRpYXRpb25TdG9yZVN0YXRlOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBUaW1lclN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX2hhbmRsZVRpbWVyQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCl7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnRpbWVyQWN0aXZlKSB7XG4gICAgICAgICAgICBsZXQgZWwgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzLnJlZnNbJ3NhbXBsZS1idXR0b24nXSk7XG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKXtcbiAgICAgICAgVGltZXJTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9oYW5kbGVUaW1lckNoYW5nZSk7XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHt0aW1lckFjdGl2ZTogZmFsc2V9XG4gICAgfSxcblxuICAgIF9pc0Rpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc3RhdGUudGltZXJBY3RpdmVcbiAgICB9LFxuXG5cbiAgICBfaGFuZGxlVGltZXJDaGFuZ2UoKSB7XG4gICAgICAgIHZhciBhdWRpbyA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMucmVmc1snZ2VpZ2VyU291bmQnXSk7XG4gICAgICAgIHZhciB0aW1lckFjdGl2ZSA9IFRpbWVyU3RvcmUuaXNSdW5uaW5nKGNvbnN0YW50cy5TQ0lFTkNFX1RJTUVSXzEpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3RpbWVyQWN0aXZlOiB0aW1lckFjdGl2ZX0pO1xuXG4gICAgICAgIGlmICh0aW1lckFjdGl2ZSAmJiBhdWRpby5wYXVzZWQpIHtcbiAgICAgICAgICAgIGF1ZGlvLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGltZXJBY3RpdmUgJiYgIWF1ZGlvLnBhdXNlZCkge1xuICAgICAgICAgICAgYXVkaW8ucGF1c2UoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIFNjaWVuY2VBY3Rpb25DcmVhdG9ycy50YWtlUmFkaWF0aW9uU2FtcGxlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmFkaWF0aW9uU3RvcmVTdGF0ZS5zYW1wbGVzLmxlbmd0aCArIDEgPj0gdGhpcy5wcm9wcy5yZXF1aXJlZFNhbXBsZXMpIHtcbiAgICAgICAgICAgIFRpbWVyQWN0aW9uQ3JlYXRvcnMuc3RvcFRpbWVyKGNvbnN0YW50cy5TQ0lFTkNFX1RJTUVSXzEpO1xuICAgICAgICAgICAgU2NpZW5jZUFjdGlvbkNyZWF0b3JzLmNvbXBsZXRlVGFzaygnc2FtcGxlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgZGlzYWJsZWQsIGNsYXNzZXM7XG5cbiAgICAgICAgY2xhc3NlcyA9ICdidG4gYnRuLXByaW1hcnknO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgICAgIGNsYXNzZXMgKz0gJyBkaXNhYmxlZCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPXtcInJhZGlhdGlvbi1zYW1wbGVyIFwiICsgdGhpcy5wcm9wcy5jbGFzc05hbWV9PlxuXG4gICAgICAgICAgICAgICAgeyAvKiBBdm9pZCBmbG9hdGluZyBpbnRvIHByZXZpb3VzIGJsb2NrICovIH1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJhZGlhdGlvbi1zYW1wbGVyX19wYWRkZXIgY2xlYXJmaXggdmlzaWJsZS14cy1ibG9ja1wiLz5cblxuICAgICAgICAgICAgICAgIDxhdWRpbyByZWY9XCJnZWlnZXJTb3VuZFwiIGxvb3A+XG4gICAgICAgICAgICAgICAgICAgIDxzb3VyY2Ugc3JjPVwiL3NvdW5kcy9BT1MwNDU5NV9FbGVjdHJpY19HZWlnZXJfQ291bnRlcl9GYXN0LndhdlwiIHR5cGU9XCJhdWRpby93YXZcIi8+XG4gICAgICAgICAgICAgICAgPC9hdWRpbz5cblxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj0nc2FtcGxlLWJ1dHRvbidcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX2hhbmRsZUNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlRhIHN0csOlbGluZ3NwcsO4dmVcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYWRpYXRpb25TYW1wbGVyOyIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBzdGF0aWNzOiB7fSxcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgc2FtcGxlczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gICAgICAgIG1pbmltYWxSb3dzVG9TaG93OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kc1xuXG4gICAgZ2V0RGVmYXVsdFByb3BzKCl7XG4gICAgICAgIHJldHVybiB7bWluaW1hbFJvd3NUb1Nob3c6IDB9O1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBzYW1wbGVSb3dzID0gdGhpcy5wcm9wcy5zYW1wbGVzLm1hcCgodmFsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDx0ciBrZXk9e2l9PlxuICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9XCJyb3dcIj57aSArIDF9PC90aD5cbiAgICAgICAgICAgICAgICAgICAgPHRkPnt2YWx9PC90ZD5cbiAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtaXNzaW5nUm93cyA9IHRoaXMucHJvcHMubWluaW1hbFJvd3NUb1Nob3cgLSBzYW1wbGVSb3dzLmxlbmd0aCxcbiAgICAgICAgICAgIGZpbGxSb3dzO1xuXG4gICAgICAgIGlmIChtaXNzaW5nUm93cyA+IDApIHtcbiAgICAgICAgICAgIGZpbGxSb3dzID0gW107XG5cbiAgICAgICAgICAgIHdoaWxlIChtaXNzaW5nUm93cy0tKSB7XG4gICAgICAgICAgICAgICAgZmlsbFJvd3MucHVzaCg8dHIga2V5PXtmaWxsUm93cy5sZW5ndGh9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHNjb3BlPVwicm93XCI+PC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD4mbmJzcDt7LyogTmVlZHMgZmlsbGVyIHRvIG5vdCBjb2xsYXBzZSBjZWxsICovfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX0+XG5cbiAgICAgICAgICAgICAgICA8aDM+UHLDuHZlcmVzdWx0YXRlcjwvaDM+XG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cIiB0YWJsZSB0YWJsZS1ib3JkZXJlZFwiPlxuICAgICAgICAgICAgICAgICAgICA8Y2FwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFN0csOlbGluZ3NwYXJ0aWtsZXIgcGVyIHNla3VuZCAocC9zKVxuICAgICAgICAgICAgICAgICAgICA8L2NhcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+UHLDuHZlbnVtbWVyPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT1cImNvbFwiPnAvczwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgeyBzYW1wbGVSb3dzIH1cbiAgICAgICAgICAgICAgICAgICAgeyBmaWxsUm93cyB9XG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICAgICAgPC90YWJsZT5cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG59KTtcblxuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgVGltZXJQYW5lbCA9IHJlcXVpcmUoJy4vdGltZXItcGFuZWwucmVhY3QnKTtcbmNvbnN0IFJhZGlhdGlvbkNoYXJ0ID0gcmVxdWlyZSgnLi9yYWRpYXRpb24tY2hhcnQucmVhY3QuanMnKTtcbmNvbnN0IFJhZGlhdGlvblNhbXBsZUJ1dHRvbiA9IHJlcXVpcmUoJy4vcmFkaWF0aW9uLXNhbXBsZXIucmVhY3QnKTtcbmNvbnN0IE92ZXJsYXkgPSByZXF1aXJlKCcuL292ZXJsYXkucmVhY3QnKTtcbmNvbnN0IFJhZGlhdGlvblRhYmxlID0gcmVxdWlyZSgnLi9yYWRpYXRpb24tdGFibGUucmVhY3QnKTtcbmNvbnN0IFJhZGlhdGlvblN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL3JhZGlhdGlvbi1zdG9yZScpO1xuY29uc3QgYWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvU2NpZW5jZUFjdGlvbkNyZWF0b3JzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBTY2llbmNlVGVhbUNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9TY2llbmNlVGVhbUNvbnN0YW50cycpO1xuY29uc3QgVGltZXJBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvVGltZXJBY3Rpb25DcmVhdG9ycycpO1xuXG5cbi8vIFNFVFRJTkdTXG5UaW1lckFjdGlvbkNyZWF0b3JzLnNldFRpbWVyKFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfVElNRVJfMSwgMzApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHN0YXRpY3M6IHt9LFxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBhcHBzdGF0ZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG4gICAgfSxcbiAgICBtaXhpbnM6IFtdLFxuXG4gICAgLy8gbGlmZSBjeWNsZSBtZXRob2RzXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFkaWF0aW9uOiBSYWRpYXRpb25TdG9yZS5nZXRTdGF0ZSgpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgUmFkaWF0aW9uU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlUmFkaWF0aW9uQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIFJhZGlhdGlvblN0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuX2hhbmRsZVJhZGlhdGlvbkNoYW5nZSk7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kc1xuXG4gICAgX2hhbmRsZVJhZGlhdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICByYWRpYXRpb246IFJhZGlhdGlvblN0b3JlLmdldFN0YXRlKClcbiAgICAgICAgfSlcbiAgICB9LFxuXG4gICAgX2hhbmRsZUF2ZXJhZ2VSYWRpYXRpb25TdWJtaXQoZSkge1xuICAgICAgICBsZXQgZWwgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzLnJlZnNbJ2F2ZXJhZ2UtaW5wdXQnXSksXG4gICAgICAgICAgICB2YWwgPSBlbC52YWx1ZS50cmltKCk7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghdmFsLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBhdmVyYWdlID0gdXRpbHMucGFyc2VOdW1iZXIodmFsKTtcbiAgICAgICAgZWwudmFsdWUgPSAnJztcblxuICAgICAgICBpZiAoYXZlcmFnZSkge1xuICAgICAgICAgICAgYWN0aW9ucy5hdmVyYWdlUmFkaWF0aW9uQ2FsY3VsYXRlZChhdmVyYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaGFuZGxlQWRkVG9Ub3RhbFN1Ym1pdChlKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGxldCBlbCA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMucmVmc1snYWRkLXRvLXRvdGFsJ10pO1xuICAgICAgICBsZXQgdmFsID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgICBpZiAoIXZhbC5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICBsZXQgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIodmFsKTtcblxuICAgICAgICBpZiAoIWlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgIGFjdGlvbnMuYWRkVG9Ub3RhbFJhZGlhdGlvbkxldmVsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKlxuICAgICAqIEhlbHBlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrTmFtZSBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGN1cnJlbnQgdGFzayBpZCBlcXVhbHMgdGhlIG5hbWUgcGFzc2VkIGluXG4gICAgICovXG4gICAgX2lzQ3VycmVudFRhc2sodGFza05hbWUpe1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5hcHBzdGF0ZS50YXNrU3RvcmUuY3VycmVudFRhc2tJZCA9PT0gdGFza05hbWU7XG4gICAgfSxcblxuICAgIF9yYWRpYXRpb25TdGF0dXMoKXtcbiAgICAgICAgdmFyIG51bSA9IHRoaXMuc3RhdGUucmFkaWF0aW9uLmxhc3RDYWxjdWxhdGVkQXZlcmFnZSxcbiAgICAgICAgICAgIGNvbG9yO1xuXG4gICAgICAgIGlmIChudW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnSWtrZSBiZXJlZ25ldCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtID4gU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9BVkdfUkFEX1JFRF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIGNvbG9yID0gJ3JlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtID4gU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9BVkdfUkFEX09SQU5HRV9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIGNvbG9yID0gJ29yYW5nZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xvciA9ICdncmVlbic7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiAoPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwicmFkaWF0aW9uLWluZGljYXRvciBjaXJjbGUgY29sLXhzLTJcIlxuICAgICAgICAgICAgc3R5bGU9eyB7ICdiYWNrZ3JvdW5kQ29sb3InIDogY29sb3IgfSB9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICB7bnVtIH1cbiAgICAgICAgPC9kaXY+KTtcblxuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBzaG93U2FtcGxlSW5wdXQgPSB0aGlzLl9pc0N1cnJlbnRUYXNrKCdzYW1wbGUnKSxcbiAgICAgICAgICAgIHNob3dBdmVyYWdlSW5wdXQgPSB0aGlzLl9pc0N1cnJlbnRUYXNrKCdhdmVyYWdlJyksXG4gICAgICAgICAgICBzaG93QWRkVG9Ub3RhbElucHV0ID0gdGhpcy5faXNDdXJyZW50VGFzaygnYWRkdG90YWwnKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3Jvdyc+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRsIGNsYXNzTmFtZT0ncmFkaWF0aW9uLXZhbHVlcyBjb2wteHMtNiAnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGR0PlRvdGFsdCBzdHLDpWxpbmdzbml2w6U8L2R0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRkPnt0aGlzLnN0YXRlLnJhZGlhdGlvbi50b3RhbH08L2RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGR0PlNpc3QgaW5ubGVzdCBzdHLDpWxpbmdzbml2w6U8L2R0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRkPnsgdGhpcy5fcmFkaWF0aW9uU3RhdHVzKCl9IDwvZGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvZGw+XG5cbiAgICAgICAgICAgICAgICAgICAgPFJhZGlhdGlvblRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbWFsUm93c1RvU2hvdz17NH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXM9e3RoaXMuc3RhdGUucmFkaWF0aW9uLnNhbXBsZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9J2NvbC14cy02ICcvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGhyLz5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5zdHJ1bWVudHNcIj5cblxuICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgZGlzYWJsZWQ9eyFzaG93U2FtcGxlSW5wdXR9IGNsYXNzTmFtZT0naW5zdHJ1bWVudHNfX3NlY3Rpb24gcm93IG92ZXJsYXlhYmxlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxPdmVybGF5IGFjdGl2ZT17ICFzaG93U2FtcGxlSW5wdXQgfS8+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9J2NvbC14cy0xMic+VGEgcHLDuHZlcjwvaDM+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VGltZXJQYW5lbCBjbGFzc05hbWU9J2NvbC14cy0xMiBjb2wtc20tOCcgdGltZXJJZD17U2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9USU1FUl8xfS8+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxSYWRpYXRpb25TYW1wbGVCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9J2NvbC14cy01IGNvbC1zbS00J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGlhdGlvblN0b3JlU3RhdGU9e3RoaXMuc3RhdGUucmFkaWF0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkU2FtcGxlcz17NH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxuXG4gICAgICAgICAgICAgICAgICAgIDxociAvPlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93IG92ZXJsYXlhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8T3ZlcmxheSBhY3RpdmU9eyAhc2hvd0F2ZXJhZ2VJbnB1dCB9Lz5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwicmFkaWF0aW9uLWlucHV0IGluc3RydW1lbnRzX19zZWN0aW9uIGNvbC14cy0xMiBjb2wtc20tNlwiPlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPSdjb2wteHMtMTInPkdqZW5ub21zbml0dGxpZyBzdHLDpWxpbmc8L2gzPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldCBjbGFzc05hbWU9XCJjb2wteHMtOFwiIGRpc2FibGVkPXsgIXNob3dBdmVyYWdlSW5wdXQgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXt0aGlzLl9oYW5kbGVBdmVyYWdlUmFkaWF0aW9uU3VibWl0fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcmVmPSdhdmVyYWdlLWlucHV0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcD1cIjAuMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCIxMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9J3JhZGlhdGlvbi1pbnB1dF9faW5wdXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9J2J0biBidG4tcHJpbWFyeSc+RXZhbHVlcjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICA8aHIvPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyBvdmVybGF5YWJsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPE92ZXJsYXkgYWN0aXZlPXsgIXNob3dBZGRUb1RvdGFsSW5wdXQgfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPSdyYWRpYXRpb24taW5wdXQgY29sLXhzLTgnIGRpc2FibGVkPXshIHNob3dBZGRUb1RvdGFsSW5wdXQgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDM+TGVnZyB2ZXJkaSB0aWwgdG90YWw8L2gzPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0gb25TdWJtaXQ9e3RoaXMuX2hhbmRsZUFkZFRvVG90YWxTdWJtaXR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHJlZj0nYWRkLXRvLXRvdGFsJyBjbGFzc05hbWU9J3JhZGlhdGlvbi1pbnB1dF9faW5wdXQnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nMCc+MDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nMTUnPjE1PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSc1MCc+NTA8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPSdidG4gYnRuLXByaW1hcnknPkV2YWx1ZXI8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG59KTtcbiIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IENPMlN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL2NhcmJvbi1kaW94aWRlLXN0b3JlJyk7XG5jb25zdCBPeHlnZW5TdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9veHlnZW4tc3RvcmUnKTtcbmNvbnN0IENvbW11bmljYXRpb25RdWFsaXR5U3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvY29tbXVuaWNhdGlvbi1xdWFsaXR5LXN0b3JlJyk7XG5jb25zdCBTZWN1cml0eVRlYW1BQyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvU2VjdXJpdHlUZWFtQWN0aW9uQ3JlYXRvcnMnKTtcblxudmFyIGNoYXJ0ID0gbnVsbDtcbnZhciBjaGFydERhdGEgPSBbe3RpdGxlOiAnTHVmdCcsIHZhbHVlOiAxMDB9XTtcblxuZnVuY3Rpb24gaW5pdChkb21FbGVtKSB7XG4gICAgY2hhcnQgPSBuZXcgQW1DaGFydHMuQW1QaWVDaGFydCgpO1xuICAgIGNoYXJ0LnZhbHVlRmllbGQgPSBcInZhbHVlXCI7XG4gICAgY2hhcnQudGl0bGVGaWVsZCA9IFwidGl0bGVcIjtcbiAgICBjaGFydC5kYXRhUHJvdmlkZXIgPSBjaGFydERhdGE7XG4gICAgY2hhcnQud3JpdGUoZG9tRWxlbSk7XG59XG5cbnZhciBQaWVDaGFydCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBoZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgd2lkdGg6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBDTzJTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcigoKSA9PiB0aGlzLl91cGRhdGVEYXRhKCkpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpe1xuICAgICAgICB2YXIgZWwgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaW5pdChlbCk7XG4gICAgfSxcblxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpe1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9LFxuXG4gICAgX3VwZGF0ZURhdGEoKXtcbiAgICAgICAgdmFyIGNvMiA9IENPMlN0b3JlLmNvMkxldmVsKCk7XG4gICAgICAgIGNoYXJ0RGF0YS5sZW5ndGggPSAwO1xuICAgICAgICBjaGFydERhdGEucHVzaCh7dGl0bGU6ICdBbm5lbiBsdWZ0JywgdmFsdWU6IDEwMCAtIGNvMn0pO1xuICAgICAgICBjaGFydERhdGEucHVzaCh7dGl0bGU6ICdDT1xcdTIwODInLCB2YWx1ZTogY28yfSk7XG5cbiAgICAgICAgY2hhcnQudmFsaWRhdGVEYXRhKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcigpe1xuICAgICAgICByZXR1cm4gPGRpdiBzdHlsZT17e2hlaWdodCA6IHRoaXMucHJvcHMuaGVpZ2h0LCB3aWR0aCA6IHRoaXMucHJvcHMud2lkdGggfX0vPjtcbiAgICB9XG59KTtcblxuXG52YXIgUHJvZ3Jlc3NCYXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgcHJvZ3Jlc3M6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgbWF4OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIGFjdGl2ZTogUmVhY3QuUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICAgICAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG4gICAgfSxcblxuICAgIHJlbmRlcigpe1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5wcm9wcy5wcm9ncmVzcywgbWF4ID0gdGhpcy5wcm9wcy5tYXg7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInByb2dyZXNzXCI+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9eyBcInByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItc3RyaXBlZCBcIiArIHRoaXMucHJvcHMuY2xhc3NOYW1lICsgKHRoaXMucHJvcHMuYWN0aXZlPyAnIGFjdGl2ZSc6JycpIH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3t3aWR0aCA6ICB2YWwqbWF4ICsgJyUnfX1cbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCI+e01hdGgubWluKE1hdGgucm91bmQodmFsICogbWF4KSwgbWF4KX0lXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgc3RhdGljczoge30sXG5cbiAgICBwcm9wVHlwZXM6IHt9LFxuXG4gICAgbWl4aW5zOiBbXSxcblxuICAgIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICAgICAgc3RhdGUuY29tbVByb2dyZXNzID0gMDtcbiAgICAgICAgc3RhdGUucXVhbGl0eVByb2dyZXNzID0gMDtcbiAgICAgICAgc3RhdGUuZGF0YVF1YWxpdHlGYWlsaW5nID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucmVhZHlGb3JTYWZlTW9kZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgT3h5Z2VuU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIoKCkgPT4gdGhpcy5fdXBkYXRlU3RhdGUoKSk7XG4gICAgICAgIENvbW11bmljYXRpb25RdWFsaXR5U3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIoKCkgPT4gdGhpcy5fdXBkYXRlU3RhdGUoKSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIH0sXG5cbiAgICBfc3RhcnRRdWFsaXR5UHJvZ3Jlc3NCYXIoKXtcbiAgICAgICAgdmFyIG1zID0gNTAwLCB0b3RhbER1cmF0aW9uID0gNSAqIDEwMDA7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3F1YWxpdHlQcm9ncmVzczogMH0pXG5cbiAgICAgICAgdmFyIHRtcCA9IHNldEludGVydmFsKCgpPT4ge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHRoaXMuc3RhdGUucXVhbGl0eVByb2dyZXNzO1xuICAgICAgICAgICAgbnVtYmVyICs9IG1zIC8gdG90YWxEdXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKG51bWJlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0bXApO1xuICAgICAgICAgICAgICAgIFNlY3VyaXR5VGVhbUFDLmVuZERhdGFRdWFsaXR5VGVzdCghdGhpcy5zdGF0ZS5kYXRhUXVhbGl0eUZhaWxpbmcpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZXRTdGF0ZSh7cXVhbGl0eVByb2dyZXNzOiAwfSksIDkwMDApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3F1YWxpdHlQcm9ncmVzczogbnVtYmVyfSlcbiAgICAgICAgfSwgbXMpXG4gICAgfSxcblxuXG4gICAgX3N0YXJ0VHJhbnNmZXJQcm9ncmVzc0Jhcigpe1xuICAgICAgICB2YXIgbXMgPSA1MDAsIHRvdGFsRHVyYXRpb24gPSA1ICogMTAwMDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Y29tbVByb2dyZXNzOiAwfSk7XG5cbiAgICAgICAgdmFyIHRtcCA9IHNldEludGVydmFsKCgpPT4ge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHRoaXMuc3RhdGUuY29tbVByb2dyZXNzO1xuICAgICAgICAgICAgbnVtYmVyICs9IG1zIC8gdG90YWxEdXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKG51bWJlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0bXApO1xuICAgICAgICAgICAgICAgIFNlY3VyaXR5VGVhbUFDLmVuZERhdGFUcmFuc2ZlclRlc3QoIXRoaXMuc3RhdGUuZGF0YVRyYW5zZmVyRmFpbGluZyk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNldFN0YXRlKHtjb21tUHJvZ3Jlc3M6IDB9KSwgOTAwMClcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtjb21tUHJvZ3Jlc3M6IG51bWJlcn0pXG4gICAgICAgIH0sIG1zKVxuICAgIH0sXG5cbiAgICBfcXVhbGl0eUFjdGl2ZSgpe1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUucXVhbGl0eVByb2dyZXNzIDwgMSk7XG4gICAgfSxcblxuICAgIF9jb21tQWN0aXZlKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbW1Qcm9ncmVzcyA8IDE7XG4gICAgfSxcblxuICAgIF91cGRhdGVTdGF0ZSgpe1xuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuX2dldFN0YXRlKCkpO1xuICAgIH0sXG5cbiAgICBfaW5kaWNhdG9yQ29sb3IoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub3h5Z2VuU3RvcmUuY29sb3JJbmRpY2F0b3I7XG4gICAgfSxcblxuICAgIF9nZXRTdGF0ZSgpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3h5Z2VuU3RvcmU6IE94eWdlblN0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgICBkYXRhUXVhbGl0eUZhaWxpbmc6IENvbW11bmljYXRpb25RdWFsaXR5U3RvcmUucXVhbGl0eVRlc3RTaG91bGRGYWlsKCksXG4gICAgICAgICAgICBkYXRhVHJhbnNmZXJGYWlsaW5nOiBDb21tdW5pY2F0aW9uUXVhbGl0eVN0b3JlLnRyYW5zZmVyVGVzdFNob3VsZCgpLFxuICAgICAgICAgICAgcmVhZHlGb3JTYWZlTW9kZTogQ29tbXVuaWNhdGlvblF1YWxpdHlTdG9yZS5yZWFkeUZvclNhZmVNb2RlKClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuXG4gICAgICAgIHZhciBpbmRpY2F0b3IgPSA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjaXJjbGUgXCJcbiAgICAgICAgICAgIHN0eWxlPXsgeyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJywgYmFja2dyb3VuZENvbG9yIDogdGhpcy5faW5kaWNhdG9yQ29sb3IoKSB9IH1cbiAgICAgICAgICAgIC8+O1xuXG5cbiAgICAgICAgcmV0dXJuICggPGRpdiA+XG5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cblxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tNlwiPlxuXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogJzIwcHgnfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17ICdidG4gYnRuLXByaW1hcnkgJyArICh0aGlzLnN0YXRlLnJlYWR5Rm9yU2FmZU1vZGU/ICcnIDogJ2Rpc2FibGVkJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtTZWN1cml0eVRlYW1BQy5zZXRJblNhZmVNb2RlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlNlbmQgaSBTQUZFIE1PREU8L2J1dHRvbj5cblxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPScnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlNjcnViZmlsdGVyIGJ5dHRldDoge0NPMlN0b3JlLmZpbHRlckNoYW5nZWQoKSA/ICdqYScgOiAnbmVpJ308L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPk9rc3lnZW5pbmRpa2F0b3I6IHtpbmRpY2F0b3J9IDwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29sLXhzLTEyIGNvbC1zbS02Jz5cbiAgICAgICAgICAgICAgICAgICAgPGgzPklubmhvbGQga2FyYm9uZGlva3NpZCBpIGRyYWt0ZW4gYXYgdG90YWwgbHVmdG1lbmdkZTwvaDM+XG4gICAgICAgICAgICAgICAgICAgIDxQaWVDaGFydCBoZWlnaHQ9XCIyMDBweFwiLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIlwiPlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJcIj5Lb21tdW5pa2Fzam9uIG9nIGRhdGE8L3A+XG5cbiAgICAgICAgICAgICAgICAgICAgPHAgPktvbW11bmlrYXNqb25zc3RhdHVzIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgPFByb2dyZXNzQmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg9ezEwMH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17dGhpcy5fY29tbUFjdGl2ZSgpfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXt0aGlzLnN0YXRlLmRhdGFUcmFuc2ZlckZhaWxpbmcgPyAoIXRoaXMuX2NvbW1BY3RpdmUoKT8gJ3Byb2dyZXNzLWJhci1kYW5nZXInIDogJycpOicnfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M9e3RoaXMuc3RhdGUuY29tbVByb2dyZXNzfS8+XG5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXt0aGlzLl9zdGFydFRyYW5zZmVyUHJvZ3Jlc3NCYXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJ0bi1wcmltYXJ5XCI+VGVzdFxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgICAgICAgICA8cCA+RGF0YWt2YWxpdGV0PC9wPlxuXG4gICAgICAgICAgICAgICAgICAgIDxQcm9ncmVzc0JhclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4PXsxMDB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e3RoaXMuX3F1YWxpdHlBY3RpdmUoKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17dGhpcy5zdGF0ZS5kYXRhUXVhbGl0eUZhaWxpbmcgPyAoIXRoaXMuX3F1YWxpdHlBY3RpdmUoKT8gJ3Byb2dyZXNzLWJhci1kYW5nZXInIDogJycpOicnfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M9e3RoaXMuc3RhdGUucXVhbGl0eVByb2dyZXNzfS8+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXsgJ2J0biBidG4tcHJpbWFyeSAnICsgKHRoaXMuc3RhdGUuZGF0YVRyYW5zZmVyRmFpbGluZz8gJ2Rpc2FibGVkJyA6ICcnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9zdGFydFF1YWxpdHlQcm9ncmVzc0Jhcn1cbiAgICAgICAgICAgICAgICAgICAgICAgID5UZXN0XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Rpdj4gKTtcbiAgICB9XG5cbn0pO1xuXG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0JyksXG4gICAgUm91dGVyID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyksXG4gICAgTWVzc2FnZVN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL21lc3NhZ2Utc3RvcmUnKSxcbiAgICBUYXNrU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvdGFzay1zdG9yZScpLFxuICAgIFJvdXRlU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvcm91dGUtc3RvcmUnKSxcbiAgICBNZXNzYWdlTGlzdCA9IHJlcXVpcmUoJy4vbWVzc2FnZS1saXN0LnJlYWN0JyksXG4gICAgSW50cm9kdWN0aW9uU2NyZWVuID0gcmVxdWlyZSgnLi9pbnRyb2R1Y3Rpb24tc2NyZWVuLnJlYWN0LmpzJyksXG4gICAgVGVhbURpc3BsYXllciA9IHJlcXVpcmUoJy4vdGVhbS1kaXNwbGF5ZXIucmVhY3QnKSxcbiAgICBNaXNzaW9uVGltZXIgPSByZXF1aXJlKCcuL21pc3Npb24tdGltZXIucmVhY3QuanMnKSxcbiAgICBTY2llbmNlVGFzayA9IHJlcXVpcmUoJy4vc2NpZW5jZS10YXNrLnJlYWN0JyksXG4gICAgQXN0cm9uYXV0VGFzayA9IHJlcXVpcmUoJy4vYXN0cm9uYXV0LXRhc2sucmVhY3QnKSxcbiAgICBDb21tdW5pY2F0aW9uVGFzayA9IHJlcXVpcmUoJy4vY29tbXVuaWNhdGlvbi10YXNrLnJlYWN0LmpzJyksXG4gICAgU2VjdXJpdHlUYXNrID0gcmVxdWlyZSgnLi9zZWN1cml0eS10YXNrLnJlYWN0LmpzJyksXG4gICAgeyBmb3JtYXQgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLy8gbGF6eXJlcXVpcmVcbmZ1bmN0aW9uIGxhenlSZXF1aXJlKHBhdGgpIHtcbiAgICBsZXQgdG1wID0gbnVsbDtcbiAgICByZXR1cm4gKCk9PiB7XG4gICAgICAgIGlmICghdG1wKSB0bXAgPSByZXF1aXJlKHBhdGgpO1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgIH1cbn1cbmlmIChmYWxzZSkge1xuICAgIHJlcXVpcmUoJy4uL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG59XG5jb25zdCBnZXRNaXNzaW9uQUMgPSBsYXp5UmVxdWlyZSgnLi4vYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcblxuZnVuY3Rpb24gdXJsT2ZUYXNrKHRhc2tJZCkge1xuICAgIHJldHVybiBmb3JtYXQoJy8lcy90YXNrLyVzJywgUm91dGVTdG9yZS5nZXRUZWFtSWQoKSwgdGFza0lkKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvblRvQ3VycmVudFRhc2sodHJhbnNpdGlvbkZ1bmN0aW9uKSB7XG4gICAgdmFyIGN1cnJlbnRUYXNrSWQgPSBUYXNrU3RvcmUuZ2V0Q3VycmVudFRhc2tJZCgpO1xuXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBmcmFnaWxlIC0gaWYgeW91IHNob3VsZCBzdWRkZW5seSBkZWNpZGUgdG8gdmlzaXQgYW5vdGhlciB0ZWFtXG4gICAgLy8gX2FmdGVyXyB5b3UgaGF2ZSBzdGFydGVkIGEgdGFzaywgdGhlIHRlYW0rdGFzayBjb21ibyBpcyBpbnZhbGlkIC0+IDQwNFxuICAgIGlmIChjdXJyZW50VGFza0lkICE9PSBSb3V0ZVN0b3JlLmdldFRhc2tJZCgpKSB7XG4gICAgICAgIHZhciB0byA9IHVybE9mVGFzayhjdXJyZW50VGFza0lkKTtcbiAgICAgICAgdHJhbnNpdGlvbkZ1bmN0aW9uKHRvKTtcbiAgICB9XG5cbn1cblxuY29uc3QgVGFzayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIGNvbnRleHRUeXBlczoge1xuICAgICAgICByb3V0ZXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gICAgfSxcblxuICAgIG1peGluczogW10sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIHdpbGxUcmFuc2l0aW9uVG8odHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdHJhbnNpdGlvblRvQ3VycmVudFRhc2sodHJhbnNpdGlvbi5yZWRpcmVjdC5iaW5kKHRyYW5zaXRpb24pKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTWVzc2FnZVN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgICAgVGFza1N0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgICAgIE1lc3NhZ2VTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG4gICAgICAgIFRhc2tTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0YXRlVGltZW91dCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY29tcG9uZW50RGlkVW5tb3VudCcpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJy5jb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PiB0aGlzLnNldFN0YXRlKHt0YXNrSXNOZXc6IGZhbHNlfSksIDIwMDApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlczogTWVzc2FnZVN0b3JlLmdldE1lc3NhZ2VzKCksXG4gICAgICAgICAgICB0YXNrU3RvcmU6IFRhc2tTdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgdGFza0lzTmV3OiB0cnVlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9vbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBtZXNzYWdlczogTWVzc2FnZVN0b3JlLmdldE1lc3NhZ2VzKCksXG4gICAgICAgICAgICB0YXNrU3RvcmU6IFRhc2tTdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgdGFza0lzTmV3OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xuICAgICAgICB0cmFuc2l0aW9uVG9DdXJyZW50VGFzayhyb3V0ZXIudHJhbnNpdGlvblRvLmJpbmQocm91dGVyKSk7XG5cbiAgICAgICAgLy8gYSBiaXQgcnVkaW1lbnRhcnkgLSB0cmlnZ2VycyBvbiBhbGwgY2hhbmdlcywgbm90IGp1c3QgVGFzayBjaGFuZ2VzIC4uLlxuICAgICAgICB0aGlzLl9zdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpPT4gdGhpcy5zZXRTdGF0ZSh7dGFza0lzTmV3OiBmYWxzZX0pLCAyMDAwKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZVN1YlRhc2tVSSgpIHtcbiAgICAgICAgc3dpdGNoIChSb3V0ZVN0b3JlLmdldFRlYW1JZCgpKSB7XG4gICAgICAgICAgICBjYXNlICdzY2llbmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gPFNjaWVuY2VUYXNrIGFwcHN0YXRlPXt0aGlzLnN0YXRlfS8+O1xuICAgICAgICAgICAgY2FzZSAnYXN0cm9uYXV0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gPEFzdHJvbmF1dFRhc2sgYXBwc3RhdGU9e3RoaXMuc3RhdGV9Lz47XG4gICAgICAgICAgICBjYXNlICdjb21tdW5pY2F0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gPENvbW11bmljYXRpb25UYXNrIGFwcHN0YXRlPXt0aGlzLnN0YXRlfS8+O1xuICAgICAgICAgICAgY2FzZSAnc2VjdXJpdHknOlxuICAgICAgICAgICAgICAgIHJldHVybiA8U2VjdXJpdHlUYXNrIGFwcHN0YXRlPXt0aGlzLnN0YXRlfS8+O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oYW5kbGVUYXNrT0tDbGljaygpe1xuICAgICAgICAgZ2V0TWlzc2lvbkFDKCkudGFza0NvbXBsZXRlZCggUm91dGVTdG9yZS5nZXRUZWFtSWQoKSwgIHRoaXMuc3RhdGUudGFza1N0b3JlLmN1cnJlbnRUYXNrSWQpO1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5fY3JlYXRlU3ViVGFza1VJKCksXG4gICAgICAgICAgICBibGluayA9IHRoaXMuc3RhdGUudGFza0lzTmV3ID8gJ2JsaW5rJyA6ICcnLFxuICAgICAgICAgICAgdGVhbU5hbWVzLCBtaXNzaW9uVGltZXI7XG5cblxuICAgICAgICB0ZWFtTmFtZXMgPSAoXG4gICAgICAgICAgICA8ZGl2IGlkPSd0ZWFtLW5hbWUnIGNsYXNzTmFtZT0nJz5cbiAgICAgICAgICAgICAgICA8aGVhZGVyIGNsYXNzTmFtZT0nJz5cbiAgICAgICAgICAgICAgICAgICAgPFRlYW1EaXNwbGF5ZXIgY2xhc3NOYW1lPScnLz5cbiAgICAgICAgICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgICAgIDwvZGl2Pik7XG5cbiAgICAgICAgbWlzc2lvblRpbWVyID0gKFxuICAgICAgICAgICAgPHNlY3Rpb24gaWQ9J21pc3Npb24tdGltZXInIGNsYXNzTmFtZT0nJz5cbiAgICAgICAgICAgICAgICA8TWlzc2lvblRpbWVyIC8+XG4gICAgICAgICAgICA8L3NlY3Rpb24+ICk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLmlzTWlzc2lvblJ1bm5pbmcpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGlkOiAnbm90X3VzZWQnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdJa2tlIGtsYXIuIFZlbnRlciBww6UgYXQgb3BwZHJhZ2V0IHNrYWwgc3RhcnRlLicsXG4gICAgICAgICAgICAgICAgbGV2ZWw6ICdpbmZvJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICB7IHRlYW1OYW1lcyB9XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TWVzc2FnZUxpc3QgY2xhc3NOYW1lPSdjb2wteHMtMTInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM9e1ttZXNzYWdlXX0vPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPScnPlxuICAgICAgICAgICAgICAgIHt0ZWFtTmFtZXN9XG4gICAgICAgICAgICAgICAge21pc3Npb25UaW1lcn1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICA8TWVzc2FnZUxpc3QgY2xhc3NOYW1lPSdjb2wteHMtMTInIG1lc3NhZ2VzPXt0aGlzLnN0YXRlLm1lc3NhZ2VzfS8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICB7IC8qIGlmIHlvdSB3YW50IHRoaXMgdG8gYmUgc3RpY2t5OiBodHRwOi8vY29kZXBlbi5pby9zZW5mZi9wZW4vYXlHdkQgKi8gfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTEyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nanVtYm90cm9uIHRhc2tib3gnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9J3Rhc2tib3hfX2hlYWRlcic+T3BwZ2F2ZTwvaDI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXsndGFza2JveF9fdGV4dCAnICsgYmxpbmt9PiB7dGhpcy5zdGF0ZS50YXNrU3RvcmUuY3VycmVudFRhc2t9IDwvc3Bhbj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGhpcy5zdGF0ZS50YXNrU3RvcmUucGxhaW5JbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4tcHJpbWFyeSBidG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17IHRoaXMuX2hhbmRsZVRhc2tPS0NsaWNrIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPk9LPC9idXR0b24+IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYXNrO1xuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgUm91dGVTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9yb3V0ZS1zdG9yZScpO1xuY29uc3QgdGVhbU5hbWVzID0gcmVxdWlyZSgnLi4vdGVhbS1uYW1lLW1hcCcpO1xuXG5jb25zdCBUZWFtV2lkZ2V0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgY29udGV4dFR5cGVzOiB7XG4gICAgICAgIHJvdXRlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXSxcblxuICAgIF9vbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvL1JvdXRlU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvL1JvdXRlU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuXG4gICAgfSxcblxuICAgIHRlYW1OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGVhbU5hbWVzLm5hbWVNYXBbKFJvdXRlU3RvcmUuZ2V0VGVhbUlkKCkpXTtcbiAgICB9LFxuXG4gICAgb3RoZXJUZWFtTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0ZWFtTmFtZXMub3RoZXJUZWFtTmFtZXMoUm91dGVTdG9yZS5nZXRUZWFtSWQoKSk7XG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZSA9IHsgdGhpcy5wcm9wcy5jbGFzc05hbWUgKyAnIHRlYW13aWRnZXQnfSA+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZSA9ICdhY3RpdmUnID57IHRoaXMudGVhbU5hbWUoKSAgfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lID0gJyc+LCB7IHRoaXMub3RoZXJUZWFtTmFtZXMoKSB9IDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZWFtV2lkZ2V0O1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKSxcbiAgICBhY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9UaW1lckFjdGlvbkNyZWF0b3JzJyksXG4gICAgVGltZXIgPSByZXF1aXJlKCcuL3RpbWVyLnJlYWN0LmpzJyksXG4gICAgVGltZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy90aW1lci1zdG9yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICB0aW1lcklkOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGltZXJTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICBUaW1lclN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuX2hhbmRsZVRpbWVTdG9yZUNoYW5nZSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFRpbWVyU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlVGltZVN0b3JlQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXh0U3RhdGUudGltZUluU2Vjb25kcyAhPT0gdGhpcy5zdGF0ZS50aW1lSW5TZWNvbmRzO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ1RpbWVyUGFuZWwuY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVUaW1lU3RvcmVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fZ2V0VGltZXJTdGF0ZSgpKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZUNsaWNrKCkge1xuICAgICAgICBhY3Rpb25zLnN0YXJ0VGltZXIodGhpcy5wcm9wcy50aW1lcklkKTtcbiAgICB9LFxuXG4gICAgX2dldFRpbWVyU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFkeTogVGltZXJTdG9yZS5pc1JlYWR5VG9TdGFydCh0aGlzLnByb3BzLnRpbWVySWQpLFxuICAgICAgICAgICAgdGltZUluU2Vjb25kczogVGltZXJTdG9yZS5nZXRSZW1haW5pbmdUaW1lKHRoaXMucHJvcHMudGltZXJJZClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPXtcInRpbWVyIFwiICsgdGhpcy5wcm9wcy5jbGFzc05hbWUgfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd0aW1lci0tYnV0dG9uIGNvbC14cy01ICc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXsgJ2J0biBidG4tcHJpbWFyeSAnICsgKHRoaXMuc3RhdGUucmVhZHkgPyAnJyA6ICdkaXNhYmxlZCcgKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9PlN0YXJ0IGtsb2trYVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ndGltZXItLXZhbHVlIGNvbC14cy02IHBhZGRpbmcteHMtMSc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VGltZXIgdGltZUluU2Vjb25kcz17dGhpcy5zdGF0ZS50aW1lSW5TZWNvbmRzfS8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICApO1xuICAgIH1cbn0pIiwiLy8gVGhpcyBleGFtcGxlIGNhbiBiZSBtb2RpZmllZCB0byBhY3QgYXMgYSBjb3VudGRvd24gdGltZXJcblxuXG5jb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0JyksXG4gICAgcHJpbnRmID0gcmVxdWlyZSgncHJpbnRmJyk7XG5cbmZ1bmN0aW9uIHBhZChudW0pIHtcbiAgICByZXR1cm4gcHJpbnRmKCclMDJkJywgbnVtKTtcbn1cblxuXG5jb25zdCBUaW1lciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICB0aW1lSW5TZWNvbmRzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdUaW1lci5jb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICB9LFxuXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXh0UHJvcHMudGltZUluU2Vjb25kcyAhPT0gdGhpcy5wcm9wcy50aW1lSW5TZWNvbmRzO1xuICAgIH0sXG5cbiAgICBfbWludXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHBhZChNYXRoLm1heCgwLCB0aGlzLnByb3BzLnRpbWVJblNlY29uZHMpIC8gNjAgPj4gMCk7XG4gICAgfSxcblxuICAgIF9zZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gcGFkKE1hdGgubWF4KDAsIHRoaXMucHJvcHMudGltZUluU2Vjb25kcykgJSA2MCk7XG4gICAgfSxcblxuICAgIF90aW1lVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taW51dGVzKCkgKyAnOicgKyB0aGlzLl9zZWNvbmRzKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd0aW1lci12YWx1ZSc+IHt0aGlzLl90aW1lVmFsdWUoKX08L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lcjtcblxuIiwid2luZG93Ll9fYXN0Q29uc3QgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnR09PRF9PWFlHRU4nOiAnR09PRF9PWFlHRU4nLFxuICAgICdXQVJOX09YWUdFTic6ICdXQVJOX09YWUdFTicsXG4gICAgJ0NSSVRJQ0FMX09YWUdFTic6ICdDUklUSUNBTF9PWFlHRU4nLFxuICAgIFwiTE9XX1JFU1BfUkFURVwiOiAnTE9XX1JFU1BfUkFURScsXG4gICAgJ0hJR0hfUkVTUF9SQVRFJzogJ0hJR0hfUkVTUF9SQVRFJyxcblxuICAgIC8qIHJlbW92ZT8gZG9uJ3QgdGhpbmsgdGhleSBhcmUgdXNlZCAqL1xuICAgIFNFVF9IRUFSVF9SQVRFOiAnU0VUX0hFQVJUX1JBVEUnLFxuICAgIFNFVF9PWFlHRU5fTEVWRUwgOiAnU0VUX09YWUdFTl9MRVZFTCcsXG4gICAgU0VUX09YWUdFTl9DT05TVU1QVElPTiA6ICdTRVRfT1hZR0VOX0NPTlNVTVBUSU9OJyxcblxuICAgIEhFQVJUX1JBVEVfVElNRVIgOiAnSEVBUlRfUkFURV9USU1FUicsXG4gICAgUkVTUElSQVRJT05fVElNRVIgOiAnUkVTUElSQVRJT05fVElNRVInXG59OyIsIm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLy8gZXZlbnRzXG4gICAgTUVTU0FHRV9BRERFRDogJ01FU1NBR0VfQURERUQnLFxuICAgIFJFTU9WRV9NRVNTQUdFOiAnUkVNT1ZFX01FU1NBR0UnXG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncmVhY3QvbGliL2tleU1pcnJvcicpKHtcbiAgICBNSVNTSU9OX1RJTUVfU1lOQzogJ01JU1NJT05fVElNRV9TWU5DJyxcbiAgICBNSVNTSU9OX1NUQVJURURfRVZFTlQ6ICdNSVNTSU9OX1NUQVJURURfRVZFTlQnLFxuICAgIE1JU1NJT05fU1RPUFBFRF9FVkVOVDogJ01JU1NJT05fU1RPUFBFRF9FVkVOVCcsXG4gICAgTUlTU0lPTl9DT01QTEVURURfRVZFTlQ6ICdNSVNTSU9OX0NPTVBMRVRFRF9FVkVOVCcsXG4gICAgTUlTU0lPTl9XQVNfUkVTRVQ6ICdNSVNTSU9OX1dBU19SRVNFVCcsXG4gICAgUkVDRUlWRURfRVZFTlRTOiBudWxsLFxuICAgIElOVFJPRFVDVElPTl9SRUFEOiAnSU5UUk9EVUNUSU9OX1JFQUQnLFxuICAgIFNUQVJUX1RBU0s6ICdTVEFSVF9UQVNLJyxcbiAgICBDT01QTEVURURfVEFTSyA6ICdDT01QTEVURURfVEFTSycsXG4gICAgQVNLX0ZPUl9BUFBfU1RBVEU6ICdBU0tfRk9SX0FQUF9TVEFURScsXG4gICAgUkVDRUlWRURfQVBQX1NUQVRFOiAnUkVDRUlWRURfQVBQX1NUQVRFJyxcbiAgICBTRU5ESU5HX1RFQU1fU1RBVEU6ICdTRU5ESU5HX1RFQU1fU1RBVEUnXG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLy8gZXZlbnRzXG4gICAgUk9VVEVfQ0hBTkdFRF9FVkVOVDogJ1JPVVRFX0NIQU5HRURfRVZFTlQnLFxuICAgIFJPVVRFUl9BVkFJTEFCTEU6ICdST1VURVJfQVZBSUxBQkxFJyxcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvLyBpZHNcbiAgICBTQ0lFTkNFX1RJTUVSXzE6ICdTQ0lFTkNFX1RJTUVSXzEnLFxuICAgIFNDSUVOQ0VfUkFESUFUSU9OX1dBUk5JTkdfTVNHIDogJ1NDSUVOQ0VfUkFESUFUSU9OX1dBUk5JTkdfTVNHJyxcblxuICAgIFNDSUVOQ0VfQ0xFQVJfUkFESUFUSU9OX1NBTVBMRVM6J1NDSUVOQ0VfQ0xFQVJfUkFESUFUSU9OX1NBTVBMRVMnLFxuXG4gICAgLy8gZXZlbnRzXG4gICAgU0NJRU5DRV9DT1VOVERPV05fVElNRVJfQ0hBTkdFRDogJ1NDSUVOQ0VfQ09VTlRET1dOX1RJTUVSX0NIQU5HRUQnLFxuICAgIFNDSUVOQ0VfVEFLRV9SQURJQVRJT05fU0FNUExFOiAnU0NJRU5DRV9UQUtFX1JBRElBVElPTl9TQU1QTEUnLFxuICAgIFNDSUVOQ0VfUkFESUFUSU9OX0xFVkVMX0NIQU5HRUQ6ICdTQ0lFTkNFX1JBRElBVElPTl9MRVZFTF9DSEFOR0VEJyxcbiAgICBTQ0lFTkNFX1RPVEFMX1JBRElBVElPTl9MRVZFTF9DSEFOR0VEOiAnU0NJRU5DRV9UT1RBTF9SQURJQVRJT05fTEVWRUxfQ0hBTkdFRCcsXG4gICAgU0NJRU5DRV9BVkdfUkFESUFUSU9OX0NBTENVTEFURUQ6ICdTQ0lFTkNFX0FWR19SQURJQVRJT05fQ0FMQ1VMQVRFRCcsXG5cbiAgICAvLyB2YWx1ZXNcbiAgICBTQ0lFTkNFX1JBRElBVElPTl9NSU46IDAsXG4gICAgU0NJRU5DRV9SQURJQVRJT05fTUFYOiAxMDAsXG4gICAgU0NJRU5DRV9BVkdfUkFEX0dSRUVOX1ZBTFVFOiAwLFxuICAgIFNDSUVOQ0VfQVZHX1JBRF9PUkFOR0VfVkFMVUU6IDE1LFxuICAgIFNDSUVOQ0VfQVZHX1JBRF9SRURfVkFMVUU6IDUwLFxuICAgIFNDSUVOQ0VfQVZHX1JBRF9PUkFOR0VfVEhSRVNIT0xEOiA0MCxcbiAgICBTQ0lFTkNFX0FWR19SQURfUkVEX1RIUkVTSE9MRDogNzUsXG4gICAgU0NJRU5DRV9UT1RBTF9SQURJQVRJT05fU0VSSU9VU19USFJFU0hPTEQ6IDUwLFxuICAgIFNDSUVOQ0VfVE9UQUxfUkFESUFUSU9OX1ZFUllfU0VSSU9VU19USFJFU0hPTEQ6IDc1XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFNFVF9USU1FUjogJ1NFVF9USU1FUicsXG4gICAgU1RBUlRfVElNRVI6ICdTVEFSVF9USU1FUicsXG4gICAgU1RPUF9USU1FUjogJ1NUT1BfVElNRVInLFxuICAgIFJFU0VUX1RJTUVSOiAnUkVTRVRfVElNRVInXG59O1xuXG4iLCIvLyBwcm94eSBhY2Nlc3MgdG8gdGhlIHJvdXRlciBhcyBmaXJzdCBzdGVwIGluIGJyaW5naW5nIGl0IGludG8gdGhlIGZsdXggZmxvd1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmFja3QvcmVhY3Qtcm91dGVyL2Jsb2IvbWFzdGVyL2RvY3MvZ3VpZGVzL2ZsdXgubWRcblxudmFyIHJvdXRlciA9IG51bGw7XG5cbndpbmRvdy5fX3JvdXRlciA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRyYW5zaXRpb25Ubyh0byxwYXJhbXMscXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlci50cmFuc2l0aW9uVG8odG8scGFyYW1zLHF1ZXJ5KVxuICAgIH0sXG5cbiAgICBnZXRDdXJyZW50UGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSxcblxuICAgIGdldFRlYW1JZCgpe1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFBhdGhuYW1lKCkuc3BsaXQoJy8nKVsxXTtcbiAgICB9LFxuXG4gICAgZ2V0VGFza0lkKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRQYXRobmFtZSgpLnNwbGl0KCcvJylbM107XG4gICAgfSxcblxuICAgIHJ1biguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXIucnVuKC4uLmFyZ3MpXG4gICAgfVxufTtcblxuY29uc3QgUm91dGVyID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyk7XG5jb25zdCByb3V0ZXMgPSByZXF1aXJlKCcuL3JvdXRlcy5yZWFjdCcpO1xuXG4vLyBCeSB0aGUgdGltZSByb3V0ZSBjb25maWcgaXMgcmVxdWlyZSgpLWQsXG4vLyByZXF1aXJlKCcuL3JvdXRlcicpIGFscmVhZHkgcmV0dXJucyBhIHZhbGlkIG9iamVjdFxuXG5yb3V0ZXIgPSBSb3V0ZXIuY3JlYXRlKHtcbiAgICByb3V0ZXM6IHJvdXRlcyxcblxuICAgIC8vIFVzZSB0aGUgSFRNTDUgSGlzdG9yeSBBUEkgZm9yIGNsZWFuIFVSTHNcbiAgICBsb2NhdGlvbjogUm91dGVyLkhpc3RvcnlMb2NhdGlvblxufSk7XG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbmNvbnN0IFJvdXRlID0gUm91dGVyLlJvdXRlO1xuY29uc3QgTm90Rm91bmRSb3V0ZSA9IFJvdXRlci5Ob3RGb3VuZFJvdXRlO1xuY29uc3QgRGVmYXVsdFJvdXRlID0gUm91dGVyLkRlZmF1bHRSb3V0ZTtcblxuY29uc3QgQXBwID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2FwcC5yZWFjdCcpO1xuY29uc3QgTWlzc2lvbkNvbW1hbmRlckFwcCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9taXNzaW9uLWNvbW1hbmRlci5yZWFjdC5qcycpO1xuY29uc3QgSW5kZXhBcHAgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvaW5kZXgtYXBwLnJlYWN0Jyk7XG5jb25zdCBOb3RGb3VuZCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9ub3QtZm91bmQucmVhY3QnKTtcbmNvbnN0IEludHJvU2NyZWVuID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2ludHJvZHVjdGlvbi1zY3JlZW4ucmVhY3QnKTtcbmNvbnN0IFNvbGFyU3Rvcm0gPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvZnVsbC1zY3JlZW4tdmlkZW8uanMnKTtcbmNvbnN0IFRhc2sgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvdGFzay5yZWFjdCcpO1xuY29uc3QgRHVtbXlSZW5kZXJNaXhpbiA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9kdW1teS1yZW5kZXIubWl4aW4nKTtcbmNvbnN0IHsgY2xlYW5Sb290UGF0aCB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgdGVhbU5hbWVNYXAgPSByZXF1aXJlKCcuL3RlYW0tbmFtZS1tYXAnKTtcblxuY29uc3QgUmVkaXJlY3RUb0ludHJvID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgc3RhdGljczoge1xuICAgICAgICB3aWxsVHJhbnNpdGlvblRvKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciB0ZWFtSWQgPSBjbGVhblJvb3RQYXRoKHRyYW5zaXRpb24ucGF0aCk7XG5cbiAgICAgICAgICAgIGlmKHRlYW1JZCBpbiB0ZWFtTmFtZU1hcC5uYW1lTWFwKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5yZWRpcmVjdCh0cmFuc2l0aW9uLnBhdGggKyAnL2ludHJvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy9taXhpbnMgOiBbRHVtbXlSZW5kZXJNaXhpbl1cbiAgICByZW5kZXIoKXtcbiAgICAgICAgcmV0dXJuIDxOb3RGb3VuZCAvPjtcbiAgICB9XG59KTtcblxuY29uc3Qgcm91dGVzID0gKFxuICAgIDxSb3V0ZSBuYW1lPVwiYXBwXCIgcGF0aD1cIi9cIiBoYW5kbGVyPXtBcHB9PlxuXG4gICAgICAgIDxSb3V0ZSBuYW1lPVwiam9iLWNvbXBsZXRlZFwiIHBhdGg9Jy9jb21wbGV0ZWQnIGhhbmRsZXI9e1NvbGFyU3Rvcm19IC8+XG5cbiAgICAgICAgPFJvdXRlIG5hbWU9XCJjb21tYW5kZXJcIiBoYW5kbGVyPXtNaXNzaW9uQ29tbWFuZGVyQXBwfS8+XG4gICAgICAgIDxSb3V0ZSBuYW1lPVwidGVhbS1yb290XCIgcGF0aD0nLzp0ZWFtSWQnIGhhbmRsZXI9e1JlZGlyZWN0VG9JbnRyb30gLz5cbiAgICAgICAgPFJvdXRlIG5hbWU9XCJ0ZWFtLWludHJvXCIgcGF0aD0nLzp0ZWFtSWQvaW50cm8nIGhhbmRsZXI9e0ludHJvU2NyZWVufSAvPlxuICAgICAgICA8Um91dGUgbmFtZT1cInRlYW0tdGFza1wiIHBhdGg9Jy86dGVhbUlkL3Rhc2svOnRhc2tJZCcgaGFuZGxlcj17VGFza30gLz5cblxuICAgICAgICA8Tm90Rm91bmRSb3V0ZSBoYW5kbGVyPXtOb3RGb3VuZH0vPlxuICAgICAgICA8RGVmYXVsdFJvdXRlIGhhbmRsZXI9e0luZGV4QXBwfS8+XG4gICAgPC9Sb3V0ZT5cbik7XG5cbm1vZHVsZS5leHBvcnRzID0gcm91dGVzO1xuIiwiY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCAgQ0hBTkdFX0VWRU5UPSAnQ0hBTkdFX0VWRU5UJztcblxudmFyIHBhdGggPSBudWxsO1xuXG5jbGFzcyBCYXNlU3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gICAgZW1pdENoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyBlbWl0dGVyLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cbiAgICAgKi9cbiAgICBhZGRDaGFuZ2VMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihDSEFOR0VfRVZFTlQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIGVtaXR0ZXIsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgICAqL1xuICAgIHJlbW92ZUNoYW5nZUxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUxpc3RlbmVyKENIQU5HRV9FVkVOVCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGRpc3BhdGNoZXJJbmRleDpOdW1iZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVN0b3JlO1xuIiwiY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IE1Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgQXN0Q29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL0FzdHJvVGVhbUNvbnN0YW50cycpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5cbnZhciBjdXJyZW50ID0gQXN0Q29uc3RhbnRzLkxPV19SRVNQX1JBVEU7XG5cbmNvbnN0IEJyZWF0aFJhdGVTdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlLCB7XG5cbiAgICBnZXRTdGF0ZSgpe1xuICAgICAgICBpZiAoY3VycmVudCA9PSBBc3RDb25zdGFudHMuTE9XX1JFU1BfUkFURSkge1xuICAgICAgICAgICAgcmV0dXJuIHtyYXRlOiBjdXJyZW50LCBtaW46IDIzLCBtYXg6IDI4fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7cmF0ZTogY3VycmVudCwgbWluOiA0NSwgbWF4OiA1NX1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IERpc3BhdGNoZXIucmVnaXN0ZXIoKHBheWxvYWQpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1Db25zdGFudHMuUkVDRUlWRURfQVBQX1NUQVRFOlxuICAgICAgICAgICAgICAgIHZhciBhcHBTdGF0ZSA9IHBheWxvYWQuYXBwU3RhdGU7XG5cbiAgICAgICAgICAgICAgICBpZihhcHBTdGF0ZS5icmVhdGhfcmF0ZSA9PT0gJ2hpZ2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBBc3RDb25zdGFudHMuSElHSF9SRVNQX1JBVEU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IEFzdENvbnN0YW50cy5MT1dfUkVTUF9SQVRFO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEJyZWF0aFJhdGVTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KVxufSk7XG4iLCJjb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgTWlzc2lvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5jb25zdCBCYXNlU3RvcmUgPSByZXF1aXJlKCcuL2Jhc2Utc3RvcmUnKTtcblxudmFyIGxldmVsID0gMDtcbnZhciBmaWx0ZXJDaGFuZ2VkID0gZmFsc2U7XG5cbmNvbnN0IENPMlN0b3JlID0gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlU3RvcmUsIHtcblxuICAgIGNvMkxldmVsKCl7XG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9LFxuXG4gICAgZmlsdGVyQ2hhbmdlZCgpe1xuICAgICAgICByZXR1cm4gZmlsdGVyQ2hhbmdlZDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hlckluZGV4OiBEaXNwYXRjaGVyLnJlZ2lzdGVyKChwYXlsb2FkKSA9PiB7XG5cbiAgICAgICAgc3dpdGNoIChwYXlsb2FkLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBNaXNzaW9uQ29uc3RhbnRzLlJFQ0VJVkVEX0FQUF9TVEFURTpcbiAgICAgICAgICAgICAgICB2YXIgYXBwU3RhdGUgPSBwYXlsb2FkLmFwcFN0YXRlO1xuXG4gICAgICAgICAgICAgICAgbGV2ZWwgPSBhcHBTdGF0ZS5jYXJib25fZGlveGlkZTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJDaGFuZ2VkID0gYXBwU3RhdGUuc2NydWJfZmlsdGVyX2NoYW5nZWQ7XG4gICAgICAgICAgICAgICAgQ08yU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSlcbn0pO1xuIiwiY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IE1pc3Npb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG52YXIgcXVhbGl0eVNob3VsZEZhaWwgPSB0cnVlO1xudmFyIHRyYW5zZmVyU2hvdWxkRmFpbCA9IHRydWU7XG52YXIgX3JlYWR5Rm9yU2FmZU1vZGUgPSBmYWxzZTtcblxudmFyIENvbW11bmljYXRpb25RdWFsaXR5U3RvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSgpLCB7XG5cbiAgICBxdWFsaXR5VGVzdFNob3VsZEZhaWwoKSB7XG4gICAgICAgIHJldHVybiBxdWFsaXR5U2hvdWxkRmFpbDtcbiAgICB9LFxuXG4gICAgdHJhbnNmZXJUZXN0U2hvdWxkKCl7XG4gICAgICAgIHJldHVybiB0cmFuc2ZlclNob3VsZEZhaWw7XG4gICAgfSxcblxuICAgIHJlYWR5Rm9yU2FmZU1vZGUoKXtcbiAgICAgICAgcmV0dXJuIF9yZWFkeUZvclNhZmVNb2RlO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IEFwcERpc3BhdGNoZXIucmVnaXN0ZXIoKHBheWxvYWQpPT4ge1xuXG4gICAgICAgIGlmIChwYXlsb2FkLmFjdGlvbiA9PT0gTWlzc2lvbkNvbnN0YW50cy5SRUNFSVZFRF9BUFBfU1RBVEUpIHtcbiAgICAgICAgICAgIHF1YWxpdHlTaG91bGRGYWlsID0gcGF5bG9hZC5hcHBTdGF0ZS5xdWFsaXR5X3Rlc3Rfc2hvdWxkX2ZhaWw7XG4gICAgICAgICAgICB0cmFuc2ZlclNob3VsZEZhaWwgPSBwYXlsb2FkLmFwcFN0YXRlLnRyYW5zZmVyX3Rlc3Rfc2hvdWxkX2ZhaWw7XG4gICAgICAgICAgICBfcmVhZHlGb3JTYWZlTW9kZSA9IHBheWxvYWQuYXBwU3RhdGUucmVhZHlfZm9yX3NhZmVfbW9kZTtcblxuICAgICAgICAgICAgQ29tbXVuaWNhdGlvblF1YWxpdHlTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9KVxufSk7IiwiY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IE1Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5cbnZhciBldmVudHNDb2xsZWN0aW9uID0ge1xuICAgIHJlbWFpbmluZzogW10sXG4gICAgY29tcGxldGVkOiBbXSxcbiAgICBvdmVyZHVlOiBbXVxufTtcblxuY29uc3QgRXZlbnRTdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gd2luZG93Ll9fZXZlbnRTdG9yZSA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSwge1xuXG4gICAgcmVtYWluaW5nKCkgeyByZXR1cm4gZXZlbnRzQ29sbGVjdGlvbi5yZW1haW5pbmc7IH0sXG5cbiAgICBjb21wbGV0ZWQoKSB7IHJldHVybiBldmVudHNDb2xsZWN0aW9uLmNvbXBsZXRlZDsgfSxcblxuICAgIG92ZXJkdWUoKSB7IHJldHVybiBldmVudHNDb2xsZWN0aW9uLm92ZXJkdWU7IH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IERpc3BhdGNoZXIucmVnaXN0ZXIoKHBheWxvYWQpID0+IHtcblxuICAgICAgICBzd2l0Y2gocGF5bG9hZC5hY3Rpb24pe1xuXG4gICAgICAgICAgICBjYXNlIE1Db25zdGFudHMuUkVDRUlWRURfRVZFTlRTOlxuICAgICAgICAgICAgICAgIGV2ZW50c0NvbGxlY3Rpb24ucmVtYWluaW5nID0gcGF5bG9hZC5yZW1haW5pbmc7XG4gICAgICAgICAgICAgICAgZXZlbnRzQ29sbGVjdGlvbi5vdmVyZHVlID0gcGF5bG9hZC5vdmVyZHVlO1xuICAgICAgICAgICAgICAgIGV2ZW50c0NvbGxlY3Rpb24uY29tcGxldGVkID0gcGF5bG9hZC5jb21wbGV0ZWQ7XG4gICAgICAgICAgICAgICAgRXZlbnRTdG9yZS5lbWl0Q2hhbmdlKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pXG59KTtcblxuXG4vL3dpbmRvdy5fX2V2ZW50U3RvcmUgPSBtb2R1bGUuZXhwb3J0cztcbiIsImNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBNQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL01pc3Npb25Db25zdGFudHMnKTtcbmNvbnN0IEFzdENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9Bc3Ryb1RlYW1Db25zdGFudHMnKTtcbmNvbnN0IEJhc2VTdG9yZSA9IHJlcXVpcmUoJy4vYmFzZS1zdG9yZScpO1xuXG52YXIgY3VycmVudCA9IHttaW46IDYwLCBtYXg6IDcwfTtcblxuY29uc3QgSGVhcnRSYXRlU3RvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSwge1xuXG4gICAgLy8gb20gdmkgdmlsIGJhY2tlIG9wcCB2ZXJkaWVyIHDDpSBzZXJ2ZXIgbcOlIHZpIGJydWtlIGRlbm5lIHN0b3JlblxuICAgIGdldFN0YXRlKCl7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IERpc3BhdGNoZXIucmVnaXN0ZXIoKHBheWxvYWQpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1Db25zdGFudHMuUkVDRUlWRURfQVBQX1NUQVRFOlxuICAgICAgICAgICAgICAgIHZhciByYXRlID0gcGF5bG9hZC5hcHBTdGF0ZS5oZWFydF9yYXRlO1xuICAgICAgICAgICAgICAgIGlmIChyYXRlICYmIHJhdGUubWluICYmIHJhdGUubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByYXRlO1xuICAgICAgICAgICAgICAgICAgICBIZWFydFJhdGVTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSlcbn0pO1xuIiwiLyogSG9sZHMgdGhlIHN0YXRlIG9mIHdoZXRoZXIgaW50cm9kdWN0aW9ucyBoYXZlIGJlZW4gcmVhZCAqL1xuXG5jb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5jb25zdCBNaXNzaW9uQ29uc3RhbnRzPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgUm91dGVTdG9yZSA9IHJlcXVpcmUoJy4vcm91dGUtc3RvcmUnKTtcblxudmFyIGludHJvUmVhZCA9IHt9O1xuXG5jb25zdCBJbnRyb2R1Y3Rpb25TdG9yZSA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSgpLCB7XG5cbiAgICBzZXRJbnRyb2R1Y3Rpb25SZWFkKHRlYW0pIHtcbiAgICAgICAgaW50cm9SZWFkWydpbnRyb18nK3RlYW1dID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIGlzSW50cm9kdWN0aW9uUmVhZCh0ZWFtKSB7XG4gICAgICAgIGlmKCF0ZWFtKSB7IHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhcmd1bWVudCBcInRlYW1cIicpOyB9XG5cbiAgICAgICAgcmV0dXJuIGludHJvUmVhZFsnaW50cm9fJyt0ZWFtXTtcbiAgICB9LFxuXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IEFwcERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHBheWxvYWQuYWN0aW9uO1xuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuSU5UUk9EVUNUSU9OX1JFQUQ6XG4gICAgICAgICAgICAgICAgSW50cm9kdWN0aW9uU3RvcmUuc2V0SW50cm9kdWN0aW9uUmVhZChwYXlsb2FkLnRlYW1OYW1lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBNaXNzaW9uQ29uc3RhbnRzLlJFQ0VJVkVEX0FQUF9TVEFURTpcbiAgICAgICAgICAgICAgICB2YXIgdGVhbUlkID0gUm91dGVTdG9yZS5nZXRUZWFtSWQoKTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZWFtU3RhdGUgPSBwYXlsb2FkLmFwcFN0YXRlW3RlYW1JZF07XG5cbiAgICAgICAgICAgICAgICBpZiAodGVhbVN0YXRlICYmIHRlYW1TdGF0ZS5pbnRyb2R1Y3Rpb25fcmVhZCApIHtcbiAgICAgICAgICAgICAgICAgICAgSW50cm9kdWN0aW9uU3RvcmUuc2V0SW50cm9kdWN0aW9uUmVhZCh0ZWFtU3RhdGUudGVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIGVycm9ycy4gTmVlZGVkIGJ5IHByb21pc2UgaW4gRGlzcGF0Y2hlci5cbiAgICB9KVxuXG59KTtcblxud2luZG93Ll9fSW50cm9kdWN0aW9uU3RvcmU9IEludHJvZHVjdGlvblN0b3JlO1xubW9kdWxlLmV4cG9ydHMgPSBJbnRyb2R1Y3Rpb25TdG9yZTtcbiIsIi8qIEEgc3RvcmUgdGhhdCBjYW4gYmUgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgcGF0aCAqL1xuXG5jb25zdCB7IEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IEJhc2VTdG9yZSA9IHJlcXVpcmUoJy4vYmFzZS1zdG9yZScpO1xuY29uc3QgeyBSRU1PVkVfTUVTU0FHRSwgTUVTU0FHRV9BRERFRCB9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL01lc3NhZ2VDb25zdGFudHMnKTtcbnZhciBtZXNzYWdlcyA9IHt9O1xuXG5cbnZhciBNZXNzYWdlU3RvcmUgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlU3RvcmUoKSwge1xuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIG1lc3NhZ2VzID0ge307XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH0sXG5cbiAgICBoYW5kbGVBZGRlZE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBkYXRhLmRpc21pc3NhYmxlID0gZGF0YS5kaXNtaXNzYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGRhdGEuZGlzbWlzc2FibGU7XG4gICAgICAgIG1lc3NhZ2VzW2RhdGEuaWRdID0gZGF0YTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIGhhbmRsZVJlbW92ZU1lc3NhZ2UoaWQpIHtcbiAgICAgICAgZGVsZXRlIG1lc3NhZ2VzW2lkXTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBhbGwgbWVzc2FnZXMgbWF0Y2hpbmcgZmlsdGVyXG4gICAgICogQHBhcmFtIFtmaWx0ZXJdXG4gICAgICogQHJldHVybnMgW11NZXNzYWdlIGEgTWVzc2FnZSA9IHsgdGV4dCwgaWQsIGxldmVsIH1cbiAgICAgKi9cbiAgICBnZXRNZXNzYWdlcyhmaWx0ZXIpIHtcbiAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtZXNzYWdlcykubWFwKChtc2dLZXkpPT4gIG1lc3NhZ2VzW21zZ0tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdVTklNUExFTUVOVEVEIFwiZmlsdGVyXCIgZmVhdHVyZScpO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IEFwcERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHsgYWN0aW9uLCBkYXRhIH0gPSBwYXlsb2FkO1xuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1FU1NBR0VfQURERUQ6XG4gICAgICAgICAgICAgICAgTWVzc2FnZVN0b3JlLmhhbmRsZUFkZGVkTWVzc2FnZShkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUkVNT1ZFX01FU1NBR0U6XG4gICAgICAgICAgICAgICAgTWVzc2FnZVN0b3JlLmhhbmRsZVJlbW92ZU1lc3NhZ2UoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gZXJyb3JzLiBOZWVkZWQgYnkgcHJvbWlzZSBpbiBEaXNwYXRjaGVyLlxuICAgIH0pXG5cbn0pO1xuXG53aW5kb3cuX19NZXNzYWdlU3RvcmUgPSBNZXNzYWdlU3RvcmU7XG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VTdG9yZTtcbiIsIi8qIEEgc3RvcmUgdGhhdCBjYW4gYmUgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgcGF0aCAqL1xuXG5jb25zdCB7IEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IEJhc2VTdG9yZSA9IHJlcXVpcmUoJy4vYmFzZS1zdG9yZScpO1xuY29uc3QgeyBNSVNTSU9OX1NUQVJURURfRVZFTlQsTUlTU0lPTl9TVE9QUEVEX0VWRU5ULCBSRUNFSVZFRF9BUFBfU1RBVEUgfSA9ICByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuXG52YXIgbWlzc2lvblJ1bm5pbmcgPSBmYWxzZSwgbWlzc2lvbkhhc0JlZW5TdG9wcGVkID0gZmFsc2U7XG52YXIgY3VycmVudENoYXB0ZXIgPSBudWxsO1xudmFyIGNoYXB0ZXJUaW1lID0gMDtcbnZhciBpblNhZmVNb2RlID0gZmFsc2U7XG5cbnZhciBNaXNzaW9uU3RhdGVTdG9yZSA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSgpLCB7XG5cbiAgICBoYW5kbGVNaXNzaW9uU3RhcnRlZCgpIHtcbiAgICAgICAgbWlzc2lvblJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlTWlzc2lvblN0b3BwZWQoKSB7XG4gICAgICAgIG1pc3Npb25SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH0sXG5cbiAgICBpc1NhdGVsbGl0ZUluU2FmZU1vZGUoKXtcbiAgICAgICAgcmV0dXJuIGluU2FmZU1vZGU7XG4gICAgfSxcblxuICAgIGlzTWlzc2lvblJ1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiBtaXNzaW9uUnVubmluZztcbiAgICB9LFxuXG4gICAgaXNNaXNzaW9uU3RvcHBlZCgpIHtcbiAgICAgICAgcmV0dXJuIG1pc3Npb25IYXNCZWVuU3RvcHBlZDtcbiAgICB9LFxuXG4gICAgY3VycmVudENoYXB0ZXIoKXtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGFwdGVyO1xuICAgIH0sXG5cbiAgICBjaGFwdGVyVGltZSgpe1xuICAgICAgICByZXR1cm4gY2hhcHRlclRpbWU7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgeyBhY3Rpb259ID0gcGF5bG9hZDtcblxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBNSVNTSU9OX1NUQVJURURfRVZFTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1pc3Npb25TdGF0ZVN0b3JlLmhhbmRsZU1pc3Npb25TdGFydGVkKCk7XG5cbiAgICAgICAgICAgIGNhc2UgTUlTU0lPTl9TVE9QUEVEX0VWRU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiBNaXNzaW9uU3RhdGVTdG9yZS5oYW5kbGVNaXNzaW9uU3RvcHBlZCgpO1xuXG4gICAgICAgICAgICBjYXNlIFJFQ0VJVkVEX0FQUF9TVEFURTpcbiAgICAgICAgICAgICAgICBsZXQgYXBwU3RhdGUgPSBwYXlsb2FkLmFwcFN0YXRlO1xuICAgICAgICAgICAgICAgIG1pc3Npb25SdW5uaW5nID0gYXBwU3RhdGUubWlzc2lvbl9ydW5uaW5nO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFwdGVyID0gYXBwU3RhdGUuY3VycmVudF9jaGFwdGVyO1xuICAgICAgICAgICAgICAgIGNoYXB0ZXJUaW1lID0gYXBwU3RhdGUuZWxhcHNlZF9jaGFwdGVyX3RpbWU7XG4gICAgICAgICAgICAgICAgaW5TYWZlTW9kZSA9IGFwcFN0YXRlLnNhdGVsbGl0ZV9pbl9zYWZlX21vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1pc3Npb25TdGF0ZVN0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBlcnJvcnMuIE5lZWRlZCBieSBwcm9taXNlIGluIERpc3BhdGNoZXIuXG4gICAgfSlcblxufSk7XG5cbndpbmRvdy5fX01pc3Npb25TdGF0ZVN0b3JlID0gTWlzc2lvblN0YXRlU3RvcmU7XG5tb2R1bGUuZXhwb3J0cyA9IE1pc3Npb25TdGF0ZVN0b3JlO1xuIiwiY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IE1pc3Npb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgQXN0Q29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL0FzdHJvVGVhbUNvbnN0YW50cycpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5cbnZhciBfc3RhdHVzID0gQXN0Q29uc3RhbnRzLkdPT0RfT1hZR0VOO1xudmFyIGNvbnN1bXB0aW9uUGVyTWludXRlID0gbnVsbDtcbnZhciByZW1haW5pbmcgPSAxMDA7XG5cbmNvbnN0IE94eWdlblN0b3JlID0gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlU3RvcmUsIHtcblxuICAgIHN0YXR1cygpe1xuICAgICAgICByZXR1cm4gX3N0YXR1cztcbiAgICB9LFxuXG4gICAgc3RhdHVzQXNDb2xvcigpe1xuICAgICAgICBzd2l0Y2ggKF9zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgQXN0Q29uc3RhbnRzLkNSSVRJQ0FMX09YWUdFTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JlZCc7XG4gICAgICAgICAgICBjYXNlIEFzdENvbnN0YW50cy5XQVJOX09YWUdFTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29yYW5nZSc7XG4gICAgICAgICAgICBjYXNlIEFzdENvbnN0YW50cy5HT09EX09YWUdFTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2dyZWVuJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFN0YXRlKCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xvckluZGljYXRvcjogdGhpcy5zdGF0dXNBc0NvbG9yKCksXG4gICAgICAgICAgICBjb25zdW1wdGlvblBlck1pbnV0ZTogY29uc3VtcHRpb25QZXJNaW51dGUsXG4gICAgICAgICAgICByZW1haW5pbmc6IHJlbWFpbmluZ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogRGlzcGF0Y2hlci5yZWdpc3RlcigocGF5bG9hZCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAocGF5bG9hZC5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5SRUNFSVZFRF9BUFBfU1RBVEU6XG4gICAgICAgICAgICAgICAgdmFyIGFwcFN0YXRlID0gcGF5bG9hZC5hcHBTdGF0ZTtcblxuICAgICAgICAgICAgICAgIGlmIChhcHBTdGF0ZS5veHlnZW5fY29uc3VtcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtcHRpb25QZXJNaW51dGUgPSBhcHBTdGF0ZS5veHlnZW5fY29uc3VtcHRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN1bXB0aW9uUGVyTWludXRlID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgX3N0YXR1cyAhPT0gQXN0Q29uc3RhbnRzLkNSSVRJQ0FMX09YWUdFTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXR1cyA9IEFzdENvbnN0YW50cy5XQVJOX09YWUdFTlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnN1bXB0aW9uUGVyTWludXRlIDwgMil7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdHVzID0gQXN0Q29uc3RhbnRzLkdPT0RfT1hZR0VOO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgT3h5Z2VuU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhcHBTdGF0ZS5veHlnZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gYXBwU3RhdGUub3h5Z2VuO1xuICAgICAgICAgICAgICAgICAgICBPeHlnZW5TdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSlcbn0pO1xuIiwiLyogQSBzaW5nbGV0b24gc3RvcmUgdGhhdCBjYW4gYmUgcXVlcmllZCBmb3IgcmVtYWluaW5nIHRpbWUgKi9cblxuY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IEJhc2VTdG9yZSA9IHJlcXVpcmUoJy4vYmFzZS1zdG9yZScpO1xuY29uc3QgU2NpZW5jZVRlYW1Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvU2NpZW5jZVRlYW1Db25zdGFudHMnKTtcbmNvbnN0IE1pc3Npb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgcmFuZG9tSW50ID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5yYW5kb21JbnQ7XG5jb25zdCByYWRpYXRpb25SYW5nZSA9IHtcbiAgICBtaW46IDUsXG4gICAgbWF4OiAyMFxufTtcbnZhciBzYW1wbGVzID0gW107XG52YXIgdG90YWxSYWRpYXRpb24gPSAwO1xudmFyIGxhc3RDYWxjdWxhdGVkQXZlcmFnZSA9IG51bGw7XG5cbmNvbnN0IFJhZGlhdGlvblN0b3JlID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlKCksIHtcblxuICAgIF9zZXRSYWRpYXRpb25MZXZlbChtaW4sIG1heCkge1xuICAgICAgICByYWRpYXRpb25SYW5nZS5taW4gPSBtaW47XG4gICAgICAgIHJhZGlhdGlvblJhbmdlLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIF9jbGVhclNhbXBsZXMoKSB7XG4gICAgICAgIHNhbXBsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIF90YWtlU2FtcGxlKCkge1xuICAgICAgICBzYW1wbGVzLnB1c2godGhpcy5nZXRMZXZlbCgpKTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIGdldExldmVsKCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tSW50KHJhZGlhdGlvblJhbmdlLm1pbiwgcmFkaWF0aW9uUmFuZ2UubWF4KTtcbiAgICB9LFxuXG4gICAgZ2V0VG90YWxMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRvdGFsUmFkaWF0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRTYW1wbGVzKCkge1xuICAgICAgICByZXR1cm4gc2FtcGxlcy5zbGljZSgpO1xuICAgIH0sXG5cbiAgICBnZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNhbXBsZXM6IHNhbXBsZXMuc2xpY2UoMCksXG4gICAgICAgICAgICB0b3RhbDogdG90YWxSYWRpYXRpb24sXG4gICAgICAgICAgICBjdXJyZW50TGV2ZWw6IHRoaXMuZ2V0TGV2ZWwoKSxcbiAgICAgICAgICAgIGxhc3RDYWxjdWxhdGVkQXZlcmFnZTogbGFzdENhbGN1bGF0ZWRBdmVyYWdlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hlckluZGV4OiBBcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciB7IGFjdGlvbiwgZGF0YX0gPSBwYXlsb2FkO1xuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfUkFESUFUSU9OX0xFVkVMX0NIQU5HRUQ6XG4gICAgICAgICAgICAgICAgUmFkaWF0aW9uU3RvcmUuX3NldFJhZGlhdGlvbkxldmVsKGRhdGEubWluLCBkYXRhLm1heCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfVE9UQUxfUkFESUFUSU9OX0xFVkVMX0NIQU5HRUQ6XG4gICAgICAgICAgICAgICAgdG90YWxSYWRpYXRpb24gPSBkYXRhLnRvdGFsO1xuICAgICAgICAgICAgICAgIFJhZGlhdGlvblN0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1RBS0VfUkFESUFUSU9OX1NBTVBMRTpcbiAgICAgICAgICAgICAgICBSYWRpYXRpb25TdG9yZS5fdGFrZVNhbXBsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX0FWR19SQURJQVRJT05fQ0FMQ1VMQVRFRDpcbiAgICAgICAgICAgICAgICBsYXN0Q2FsY3VsYXRlZEF2ZXJhZ2UgPSBkYXRhLmF2ZXJhZ2U7XG4gICAgICAgICAgICAgICAgUmFkaWF0aW9uU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX0NMRUFSX1JBRElBVElPTl9TQU1QTEVTOlxuICAgICAgICAgICAgICAgIHNhbXBsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBSYWRpYXRpb25TdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5SRUNFSVZFRF9BUFBfU1RBVEU6XG4gICAgICAgICAgICAgICAgbGV0IGFwcFN0YXRlID0gcGF5bG9hZC5hcHBTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaWF0aW9uTGV2ZWwgPSBhcHBTdGF0ZS5yYWRpYXRpb25fbGV2ZWw7XG5cbiAgICAgICAgICAgICAgICBSYWRpYXRpb25TdG9yZS5fc2V0UmFkaWF0aW9uTGV2ZWwocmFkaWF0aW9uTGV2ZWwubG93LHJhZGlhdGlvbkxldmVsLmhpZ2gpO1xuXG4gICAgICAgICAgICAgICAgaWYoYXBwU3RhdGUuc2NpZW5jZSAmJiBhcHBTdGF0ZS5zY2llbmNlLnJhZGlhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFkaWF0aW9uU3RhdGUgPSBhcHBTdGF0ZS5zY2llbmNlLnJhZGlhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcyA9IHJhZGlhdGlvblN0YXRlLnNhbXBsZXM7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDYWxjdWxhdGVkQXZlcmFnZSA9IHJhZGlhdGlvblN0YXRlLmxhc3RDYWxjdWxhdGVkQXZlcmFnZTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxSYWRpYXRpb24gPSByYWRpYXRpb25TdGF0ZS50b3RhbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBSYWRpYXRpb25TdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5NSVNTSU9OX1dBU19SRVNFVDpcbiAgICAgICAgICAgICAgICBzYW1wbGVzID0gW107XG4gICAgICAgICAgICAgICAgbGFzdENhbGN1bGF0ZWRBdmVyYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0b3RhbFJhZGlhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gZXJyb3JzLiBOZWVkZWQgYnkgcHJvbWlzZSBpbiBEaXNwYXRjaGVyLlxuICAgIH0pXG5cbn0pO1xuXG53aW5kb3cuX19SYWRpYXRpb25TdG9yZSA9IFJhZGlhdGlvblN0b3JlO1xubW9kdWxlLmV4cG9ydHMgPSBSYWRpYXRpb25TdG9yZTtcbiIsIi8qIEEgc3RvcmUgdGhhdCBjYW4gYmUgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgcGF0aCAqL1xuXG5jb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5jb25zdCB7IFJPVVRFX0NIQU5HRURfRVZFTlQgfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9Sb3V0ZXJDb25zdGFudHMnKTtcbmNvbnN0IHsgY2xlYW5Sb290UGF0aCB9PSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgcm91dGVyID0gcmVxdWlyZSgnLi4vcm91dGVyLWNvbnRhaW5lcicpXG5cbnZhciBSb3V0ZVN0b3JlID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlKCksIHtcblxuICAgIGhhbmRsZVJvdXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgZ2V0VGVhbUlkKCkge1xuICAgICAgICByZXR1cm4gcm91dGVyLmdldFRlYW1JZCgpO1xuICAgIH0sXG5cbiAgICBnZXRUYXNrSWQoKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXIuZ2V0VGFza0lkKCk7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gcGF5bG9hZC5hY3Rpb247XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgUk9VVEVfQ0hBTkdFRF9FVkVOVDpcbiAgICAgICAgICAgICAgICBSb3V0ZVN0b3JlLmhhbmRsZVJvdXRlQ2hhbmdlZChwYXlsb2FkLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBlcnJvcnMuIE5lZWRlZCBieSBwcm9taXNlIGluIERpc3BhdGNoZXIuXG4gICAgfSlcblxufSk7XG5cbndpbmRvdy5fX1JvdXRlU3RvcmUgPSBSb3V0ZVN0b3JlO1xubW9kdWxlLmV4cG9ydHMgPSBSb3V0ZVN0b3JlO1xuIiwiLyogQSBzdG9yZSB0aGF0IGNhbiBiZSBxdWVyaWVkIGZvciB0aGUgY3VycmVudCBwYXRoICovXG5cbmNvbnN0IEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBCYXNlU3RvcmUgPSByZXF1aXJlKCcuL2Jhc2Utc3RvcmUnKTtcbmNvbnN0IFJvdXRlU3RvcmUgPSByZXF1aXJlKCcuL3JvdXRlLXN0b3JlJyk7XG5jb25zdCBNaXNzaW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL01pc3Npb25Db25zdGFudHMnKTtcblxudmFyIGF3YWl0aW5nTmV3SW5zdHJ1Y3Rpb25zID0ge1xuICAgICd0ZXh0JzogJ1ZlbnRlciBww6UgbnllIGluc3RydWtzam9uZXIgLi4uJ1xufTtcblxudmFyIGFzc2lnbm1lbnRzID0ge1xuICAgIHNjaWVuY2U6IHtcbiAgICAgICAgY3VycmVudDogbnVsbCxcbiAgICAgICAgc2FtcGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiAnU3RhcnQga2xva2thIG9nIHRhIGZpcmUgbcOlbGluZ2VyIGpldm50IGZvcmRlbHQgdXRvdmVyIGRlIDMwIHNla3VuZGVuZScsXG4gICAgICAgICAgICBuZXh0OiAnYXZlcmFnZSdcbiAgICAgICAgfSxcbiAgICAgICAgYXZlcmFnZToge1xuICAgICAgICAgICAgdGV4dDogJ1JlZ24gdXQgZ2plbm5vbXNuaXR0c3ZlcmRpZW4gYXYgc3Ryw6VsaW5nc3ZlcmRpZW5lIGRlcmUgZmFudC4gU2tyaXYgZGVuIGlubiBpIHRla3N0ZmVsdGV0LicsXG4gICAgICAgICAgICBuZXh0OiAnYWRkdG90YWwnXG4gICAgICAgIH0sXG4gICAgICAgIGFkZHRvdGFsOiB7XG4gICAgICAgICAgICB0ZXh0OiAnQmFzZXJ0IHDDpSBmYXJnZW4gc29tIGJsZSBpbmRpa2VydCB2ZWQgZXZhbHVlcmluZyBhdiBnamVubm9tc25pdHRzdmVyZGllbiAnXG4gICAgICAgICAgICArICdza2FsIHZpIG7DpSBsZWdnZSB0aWwgZXQgdGFsbCB0aWwgdG90YWx0IGZ1bm5ldCBzdHLDpWxpbmdzbWVuZ2RlLidcbiAgICAgICAgICAgICsgJyBGb3IgZ3LDuG5uIHN0YXR1cyBtYW4gbGVnZ2UgdGlsIDAsICdcbiAgICAgICAgICAgICsgJyBmb3Igb3JhbnNqIHN0YXR1cyBtYW4gbGVnZ2UgdGlsIDE1LCAnXG4gICAgICAgICAgICArICcgZm9yIHLDuGQgc3RhdHVzIG1hbiBsZWdnZSB0aWwgNTAuJ1xuICAgICAgICAgICAgKyAnIERlbiB0b3RhbGUgc3Ryw6VsaW5nc3ZlcmRpZW4gaSBrcm9wcGVuIHNrYWwgaGVsc3QgaWtrZSBnw6Ugb3ZlciA1MCwgb2cgYWxkcmkgb3ZlciA3NSEnLFxuICAgICAgICAgICAgbmV4dDogJ2F3YWl0aW5nJ1xuICAgICAgICB9LFxuICAgICAgICBhd2FpdGluZzogYXdhaXRpbmdOZXdJbnN0cnVjdGlvbnNcbiAgICB9LFxuXG4gICAgYXN0cm9uYXV0OiB7XG4gICAgICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgICAgIGF3YWl0aW5nOiBhd2FpdGluZ05ld0luc3RydWN0aW9ucyxcbiAgICAgICAgYnJlYXRoaW5nX3RpbWVyOiB7XG4gICAgICAgICAgICB0ZXh0OiAnU3RhcnQga2xva2thLCBvZyB0ZWxsIGFudGFsbCBpbm5wdXN0ICh0b3BwZXIpIHDDpSBwdXN0ZWdyYWZlbi4nLFxuICAgICAgICAgICAgbmV4dDogJ2JyZWF0aGluZ19jYWxjdWxhdGUnLFxuICAgICAgICAgICAgcGxhaW5faW5mbzogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBicmVhdGhpbmdfY2FsY3VsYXRlOiB7XG4gICAgICAgICAgICB0ZXh0OiAnSHZvciBtYW5nZSBpbm5wdXN0IGJsaXIgZGV0IHDDpSBldHQgbWludXR0PyBCcnVrIHRhbGxldCBkdSBmaW5uZXIgdGlsIMOlIHJlZ25lIHV0IG9rc3lnZW5mb3JicnVrZXQgcHIgbWludXR0LiBHamVubm9tc25pdHRsaWcgb2tzeWdlbmZvcmJydWsgbWVkIDI1IGlubnB1c3QgaSBtaW51dHRldCBlciAxIG9rc3lnZW5lbmhldC4nLFxuICAgICAgICAgICAgbmV4dDogJ2hlYXJ0cmF0ZV90aW1lcidcbiAgICAgICAgfSxcbiAgICAgICAgaGVhcnRyYXRlX3RpbWVyOiB7XG4gICAgICAgICAgICB0ZXh0OiAnU3RhcnQga2xva2thIG9nIHRlbGwgYW50YWxsIGhqZXJ0ZXNsYWcgcMOlIHRpIHNla3VuZGVyJyxcbiAgICAgICAgICAgIG5leHQ6ICdoZWFydHJhdGVfY2FsY3VsYXRlJyxcbiAgICAgICAgICAgIHBsYWluX2luZm86IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgaGVhcnRyYXRlX2NhbGN1bGF0ZToge1xuICAgICAgICAgICAgdGV4dDogJ0Zpbm4gbsOlIHV0IGh2b3IgbWFuZ2Ugc2xhZyBkZXQgYmxpciBpIG1pbnV0dGV0LiBFdmFsdWVyIHJlc3VsdGF0ZXQgdmVkIMOlIHNrcml2ZSBkZXQgaW5uIGkgdGVrc3RmZWx0ZXQuJyxcbiAgICAgICAgICAgIG5leHQ6ICdhd2FpdGluZydcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWN1cml0eToge1xuICAgICAgICBjdXJyZW50IDogbnVsbCxcbiAgICAgICAgYXdhaXRpbmcgOiBhd2FpdGluZ05ld0luc3RydWN0aW9ucyxcblxuICAgICAgICBzY3J1YmJlciA6e1xuICAgICAgICAgICAgdGV4dCA6ICdOT1QgU1VSRSBBQk9VVCBUSElTIE9ORS4gSSBUSElOSyBJVCBXSUxMIEJFIFRSSUdHRVJFRCBXSVRIT1VUIEFOWSBORUVEIEZPUiBJTlNUUlVDVElPTlMnLFxuICAgICAgICAgICAgbmV4dCA6ICdhd2FpdGluZydcbiAgICAgICAgfSxcblxuICAgICAgICBzaWduYWxfdGVzdCA6IHtcbiAgICAgICAgICAgIHRleHQgOiAnU2pla2sgb20gZGF0YW92ZXJmw7hyaW5nZXIgbGFyIHNlZyBnasO4cmUuIE9tIGRldCBnw6VyIGJyYSBrYW4gZGVyZSB0ZXN0ZSBvbSBkYXRha3ZhbGl0ZXRlbiBlciB0aWxmcmVkc3N0aWxsZW5kZScsXG4gICAgICAgICAgICBuZXh0IDogJ2F3YWl0aW5nJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbW11bmljYXRpb24gOiB7XG4gICAgICAgIGN1cnJlbnQgOiBudWxsLFxuICAgICAgICBhd2FpdGluZyA6IGF3YWl0aW5nTmV3SW5zdHJ1Y3Rpb25zLFxuXG4gICAgICAgIGNvbW1fY2hlY2sgOiB7XG4gICAgICAgICAgICB0ZXh0IDogJ1NqZWtrIHN0YXR1cyBww6Uga29tbXVuaWthc2pvbnNsaW5rZW4uIE9tIHNpZ25hbGV0IGVyIHN2YWt0IGLDuHIgZW4gYW5uZW4gc2F0ZWxpdHQgdmVsZ2VzLiAnXG4gICAgICAgICAgICArJ09tIGRlcmUgdmVsZ2VyIGVuIGFubmVuIHNhdGVsaXR0IG3DpSBkZXJlIG9nc8OlIHZlbGdlIGVuIGZyZWt2ZW5zIGZyYSBmcmVrdmVuc2LDpW5kZXQuICdcbiAgICAgICAgICAgICsgJ0RldCBiZXN0ZSB2YWxnZXQgYXYgZnJla3ZlbnMgZXIgdmFubGlndmlzIG1pZHQgaSBmcmVrdmVuc2LDpW5kZXQuICdcbiAgICAgICAgfVxuXG4gICAgfVxufTtcblxudmFyIFRhc2tTdG9yZSA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSgpLCB7XG5cbiAgICBnZXRDdXJyZW50VGFzaygpIHtcbiAgICAgICAgdmFyIHRlYW1JZCA9IFJvdXRlU3RvcmUuZ2V0VGVhbUlkKCk7XG4gICAgICAgIHZhciBhc3NpZ25tZW50c0ZvclRlYW0gPSBhc3NpZ25tZW50c1t0ZWFtSWRdO1xuICAgICAgICByZXR1cm4gKGFzc2lnbm1lbnRzRm9yVGVhbSAmJiBhc3NpZ25tZW50c0ZvclRlYW1bdGhpcy5nZXRDdXJyZW50VGFza0lkKHRlYW1JZCldKVxuICAgICAgICAgICAgfHwgJ0luZ2VuIG9wcGdhdmUgZnVubmV0JztcbiAgICB9LFxuXG4gICAgZ2V0Q3VycmVudFRhc2tJZCh0ZWFtSWQgPSBSb3V0ZVN0b3JlLmdldFRlYW1JZCgpKSB7XG4gICAgICAgIGlmICghdGVhbUlkLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbm1lbnRzW3RlYW1JZF0uY3VycmVudCB8fCAnYXdhaXRpbmcnO1xuICAgIH0sXG5cbiAgICBnZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXNrSWQ6IHRoaXMuZ2V0Q3VycmVudFRhc2tJZCgpLFxuICAgICAgICAgICAgY3VycmVudFRhc2s6IHRoaXMuZ2V0Q3VycmVudFRhc2soKS50ZXh0LFxuICAgICAgICAgICAgbmV4dFRhc2tJZDogdGhpcy5nZXRDdXJyZW50VGFzaygpLm5leHQsXG4gICAgICAgICAgICBwbGFpbkluZm86IHRoaXMuZ2V0Q3VycmVudFRhc2soKS5wbGFpbl9pbmZvXG4gICAgICAgIH07XG4gICAgfSxcblxuXG4gICAgZGlzcGF0Y2hlckluZGV4OiBBcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciB0YXNrSWQ7XG4gICAgICAgIHZhciB0ZWFtSWQ7XG4gICAgICAgIHZhciBjdXJyZW50VGFzaztcbiAgICAgICAgdmFyIHRlYW1UYXNrcztcblxuICAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5TVEFSVF9UQVNLOlxuICAgICAgICAgICAgICAgIHRlYW1JZCA9IHBheWxvYWQudGVhbUlkO1xuICAgICAgICAgICAgICAgIHRhc2tJZCA9IHBheWxvYWQudGFza0lkO1xuXG4gICAgICAgICAgICAgICAgdGVhbVRhc2tzID0gYXNzaWdubWVudHNbdGVhbUlkXTtcbiAgICAgICAgICAgICAgICB0ZWFtVGFza3MuY3VycmVudCA9IHRhc2tJZDtcbiAgICAgICAgICAgICAgICBUYXNrU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuQ09NUExFVEVEX1RBU0s6XG4gICAgICAgICAgICAgICAgdGVhbUlkID0gcGF5bG9hZC50ZWFtSWQ7XG4gICAgICAgICAgICAgICAgdGFza0lkID0gcGF5bG9hZC50YXNrSWQ7XG5cbiAgICAgICAgICAgICAgICB0ZWFtVGFza3MgPSBhc3NpZ25tZW50c1t0ZWFtSWRdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gdGVhbVRhc2tzW3Rhc2tJZF07XG4gICAgICAgICAgICAgICAgdGVhbVRhc2tzLmN1cnJlbnQgPSBjdXJyZW50VGFzay5uZXh0O1xuICAgICAgICAgICAgICAgIFRhc2tTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5SRUNFSVZFRF9BUFBfU1RBVEU6XG4gICAgICAgICAgICAgICAgdGVhbUlkID0gUm91dGVTdG9yZS5nZXRUZWFtSWQoKTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZWFtU3RhdGUgPSBwYXlsb2FkLmFwcFN0YXRlW3RlYW1JZF07XG5cbiAgICAgICAgICAgICAgICBpZiAodGVhbVN0YXRlICYmIHRlYW1TdGF0ZS5jdXJyZW50X3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSB0ZWFtU3RhdGUuY3VycmVudF90YXNrO1xuICAgICAgICAgICAgICAgICAgICB0ZWFtVGFza3MgPSBhc3NpZ25tZW50c1t0ZWFtSWRdO1xuICAgICAgICAgICAgICAgICAgICB0ZWFtVGFza3MuY3VycmVudCA9IGN1cnJlbnRUYXNrO1xuICAgICAgICAgICAgICAgICAgICBUYXNrU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIGVycm9ycy4gTmVlZGVkIGJ5IHByb21pc2UgaW4gRGlzcGF0Y2hlci5cbiAgICB9KVxuXG59KTtcblxud2luZG93Ll9fVGFza1N0b3JlID0gVGFza1N0b3JlO1xubW9kdWxlLmV4cG9ydHMgPSBUYXNrU3RvcmU7XG4iLCIvKiBBIHNpbmdsZXRvbiBzdG9yZSB0aGF0IGNhbiBiZSBxdWVyaWVkIGZvciByZW1haW5pbmcgdGltZSAqL1xuXG5jb25zdCBjaGVjayA9IHJlcXVpcmUoJ2NoZWNrLXR5cGVzJyk7XG5jb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5jb25zdCBUaW1lckNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9UaW1lckNvbnN0YW50cycpO1xuY29uc3QgTWlzc2lvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5cblxuLy8ga2VlcGluZyBzdGF0ZSBoaWRkZW4gaW4gdGhlIG1vZHVsZVxudmFyIHJlbWFpbmluZ1RpbWUgPSB7fSxcbiAgICBpbml0aWFsVGltZSA9IHt9LFxuICAgIGludGVydmFsSWQgPSB7fSxcbiAgICBlbGFwc2VkTWlzc2lvblRpbWUgPSAwLFxuICAgIG1pc3Npb25UaW1lciA9IG51bGw7XG5cblxuZnVuY3Rpb24gcmVzZXQodGltZXJJZCkge1xuICAgIHN0b3AodGltZXJJZCk7XG4gICAgcmVtYWluaW5nVGltZVt0aW1lcklkXSA9IGluaXRpYWxUaW1lW3RpbWVySWRdO1xufVxuXG5mdW5jdGlvbiBzdGFydCh0aW1lcklkKSB7XG4gICAgYXNzZXJ0RXhpc3RzKHRpbWVySWQpO1xuXG4gICAgaW50ZXJ2YWxJZFt0aW1lcklkXSA9IHNldEludGVydmFsKGZ1bmN0aW9uIGZuKCkge1xuICAgICAgICBpZiAocmVtYWluaW5nVGltZVt0aW1lcklkXSA+IDApIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ1RpbWVbdGltZXJJZF0tLTtcbiAgICAgICAgICAgIFRpbWVyU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgIH0sIDEwMDApO1xufVxuXG5mdW5jdGlvbiBzdG9wKHRpbWVySWQpIHtcbiAgICBhc3NlcnRFeGlzdHModGltZXJJZCk7XG5cbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWRbdGltZXJJZF0pO1xuICAgIGRlbGV0ZSBpbnRlcnZhbElkW3RpbWVySWRdO1xuICAgIFRpbWVyU3RvcmUuZW1pdENoYW5nZSgpO1xufVxuXG5mdW5jdGlvbiBzdGFydE1pc3Npb25UaW1lcigpe1xuICAgIHN0b3BNaXNzaW9uVGltZXIoKTtcbiAgICBtaXNzaW9uVGltZXIgPSBzZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgICBlbGFwc2VkTWlzc2lvblRpbWUrKztcbiAgICAgICAgVGltZXJTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgfSwxMDAwKTtcbn1cblxuZnVuY3Rpb24gc3RvcE1pc3Npb25UaW1lcigpe1xuICAgIGNsZWFySW50ZXJ2YWwobWlzc2lvblRpbWVyKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSBkYXRhLnJlbWFpbmluZ1RpbWUge051bWJlcn1cbiAqIEBwYXJhbSBkYXRhLnRpbWVySWQge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUmVtYWluaW5nVGltZUNoYW5nZWQoZGF0YSkge1xuICAgIHZhciByZW1haW5pbmcgPSBkYXRhLnJlbWFpbmluZ1RpbWU7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgaW52YWxpZCByZW1haW5pbmcgdGltZSA6JyArIHJlbWFpbmluZyk7XG5cbiAgICByZW1haW5pbmdUaW1lW2RhdGEudGltZXJJZF0gPSByZW1haW5pbmc7XG4gICAgaW5pdGlhbFRpbWVbZGF0YS50aW1lcklkXSA9IHJlbWFpbmluZztcbiAgICBUaW1lclN0b3JlLmVtaXRDaGFuZ2UoKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhpc3RzKHRpbWVySWQpIHtcbiAgICBjaGVjay5hc3NlcnQodGltZXJJZCBpbiByZW1haW5pbmdUaW1lLCAnTm8gdGltZSBzZXQgZm9yIHRpbWVyIHdpdGggaWQgJyArIHRpbWVySWQpO1xufVxuXG5jb25zdCBUaW1lclN0b3JlID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlKCksIHtcbiAgICBcbiAgICBnZXRSZW1haW5pbmdUaW1lKHRpbWVySWQpIHtcbiAgICAgICAgY2hlY2subnVtYmVyKHRpbWVySWQpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nVGltZVt0aW1lcklkXTtcbiAgICB9LFxuXG4gICAgaXNSdW5uaW5nKHRpbWVySWQpIHtcbiAgICAgICAgY2hlY2subnVtYmVyKHRpbWVySWQpO1xuICAgICAgICByZXR1cm4gISFpbnRlcnZhbElkW3RpbWVySWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXIgaXMgc2V0IChvciBoYXMgYmVlbiByZXNldCksIGJ1dCBub3Qgc3RhcnRlZFxuICAgICAqIEBwYXJhbSB0aW1lcklkXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiByZWFkeSwgZmFsc2UgaWYgcnVubmluZyBvciB0aW1lZCBvdXRcbiAgICAgKi9cbiAgICBpc1JlYWR5VG9TdGFydCh0aW1lcklkKSB7XG4gICAgICAgIGNoZWNrLm51bWJlcih0aW1lcklkKTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuaXNSdW5uaW5nKHRpbWVySWQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbWFpbmluZ1RpbWUodGltZXJJZCkgPiAwO1xuICAgIH0sXG5cbiAgICBnZXRFbGFwc2VkTWlzc2lvblRpbWUoKSB7XG4gICAgICAgIHJldHVybiBlbGFwc2VkTWlzc2lvblRpbWU7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgeyBhY3Rpb24sIGRhdGF9ID0gcGF5bG9hZDtcblxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlIFRpbWVyQ29uc3RhbnRzLlNFVF9USU1FUjpcbiAgICAgICAgICAgICAgICBoYW5kbGVSZW1haW5pbmdUaW1lQ2hhbmdlZChkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBUaW1lckNvbnN0YW50cy5TVEFSVF9USU1FUjpcbiAgICAgICAgICAgICAgICBhc3NlcnRFeGlzdHMoZGF0YS50aW1lcklkKTtcblxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHNldHRpbmcgdXAgbW9yZSB0aGFuIG9uZSB0aW1lclxuICAgICAgICAgICAgICAgIGlmKCFUaW1lclN0b3JlLmlzUnVubmluZyhkYXRhLnRpbWVySWQpKXtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQoZGF0YS50aW1lcklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVGltZXJDb25zdGFudHMuU1RPUF9USU1FUjpcbiAgICAgICAgICAgICAgICBzdG9wKGRhdGEudGltZXJJZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVGltZXJDb25zdGFudHMuUkVTRVRfVElNRVI6XG4gICAgICAgICAgICAgICAgcmVzZXQoZGF0YS50aW1lcklkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBNaXNzaW9uQ29uc3RhbnRzLk1JU1NJT05fU1RBUlRFRF9FVkVOVDpcbiAgICAgICAgICAgICAgICBzdGFydE1pc3Npb25UaW1lcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuTUlTU0lPTl9TVE9QUEVEX0VWRU5UOlxuICAgICAgICAgICAgICAgIHN0b3BNaXNzaW9uVGltZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBNaXNzaW9uQ29uc3RhbnRzLlJFQ0VJVkVEX0FQUF9TVEFURTpcbiAgICAgICAgICAgICAgICB2YXIgYXBwU3RhdGUgPSBwYXlsb2FkLmFwcFN0YXRlO1xuXG4gICAgICAgICAgICAgICAgZWxhcHNlZE1pc3Npb25UaW1lID0gYXBwU3RhdGUuZWxhcHNlZF9taXNzaW9uX3RpbWU7XG5cbiAgICAgICAgICAgICAgICBpZihhcHBTdGF0ZS5taXNzaW9uX3J1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNaXNzaW9uVGltZXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wTWlzc2lvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgVGltZXJTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5NSVNTSU9OX1RJTUVfU1lOQzpcbiAgICAgICAgICAgICAgICBlbGFwc2VkTWlzc2lvblRpbWUgID0gZGF0YS5lbGFwc2VkTWlzc2lvblRpbWU7XG4gICAgICAgICAgICAgICAgVGltZXJTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gZXJyb3JzLiBOZWVkZWQgYnkgcHJvbWlzZSBpbiBEaXNwYXRjaGVyLlxuICAgIH0pXG5cbn0pO1xuXG53aW5kb3cuX19UaW1lU3RvcmUgPSBUaW1lclN0b3JlO1xubW9kdWxlLmV4cG9ydHMgPSBUaW1lclN0b3JlO1xuIiwiY29uc3QgdGVhbU1hcCA9IE9iamVjdC5mcmVlemUoe1xuICAgICdzY2llbmNlJzogJ2ZvcnNrbmluZ3N0ZWFtJyxcbiAgICAnY29tbXVuaWNhdGlvbic6ICdrb21tdW5pa2Fzam9uc3RlYW0nLFxuICAgICdzZWN1cml0eSc6ICdzaWtrZXJoZXRzdGVhbScsXG4gICAgJ2FzdHJvbmF1dCc6ICdhc3Ryb25hdXR0ZWFtJ1xufSk7XG5cbmZ1bmN0aW9uIG90aGVyVGVhbU5hbWVzKGN1cnJlbnRUZWFtSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGVhbU1hcClcbiAgICAgICAgLmZpbHRlcigobikgPT4gbiAhPT0gY3VycmVudFRlYW1JZCAmJiBuICE9PSAnbGVhZGVyJylcbiAgICAgICAgLm1hcCgobikgPT4gdGVhbU1hcFtuXSlcbiAgICAgICAgLmpvaW4oJywgJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbmFtZU1hcDogdGVhbU1hcCxcbiAgICBvdGhlclRlYW1OYW1lc1xufTtcbiIsImZ1bmN0aW9uIGNsZWFuUm9vdFBhdGgocGF0aCkge1xuICAgIC8vIGNvbnZlcnQgJy9zY2llbmNlL3N0ZXAxJyA9PiAnc2NpZW5jZSdcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC8/KFxcdyspLiovLCBcIiQxXCIpO1xufVxuXG5mdW5jdGlvbiByYW5kb21JbnQobWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCArIDEgLSBtaW4pKSArIG1pbjtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSBudW1iZXIgcGFyc2luZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgaXMgYSBub24tZW1wdHkgc3RyaW5nXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIHBvc3NpYmx5IE5hTlxuICpcbiAqIFRoZSBzdGFuZGFyZGl6YXRpb24gc3RlcCBvZiBjb252ZXJ0aW5nICcxLDIzJyAtPiAnMS4yMycgaXMgc3RyaWN0bHkgbm90IG5lZWRlZCB3aGVuIGhhbmRsaW5nIGlucHV0cyBmcm9tXG4gKiBpbnB1dCBmaWVsZHMgdGhhdCBoYXZlIHR5cGU9J251bWJlcicsIHdoZXJlIHRoaXMgaGFwcGVucyBhdXRvbWF0aWNhbGx5LlxuICogVGhlIHJlc3Qgb2YgdGhlIGVycm9yIGhhbmRsaW5nIGlzIHVzZWZ1bCwgbm9uZSB0aGUgbGVzcy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VOdW1iZXIoc3RyKSB7XG4gICAgaWYgKCF0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1RoaXMgZnVuY3Rpb24gZXhwZWN0cyBzdHJpbmdzLiBHb3Qgc29tZXRoaW5nIGVsc2U6ICcgKyBzdHIpO1xuICAgIH1cblxuICAgIC8vIHN0YW5kYXJkaXplIHRoZSBudW1iZXIgZm9ybWF0IC0gcmVtb3ZpbmcgTm9yd2VnaWFuIGN1cnJlbmN5IGZvcm1hdFxuICAgIGxldCBjbGVhbmVkU3RyaW5nID0gc3RyLnRyaW0oKS5yZXBsYWNlKCcsJywgJy4nKTtcblxuICAgIGlmICghY2xlYW5lZFN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdHb3QgYSBibGFuayBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoY2xlYW5lZFN0cmluZy5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGNsZWFuZWRTdHJpbmcsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoY2xlYW5lZFN0cmluZywgMTApO1xuICAgIH1cbn1cblxuLy8gZ2VuZXJhdGVzIGEgVVVJRFxuLy8gd29ybGRzIHNtYWxsZXN0IHV1aWQgbGliLiBjcmF6eSBzaGl0IDopXG4vLyBAc2VlIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcbmZ1bmN0aW9uIGIoYSkge1xuICAgIHJldHVybiBhID8gKGEgXiBNYXRoLnJhbmRvbSgpICogMTYgPj4gYSAvIDQpLnRvU3RyaW5nKDE2KSA6IChbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBiKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjbGVhblJvb3RQYXRoLCByYW5kb21JbnQsIHBhcnNlTnVtYmVyLCB1dWlkOiBiXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2ZyZWV6ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KSgpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRhc3NpZ24gPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9PYmplY3QkYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpLmNvcmUuT2JqZWN0LmFzc2lnbjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc3RhdGljcy1hY2NlcHQtcHJpbWl0aXZlcycpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpLmNvcmUuT2JqZWN0LmZyZWV6ZTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc3RhdGljcy1hY2NlcHQtcHJpbWl0aXZlcycpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpLmNvcmUuT2JqZWN0LmtleXM7IiwidmFyICQgPSByZXF1aXJlKCcuLyQnKTtcclxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxyXG4vKmVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2Upe1xyXG4vKmVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuICB2YXIgVCA9IE9iamVjdCgkLmFzc2VydERlZmluZWQodGFyZ2V0KSlcclxuICAgICwgbCA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICwgaSA9IDE7XHJcbiAgd2hpbGUobCA+IGkpe1xyXG4gICAgdmFyIFMgICAgICA9ICQuRVM1T2JqZWN0KGFyZ3VtZW50c1tpKytdKVxyXG4gICAgICAsIGtleXMgICA9ICQuZ2V0S2V5cyhTKVxyXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICwgaiAgICAgID0gMFxyXG4gICAgICAsIGtleTtcclxuICAgIHdoaWxlKGxlbmd0aCA+IGopVFtrZXkgPSBrZXlzW2orK11dID0gU1trZXldO1xyXG4gIH1cclxuICByZXR1cm4gVDtcclxufTsiLCJ2YXIgJCAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXHJcbiAgLCBnbG9iYWwgICAgID0gJC5nXHJcbiAgLCBjb3JlICAgICAgID0gJC5jb3JlXHJcbiAgLCBpc0Z1bmN0aW9uID0gJC5pc0Z1bmN0aW9uO1xyXG5mdW5jdGlvbiBjdHgoZm4sIHRoYXQpe1xyXG4gIHJldHVybiBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG4vLyB0eXBlIGJpdG1hcFxyXG4kZGVmLkYgPSAxOyAgLy8gZm9yY2VkXHJcbiRkZWYuRyA9IDI7ICAvLyBnbG9iYWxcclxuJGRlZi5TID0gNDsgIC8vIHN0YXRpY1xyXG4kZGVmLlAgPSA4OyAgLy8gcHJvdG9cclxuJGRlZi5CID0gMTY7IC8vIGJpbmRcclxuJGRlZi5XID0gMzI7IC8vIHdyYXBcclxuZnVuY3Rpb24gJGRlZih0eXBlLCBuYW1lLCBzb3VyY2Upe1xyXG4gIHZhciBrZXksIG93biwgb3V0LCBleHBcclxuICAgICwgaXNHbG9iYWwgPSB0eXBlICYgJGRlZi5HXHJcbiAgICAsIHRhcmdldCAgID0gaXNHbG9iYWwgPyBnbG9iYWwgOiB0eXBlICYgJGRlZi5TXHJcbiAgICAgICAgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KS5wcm90b3R5cGVcclxuICAgICwgZXhwb3J0cyAgPSBpc0dsb2JhbCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xyXG4gIGlmKGlzR2xvYmFsKXNvdXJjZSA9IG5hbWU7XHJcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xyXG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXHJcbiAgICBvd24gPSAhKHR5cGUgJiAkZGVmLkYpICYmIHRhcmdldCAmJiBrZXkgaW4gdGFyZ2V0O1xyXG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xyXG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcclxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XHJcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcclxuICAgIGlmKGlzR2xvYmFsICYmICFpc0Z1bmN0aW9uKHRhcmdldFtrZXldKSlleHAgPSBzb3VyY2Vba2V5XTtcclxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XHJcbiAgICBlbHNlIGlmKHR5cGUgJiAkZGVmLkIgJiYgb3duKWV4cCA9IGN0eChvdXQsIGdsb2JhbCk7XHJcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxyXG4gICAgZWxzZSBpZih0eXBlICYgJGRlZi5XICYmIHRhcmdldFtrZXldID09IG91dCkhZnVuY3Rpb24oQyl7XHJcbiAgICAgIGV4cCA9IGZ1bmN0aW9uKHBhcmFtKXtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEMgPyBuZXcgQyhwYXJhbSkgOiBDKHBhcmFtKTtcclxuICAgICAgfTtcclxuICAgICAgZXhwLnByb3RvdHlwZSA9IEMucHJvdG90eXBlO1xyXG4gICAgfShvdXQpO1xyXG4gICAgZWxzZSBleHAgPSB0eXBlICYgJGRlZi5QICYmIGlzRnVuY3Rpb24ob3V0KSA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xyXG4gICAgLy8gZXhwb3J0XHJcbiAgICAkLmhpZGUoZXhwb3J0cywga2V5LCBleHApO1xyXG4gIH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWY7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkKXtcclxuICAkLkZXICAgPSBmYWxzZTtcclxuICAkLnBhdGggPSAkLmNvcmU7XHJcbiAgcmV0dXJuICQ7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgZ2xvYmFsID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxyXG4gICwgY29yZSAgID0ge31cclxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XHJcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5XHJcbiAgLCBjZWlsICA9IE1hdGguY2VpbFxyXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yXHJcbiAgLCBtYXggICA9IE1hdGgubWF4XHJcbiAgLCBtaW4gICA9IE1hdGgubWluO1xyXG4vLyBUaGUgZW5naW5lIHdvcmtzIGZpbmUgd2l0aCBkZXNjcmlwdG9ycz8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eS5cclxudmFyIERFU0MgPSAhIWZ1bmN0aW9uKCl7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gMjsgfX0pLmEgPT0gMjtcclxuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XHJcbn0oKTtcclxudmFyIGhpZGUgPSBjcmVhdGVEZWZpbmVyKDEpO1xyXG4vLyA3LjEuNCBUb0ludGVnZXJcclxuZnVuY3Rpb24gdG9JbnRlZ2VyKGl0KXtcclxuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcclxufVxyXG5mdW5jdGlvbiBkZXNjKGJpdG1hcCwgdmFsdWUpe1xyXG4gIHJldHVybiB7XHJcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXHJcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXHJcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXHJcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaW1wbGVTZXQob2JqZWN0LCBrZXksIHZhbHVlKXtcclxuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xyXG4gIHJldHVybiBvYmplY3Q7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRGVmaW5lcihiaXRtYXApe1xyXG4gIHJldHVybiBERVNDID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcclxuICAgIHJldHVybiAkLnNldERlc2Mob2JqZWN0LCBrZXksIGRlc2MoYml0bWFwLCB2YWx1ZSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXHJcbiAgfSA6IHNpbXBsZVNldDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNPYmplY3QoaXQpe1xyXG4gIHJldHVybiBpdCAhPT0gbnVsbCAmJiAodHlwZW9mIGl0ID09ICdvYmplY3QnIHx8IHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nKTtcclxufVxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGl0KXtcclxuICByZXR1cm4gdHlwZW9mIGl0ID09ICdmdW5jdGlvbic7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZChpdCl7XHJcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuXHJcbnZhciAkID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZncnKSh7XHJcbiAgZzogZ2xvYmFsLFxyXG4gIGNvcmU6IGNvcmUsXHJcbiAgaHRtbDogZ2xvYmFsLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9jb3JlLWpzLWlzb2JqZWN0XHJcbiAgaXNPYmplY3Q6ICAgaXNPYmplY3QsXHJcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcclxuICBpdDogZnVuY3Rpb24oaXQpe1xyXG4gICAgcmV0dXJuIGl0O1xyXG4gIH0sXHJcbiAgdGhhdDogZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcbiAgLy8gNy4xLjQgVG9JbnRlZ2VyXHJcbiAgdG9JbnRlZ2VyOiB0b0ludGVnZXIsXHJcbiAgLy8gNy4xLjE1IFRvTGVuZ3RoXHJcbiAgdG9MZW5ndGg6IGZ1bmN0aW9uKGl0KXtcclxuICAgIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXHJcbiAgfSxcclxuICB0b0luZGV4OiBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcclxuICAgIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcclxuICAgIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xyXG4gIH0sXHJcbiAgaGFzOiBmdW5jdGlvbihpdCwga2V5KXtcclxuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xyXG4gIH0sXHJcbiAgY3JlYXRlOiAgICAgT2JqZWN0LmNyZWF0ZSxcclxuICBnZXRQcm90bzogICBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXHJcbiAgREVTQzogICAgICAgREVTQyxcclxuICBkZXNjOiAgICAgICBkZXNjLFxyXG4gIGdldERlc2M6ICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXHJcbiAgc2V0RGVzYzogICAgZGVmaW5lUHJvcGVydHksXHJcbiAgZ2V0S2V5czogICAgT2JqZWN0LmtleXMsXHJcbiAgZ2V0TmFtZXM6ICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXHJcbiAgZ2V0U3ltYm9sczogT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcclxuICAvLyBEdW1teSwgZml4IGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5nIGluIGVzNSBtb2R1bGVcclxuICBhc3NlcnREZWZpbmVkOiBhc3NlcnREZWZpbmVkLFxyXG4gIEVTNU9iamVjdDogT2JqZWN0LFxyXG4gIHRvT2JqZWN0OiBmdW5jdGlvbihpdCl7XHJcbiAgICByZXR1cm4gJC5FUzVPYmplY3QoYXNzZXJ0RGVmaW5lZChpdCkpO1xyXG4gIH0sXHJcbiAgaGlkZTogaGlkZSxcclxuICBkZWY6IGNyZWF0ZURlZmluZXIoMCksXHJcbiAgc2V0OiBnbG9iYWwuU3ltYm9sID8gc2ltcGxlU2V0IDogaGlkZSxcclxuICBtaXg6IGZ1bmN0aW9uKHRhcmdldCwgc3JjKXtcclxuICAgIGZvcih2YXIga2V5IGluIHNyYyloaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH0sXHJcbiAgZWFjaDogW10uZm9yRWFjaFxyXG59KTtcclxuaWYodHlwZW9mIF9fZSAhPSAndW5kZWZpbmVkJylfX2UgPSBjb3JlO1xyXG5pZih0eXBlb2YgX19nICE9ICd1bmRlZmluZWQnKV9fZyA9IGdsb2JhbDsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxyXG52YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcclxuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuLyQuYXNzaWduJyl9KTsiLCJ2YXIgJCAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxyXG4gICwgJGRlZiAgICAgPSByZXF1aXJlKCcuLyQuZGVmJylcclxuICAsIGlzT2JqZWN0ID0gJC5pc09iamVjdFxyXG4gICwgdG9PYmplY3QgPSAkLnRvT2JqZWN0O1xyXG5mdW5jdGlvbiB3cmFwT2JqZWN0TWV0aG9kKE1FVEhPRCwgTU9ERSl7XHJcbiAgdmFyIGZuICA9ICgkLmNvcmUuT2JqZWN0IHx8IHt9KVtNRVRIT0RdIHx8IE9iamVjdFtNRVRIT0RdXHJcbiAgICAsIGYgICA9IDBcclxuICAgICwgbyAgID0ge307XHJcbiAgb1tNRVRIT0RdID0gTU9ERSA9PSAxID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGl0O1xyXG4gIH0gOiBNT0RFID09IDIgPyBmdW5jdGlvbihpdCl7XHJcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogdHJ1ZTtcclxuICB9IDogTU9ERSA9PSAzID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGZhbHNlO1xyXG4gIH0gOiBNT0RFID09IDQgPyBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XHJcbiAgICByZXR1cm4gZm4odG9PYmplY3QoaXQpLCBrZXkpO1xyXG4gIH0gOiBNT0RFID09IDUgPyBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XHJcbiAgICByZXR1cm4gZm4oT2JqZWN0KCQuYXNzZXJ0RGVmaW5lZChpdCkpKTtcclxuICB9IDogZnVuY3Rpb24oaXQpe1xyXG4gICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSk7XHJcbiAgfTtcclxuICB0cnkge1xyXG4gICAgZm4oJ3onKTtcclxuICB9IGNhdGNoKGUpe1xyXG4gICAgZiA9IDE7XHJcbiAgfVxyXG4gICRkZWYoJGRlZi5TICsgJGRlZi5GICogZiwgJ09iamVjdCcsIG8pO1xyXG59XHJcbndyYXBPYmplY3RNZXRob2QoJ2ZyZWV6ZScsIDEpO1xyXG53cmFwT2JqZWN0TWV0aG9kKCdzZWFsJywgMSk7XHJcbndyYXBPYmplY3RNZXRob2QoJ3ByZXZlbnRFeHRlbnNpb25zJywgMSk7XHJcbndyYXBPYmplY3RNZXRob2QoJ2lzRnJvemVuJywgMik7XHJcbndyYXBPYmplY3RNZXRob2QoJ2lzU2VhbGVkJywgMik7XHJcbndyYXBPYmplY3RNZXRob2QoJ2lzRXh0ZW5zaWJsZScsIDMpO1xyXG53cmFwT2JqZWN0TWV0aG9kKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCA0KTtcclxud3JhcE9iamVjdE1ldGhvZCgnZ2V0UHJvdG90eXBlT2YnLCA1KTtcclxud3JhcE9iamVjdE1ldGhvZCgna2V5cycpO1xyXG53cmFwT2JqZWN0TWV0aG9kKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJyk7IixudWxsLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBCdWZmZXIpKSByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG4gIHZhciBsZW5ndGhcblxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBsZW5ndGggPSArc3ViamVjdFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkge1xuICAgIC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSkgc3ViamVjdCA9IHN1YmplY3QuZGF0YVxuICAgIGxlbmd0aCA9ICtzdWJqZWN0Lmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmIChsZW5ndGggPiBrTWF4TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHgnICtcbiAgICAgIGtNYXhMZW5ndGgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkgbGVuZ3RoID0gMFxuICBlbHNlIGxlbmd0aCA+Pj49IDAgLy8gY29lcmNlIHRvIHVpbnQzMlxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBzZWxmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBzZWxmLmxlbmd0aCA9IGxlbmd0aFxuICAgIHNlbGYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBzZWxmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCA+IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSkgc2VsZi5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW4gJiYgYVtpXSA9PT0gYltpXTsgaSsrKSB7fVxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG5cbiAgaWYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgPj4+IDAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpID4+PiAwICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSW50KFxuICAgICAgdGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCxcbiAgICAgIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSkgLSAxLFxuICAgICAgLU1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcbiAgICApXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJbnQoXG4gICAgICB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLFxuICAgICAgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKSAtIDEsXG4gICAgICAtTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuICAgIClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldF9zdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XFwtXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG4gIHZhciBpID0gMFxuXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICBjb2RlUG9pbnQgPSBsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwIHwgMHgxMDAwMFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG5cbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDIwMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xuaWYgKGRlYnVnICYmIGRlYnVnLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWcuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udClcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgdXRpbC5pc051bGwobikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICghdXRpbC5pc051bWJlcihuKSB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH1cblxuICBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmICh1dGlsLmlzTnVsbChyZXQpKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmICghdXRpbC5pc051bGwocmV0KSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsXG4gICAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXG4gIC8vIHRoZW4gY2FsbCByZXN1bWUgdG8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YSBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiBmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgICAgICAgICBzZWxmLnJlYWQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIH1cbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZXN1bWVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgIGlmICghY2h1bmsgfHwgIXN0YXRlLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oc3RyZWFtW2ldKSAmJiB1dGlsLmlzVW5kZWZpbmVkKHRoaXNbaV0pKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChkYXRhKSlcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24odGhpcy5fZmx1c2gpKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbCh0cy53cml0ZWNodW5rKSAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcbn1cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyoqXG4gKiBUaGlzIG1vZHVsZSBleHBvcnRzIGZ1bmN0aW9ucyBmb3IgY2hlY2tpbmcgdHlwZXNcbiAqIGFuZCB0aHJvd2luZyBleGNlcHRpb25zLlxuICovXG5cbi8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbWVzc2FnZXMsIHByZWRpY2F0ZXMsIGZ1bmN0aW9ucywgYXNzZXJ0LCBub3QsIG1heWJlLCBlaXRoZXI7XG5cbiAgICBtZXNzYWdlcyA9IHtcbiAgICAgICAgbGlrZTogJ0ludmFsaWQgdHlwZScsXG4gICAgICAgIGluc3RhbmNlOiAnSW52YWxpZCB0eXBlJyxcbiAgICAgICAgZW1wdHlPYmplY3Q6ICdJbnZhbGlkIG9iamVjdCcsXG4gICAgICAgIG9iamVjdDogJ0ludmFsaWQgb2JqZWN0JyxcbiAgICAgICAgYXNzaWduZWQ6ICdJbnZhbGlkIHZhbHVlJyxcbiAgICAgICAgdW5kZWZpbmVkOiAnSW52YWxpZCB2YWx1ZScsXG4gICAgICAgIG51bGw6ICdJbnZhbGlkIHZhbHVlJyxcbiAgICAgICAgaGFzTGVuZ3RoOiAnSW52YWxpZCBsZW5ndGgnLFxuICAgICAgICBlbXB0eUFycmF5OiAnSW52YWxpZCBhcnJheScsXG4gICAgICAgIGFycmF5OiAnSW52YWxpZCBhcnJheScsXG4gICAgICAgIGRhdGU6ICdJbnZhbGlkIGRhdGUnLFxuICAgICAgICBlcnJvcjogJ0ludmFsaWQgZXJyb3InLFxuICAgICAgICBmbjogJ0ludmFsaWQgZnVuY3Rpb24nLFxuICAgICAgICBtYXRjaDogJ0ludmFsaWQgc3RyaW5nJyxcbiAgICAgICAgY29udGFpbnM6ICdJbnZhbGlkIHN0cmluZycsXG4gICAgICAgIHVuZW1wdHlTdHJpbmc6ICdJbnZhbGlkIHN0cmluZycsXG4gICAgICAgIHN0cmluZzogJ0ludmFsaWQgc3RyaW5nJyxcbiAgICAgICAgb2RkOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBldmVuOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBiZXR3ZWVuOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBncmVhdGVyOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBsZXNzOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBwb3NpdGl2ZTogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgbmVnYXRpdmU6ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIGludGVnZXI6ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIHplcm86ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIG51bWJlcjogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgYm9vbGVhbjogJ0ludmFsaWQgYm9vbGVhbidcbiAgICB9O1xuXG4gICAgcHJlZGljYXRlcyA9IHtcbiAgICAgICAgbGlrZTogbGlrZSxcbiAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICBlbXB0eU9iamVjdDogZW1wdHlPYmplY3QsXG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBhc3NpZ25lZDogYXNzaWduZWQsXG4gICAgICAgIHVuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gICAgICAgIG51bGw6IGlzTnVsbCxcbiAgICAgICAgaGFzTGVuZ3RoOiBoYXNMZW5ndGgsXG4gICAgICAgIGVtcHR5QXJyYXk6IGVtcHR5QXJyYXksXG4gICAgICAgIGFycmF5OiBhcnJheSxcbiAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBmdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBjb250YWluczogY29udGFpbnMsXG4gICAgICAgIHVuZW1wdHlTdHJpbmc6IHVuZW1wdHlTdHJpbmcsXG4gICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICBvZGQ6IG9kZCxcbiAgICAgICAgZXZlbjogZXZlbixcbiAgICAgICAgYmV0d2VlbjogYmV0d2VlbixcbiAgICAgICAgZ3JlYXRlcjogZ3JlYXRlcixcbiAgICAgICAgbGVzczogbGVzcyxcbiAgICAgICAgcG9zaXRpdmU6IHBvc2l0aXZlLFxuICAgICAgICBuZWdhdGl2ZTogbmVnYXRpdmUsXG4gICAgICAgIGludGVnZXIgOiBpbnRlZ2VyLFxuICAgICAgICB6ZXJvOiB6ZXJvLFxuICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgYm9vbGVhbjogYm9vbGVhblxuICAgIH07XG5cbiAgICBmdW5jdGlvbnMgPSB7XG4gICAgICAgIGFwcGx5OiBhcHBseSxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIGFsbDogYWxsLFxuICAgICAgICBhbnk6IGFueVxuICAgIH07XG5cbiAgICBmdW5jdGlvbnMgPSBtaXhpbihmdW5jdGlvbnMsIHByZWRpY2F0ZXMpO1xuICAgIGFzc2VydCA9IGNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyhhc3NlcnRNb2RpZmllciwgYXNzZXJ0SW1wbCk7XG4gICAgbm90ID0gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzKG5vdE1vZGlmaWVyLCBub3RJbXBsKTtcbiAgICBtYXliZSA9IGNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyhtYXliZU1vZGlmaWVyLCBtYXliZUltcGwpO1xuICAgIGVpdGhlciA9IGNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyhlaXRoZXJNb2RpZmllcik7XG4gICAgYXNzZXJ0Lm5vdCA9IGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKGFzc2VydE1vZGlmaWVyLCBub3QpO1xuICAgIGFzc2VydC5tYXliZSA9IGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKGFzc2VydE1vZGlmaWVyLCBtYXliZSk7XG4gICAgYXNzZXJ0LmVpdGhlciA9IGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKGFzc2VydEVpdGhlck1vZGlmaWVyLCBwcmVkaWNhdGVzKTtcblxuICAgIGV4cG9ydEZ1bmN0aW9ucyhtaXhpbihmdW5jdGlvbnMsIHtcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIG5vdDogbm90LFxuICAgICAgICBtYXliZTogbWF5YmUsXG4gICAgICAgIGVpdGhlcjogZWl0aGVyXG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBsaWtlYC5cbiAgICAgKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgYW4gb2JqZWN0ICdxdWFja3MgbGlrZSBhIGR1Y2snLlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBoYXMgYWxsIG9mXG4gICAgICogdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNlY29uZCwgYXJjaGV0eXBhbCBhcmd1bWVudFxuICAgICAqICh0aGUgJ2R1Y2snKS4gUmV0dXJucyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpa2UgKGRhdGEsIGR1Y2spIHtcbiAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgZm9yIChuYW1lIGluIGR1Y2spIHtcbiAgICAgICAgICAgIGlmIChkdWNrLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgPT09IGZhbHNlIHx8IHR5cGVvZiBkYXRhW25hbWVdICE9PSB0eXBlb2YgZHVja1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdChkYXRhW25hbWVdKSAmJiBsaWtlKGRhdGFbbmFtZV0sIGR1Y2tbbmFtZV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBpbnN0YW5jZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBwcm90b3R5cGUsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnN0YW5jZSAoZGF0YSwgcHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGlzRnVuY3Rpb24ocHJvdG90eXBlKSAmJiBkYXRhIGluc3RhbmNlb2YgcHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGVtcHR5T2JqZWN0YC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhbiBlbXB0eSBvYmplY3QsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbXB0eU9iamVjdCAoZGF0YSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0KGRhdGEpICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBwbGFpbi1vbGQgSlMgb2JqZWN0LFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0IChkYXRhKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgYXNzaWduZWRgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZCxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbmVkIChkYXRhKSB7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQoZGF0YSkgJiYgIWlzTnVsbChkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgdW5kZWZpbmVkLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG51bGxgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIG51bGwsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBoYXNMZW5ndGhgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGhhcyBhIGxlbmd0aCBwcm9wZXJ0eVxuICAgICAqIHRoYXQgZXF1YWxzIGB2YWx1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzTGVuZ3RoIChkYXRhLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYXNzaWduZWQoZGF0YSkgJiYgZGF0YS5sZW5ndGggPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZW1wdHlBcnJheWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYW4gZW1wdHkgYXJyYXksXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbXB0eUFycmF5IChkYXRhKSB7XG4gICAgICAgIHJldHVybiBhcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIHNvbWV0aGluZyBpcyBhbiBhcnJheSxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5IChkYXRhKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZGF0ZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBzb21ldGhpbmcgaXMgYSB2YWxpZCBkYXRlLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGF0ZSAoZGF0YSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBEYXRlXScgJiZcbiAgICAgICAgICAgICFpc05hTihkYXRhLmdldFRpbWUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBlcnJvcmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBwbGFpbi1vbGQgSlMgb2JqZWN0LFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXJyb3IgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGZ1bmN0aW9uYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBmdW5jdGlvbixcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgbWF0Y2hgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgc3RyaW5nXG4gICAgICogdGhhdCBtYXRjaGVzIGByZWdleGAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2ggKGRhdGEsIHJlZ2V4KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgISFkYXRhLm1hdGNoKHJlZ2V4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGNvbnRhaW5zYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIHN0cmluZ1xuICAgICAqIHRoYXQgY29udGFpbnMgYHN1YnN0cmluZ2AsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMgKGRhdGEsIHN1YnN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nKGRhdGEpICYmIGRhdGEuaW5kZXhPZihzdWJzdHJpbmcpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYHVuZW1wdHlTdHJpbmdgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgbm9uLWVtcHR5IHN0cmluZyxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZW1wdHlTdHJpbmcgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyhkYXRhKSAmJiBkYXRhICE9PSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBzdHJpbmcsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaW5nIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBvZGRgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGFuIG9kZCBudW1iZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvZGQgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGludGVnZXIoZGF0YSkgJiYgIWV2ZW4oZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBldmVuYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhbiBldmVuIG51bWJlcixcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZW4gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihkYXRhKSAmJiBkYXRhICUgMiA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGludGVnZXJgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGFuIGludGVnZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlZ2VyIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIoZGF0YSkgJiYgZGF0YSAlIDEgPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBiZXR3ZWVuYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIG51bWJlclxuICAgICAqIGJldHdlZW4gYGFgIGFuZCBgYmAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmV0d2VlbiAoZGF0YSwgYSwgYikge1xuICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgIHJldHVybiBncmVhdGVyKGRhdGEsIGEpICYmIGxlc3MoZGF0YSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVzcyhkYXRhLCBhKSAmJiBncmVhdGVyKGRhdGEsIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZ3JlYXRlcmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBudW1iZXJcbiAgICAgKiBncmVhdGVyIHRoYW4gYHZhbHVlYCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncmVhdGVyIChkYXRhLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyKGRhdGEpICYmIGRhdGEgPiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGxlc3NgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgbnVtYmVyXG4gICAgICogbGVzcyB0aGFuIGB2YWx1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVzcyAoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihkYXRhKSAmJiBkYXRhIDwgdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBwb3NpdGl2ZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBwb3NpdGl2ZSBudW1iZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZSAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZ3JlYXRlcihkYXRhLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5lZ2F0aXZlYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIG5lZ2F0aXZlIG51bWJlcixcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhICAgICAgICAgIFRoZSB0aGluZyB0byB0ZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0aXZlIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBsZXNzKGRhdGEsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgbnVtYmVyYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGRhdGEgaXMgYSBudW1iZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudW1iZXIgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJiBpc05hTihkYXRhKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgIGRhdGEgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJlxuICAgICAgICAgICAgICAgZGF0YSAhPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgemVyb2AuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgemVybyxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhICAgICAgICAgIFRoZSB0aGluZyB0byB0ZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm8gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBib29sZWFuYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGRhdGEgaXMgYSBib29sZWFuIHZhbHVlLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gYm9vbGVhbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YSA9PT0gZmFsc2UgfHwgZGF0YSA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIE1hcHMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBkYXRhIHRvIHRoZSBjb3JyZXNwb25kaW5nIHByZWRpY2F0ZSBhbmQgcmV0dXJuc1xuICAgICAqIHRoZSByZXN1bHQgYXJyYXkuIElmIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiB0aGVcbiAgICAgKiBkYXRhLCBhIHNpbmdsZSBwcmVkaWNhdGUgZnVuY3Rpb24gbWF5IGJlIHBhc3NlZCBpbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGx5IChkYXRhLCBwcmVkaWNhdGVzKSB7XG4gICAgICAgIGFzc2VydC5hcnJheShkYXRhKTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihwcmVkaWNhdGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGVzKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0LmFycmF5KHByZWRpY2F0ZXMpO1xuICAgICAgICBhc3NlcnQuaGFzTGVuZ3RoKGRhdGEsIHByZWRpY2F0ZXMubGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNbaW5kZXhdKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBtYXBgLlxuICAgICAqXG4gICAgICogTWFwcyBlYWNoIHZhbHVlIGZyb20gdGhlIGRhdGEgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJlZGljYXRlIGFuZCByZXR1cm5zXG4gICAgICogdGhlIHJlc3VsdCBvYmplY3QuIFN1cHBvcnRzIG5lc3RlZCBvYmplY3RzLiBJZiB0aGUgZGF0YSBpcyBub3QgbmVzdGVkIGFuZFxuICAgICAqIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiBpdCwgYSBzaW5nbGUgcHJlZGljYXRlXG4gICAgICogZnVuY3Rpb24gbWF5IGJlIHBhc3NlZCBpbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcCAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgICAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHByZWRpY2F0ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwU2ltcGxlKGRhdGEsIHByZWRpY2F0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0Lm9iamVjdChwcmVkaWNhdGVzKTtcblxuICAgICAgICByZXR1cm4gbWFwQ29tcGxleChkYXRhLCBwcmVkaWNhdGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBTaW1wbGUgKGRhdGEsIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHByZWRpY2F0ZShkYXRhW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcENvbXBsZXggKGRhdGEsIHByZWRpY2F0ZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHByZWRpY2F0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNba2V5XTtcblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcHJlZGljYXRlKGRhdGFba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdChwcmVkaWNhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBtYXBDb21wbGV4KGRhdGFba2V5XSwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFsbGBcbiAgICAgKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIGJvb2xlYW4gdmFsdWVzIGFyZSB0cnVlXG4gICAgICogaW4gYW4gYXJyYXkgKHJldHVybmVkIGZyb20gYGFwcGx5YClcbiAgICAgKiBvciBvYmplY3QgKHJldHVybmVkIGZyb20gYG1hcGApLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWxsIChkYXRhKSB7XG4gICAgICAgIGlmIChhcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RBcnJheShkYXRhLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0ZXN0T2JqZWN0KGRhdGEsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0QXJyYXkgKGRhdGEsIHJlc3VsdCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0T2JqZWN0IChkYXRhLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGtleSwgdmFsdWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0YVtrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCh2YWx1ZSkgJiYgdGVzdE9iamVjdCh2YWx1ZSwgcmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFueWBcbiAgICAgKlxuICAgICAqIENoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGJvb2xlYW4gdmFsdWUgaXMgdHJ1ZVxuICAgICAqIGluIGFuIGFycmF5IChyZXR1cm5lZCBmcm9tIGBhcHBseWApXG4gICAgICogb3Igb2JqZWN0IChyZXR1cm5lZCBmcm9tIGBtYXBgKS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFueSAoZGF0YSkge1xuICAgICAgICBpZiAoYXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0QXJyYXkoZGF0YSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0ZXN0T2JqZWN0KGRhdGEsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1peGluICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbW9kaWZpZXIgYGFzc2VydGAuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydE1vZGlmaWVyIChwcmVkaWNhdGUsIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmVkaWNhdGUocHJlZGljYXRlLCBhcmd1bWVudHMsIGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnRQcmVkaWNhdGUgKHByZWRpY2F0ZSwgYXJncywgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGFzc2VydEltcGwocHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3MpLCB1bmVtcHR5U3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnRJbXBsICh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0RWl0aGVyTW9kaWZpZXIgKHByZWRpY2F0ZSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRQcmVkaWNhdGUocHJlZGljYXRlLCBhcmd1bWVudHMsIGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3I6IE9iamVjdC5rZXlzKHByZWRpY2F0ZXMpLnJlZHVjZShkZWxheWVkQXNzZXJ0LCB7fSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWRBc3NlcnQgKHJlc3VsdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiAhcHJlZGljYXRlc1trZXldLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1vZGlmaWVyIGBub3RgLlxuICAgICAqXG4gICAgICogTmVnYXRlcyBgcHJlZGljYXRlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3RNb2RpZmllciAocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90SW1wbChwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90SW1wbCAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbW9kaWZpZXIgYG1heWJlYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHByZWRpY2F0ZSBhcmd1bWVudCBpcyAgYG51bGxgIG9yIGB1bmRlZmluZWRgLFxuICAgICAqIG90aGVyd2lzZSBwcm9wYWdhdGVzIHRoZSByZXR1cm4gdmFsdWUgZnJvbSBgcHJlZGljYXRlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXliZU1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghYXNzaWduZWQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF5YmVJbXBsICh2YWx1ZSkge1xuICAgICAgICBpZiAoYXNzaWduZWQodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1vZGlmaWVyIGBlaXRoZXJgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZWl0aGVyIHByZWRpY2F0ZSBpcyB0cnVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVpdGhlck1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzaG9ydGN1dCA9IHByZWRpY2F0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9yOiBPYmplY3Qua2V5cyhwcmVkaWNhdGVzKS5yZWR1Y2Uobm9wT3JQcmVkaWNhdGUsIHt9KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbm9wT3JQcmVkaWNhdGUgKHJlc3VsdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzaG9ydGN1dCA/IG5vcCA6IHByZWRpY2F0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5vcCAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyAobW9kaWZpZXIsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMobW9kaWZpZXIsIHByZWRpY2F0ZXMsIG9iamVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMgKG1vZGlmaWVyLCBmdW5jdGlvbnMsIG9iamVjdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0IHx8IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGZ1bmN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtb2RpZmllcihmdW5jdGlvbnNba2V5XSwgbWVzc2FnZXNba2V5XSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydEZ1bmN0aW9ucyAoZnVuY3Rpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAhPT0gbnVsbCAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxzLmNoZWNrID0gZnVuY3Rpb25zO1xuICAgICAgICB9XG4gICAgfVxufSh0aGlzKSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbm1vZHVsZS5leHBvcnRzLkRpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2xpYi9EaXNwYXRjaGVyJylcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGlzcGF0Y2hlclxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbnZhciBfbGFzdElEID0gMTtcbnZhciBfcHJlZml4ID0gJ0lEXyc7XG5cbi8qKlxuICogRGlzcGF0Y2hlciBpcyB1c2VkIHRvIGJyb2FkY2FzdCBwYXlsb2FkcyB0byByZWdpc3RlcmVkIGNhbGxiYWNrcy4gVGhpcyBpc1xuICogZGlmZmVyZW50IGZyb20gZ2VuZXJpYyBwdWItc3ViIHN5c3RlbXMgaW4gdHdvIHdheXM6XG4gKlxuICogICAxKSBDYWxsYmFja3MgYXJlIG5vdCBzdWJzY3JpYmVkIHRvIHBhcnRpY3VsYXIgZXZlbnRzLiBFdmVyeSBwYXlsb2FkIGlzXG4gKiAgICAgIGRpc3BhdGNoZWQgdG8gZXZlcnkgcmVnaXN0ZXJlZCBjYWxsYmFjay5cbiAqICAgMikgQ2FsbGJhY2tzIGNhbiBiZSBkZWZlcnJlZCBpbiB3aG9sZSBvciBwYXJ0IHVudGlsIG90aGVyIGNhbGxiYWNrcyBoYXZlXG4gKiAgICAgIGJlZW4gZXhlY3V0ZWQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGNvbnNpZGVyIHRoaXMgaHlwb3RoZXRpY2FsIGZsaWdodCBkZXN0aW5hdGlvbiBmb3JtLCB3aGljaFxuICogc2VsZWN0cyBhIGRlZmF1bHQgY2l0eSB3aGVuIGEgY291bnRyeSBpcyBzZWxlY3RlZDpcbiAqXG4gKiAgIHZhciBmbGlnaHREaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoKTtcbiAqXG4gKiAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoaWNoIGNvdW50cnkgaXMgc2VsZWN0ZWRcbiAqICAgdmFyIENvdW50cnlTdG9yZSA9IHtjb3VudHJ5OiBudWxsfTtcbiAqXG4gKiAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoaWNoIGNpdHkgaXMgc2VsZWN0ZWRcbiAqICAgdmFyIENpdHlTdG9yZSA9IHtjaXR5OiBudWxsfTtcbiAqXG4gKiAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBiYXNlIGZsaWdodCBwcmljZSBvZiB0aGUgc2VsZWN0ZWQgY2l0eVxuICogICB2YXIgRmxpZ2h0UHJpY2VTdG9yZSA9IHtwcmljZTogbnVsbH1cbiAqXG4gKiBXaGVuIGEgdXNlciBjaGFuZ2VzIHRoZSBzZWxlY3RlZCBjaXR5LCB3ZSBkaXNwYXRjaCB0aGUgcGF5bG9hZDpcbiAqXG4gKiAgIGZsaWdodERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICogICAgIGFjdGlvblR5cGU6ICdjaXR5LXVwZGF0ZScsXG4gKiAgICAgc2VsZWN0ZWRDaXR5OiAncGFyaXMnXG4gKiAgIH0pO1xuICpcbiAqIFRoaXMgcGF5bG9hZCBpcyBkaWdlc3RlZCBieSBgQ2l0eVN0b3JlYDpcbiAqXG4gKiAgIGZsaWdodERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24ocGF5bG9hZCkge1xuICogICAgIGlmIChwYXlsb2FkLmFjdGlvblR5cGUgPT09ICdjaXR5LXVwZGF0ZScpIHtcbiAqICAgICAgIENpdHlTdG9yZS5jaXR5ID0gcGF5bG9hZC5zZWxlY3RlZENpdHk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBXaGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBjb3VudHJ5LCB3ZSBkaXNwYXRjaCB0aGUgcGF5bG9hZDpcbiAqXG4gKiAgIGZsaWdodERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICogICAgIGFjdGlvblR5cGU6ICdjb3VudHJ5LXVwZGF0ZScsXG4gKiAgICAgc2VsZWN0ZWRDb3VudHJ5OiAnYXVzdHJhbGlhJ1xuICogICB9KTtcbiAqXG4gKiBUaGlzIHBheWxvYWQgaXMgZGlnZXN0ZWQgYnkgYm90aCBzdG9yZXM6XG4gKlxuICogICAgQ291bnRyeVN0b3JlLmRpc3BhdGNoVG9rZW4gPSBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY291bnRyeS11cGRhdGUnKSB7XG4gKiAgICAgICBDb3VudHJ5U3RvcmUuY291bnRyeSA9IHBheWxvYWQuc2VsZWN0ZWRDb3VudHJ5O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogV2hlbiB0aGUgY2FsbGJhY2sgdG8gdXBkYXRlIGBDb3VudHJ5U3RvcmVgIGlzIHJlZ2lzdGVyZWQsIHdlIHNhdmUgYSByZWZlcmVuY2VcbiAqIHRvIHRoZSByZXR1cm5lZCB0b2tlbi4gVXNpbmcgdGhpcyB0b2tlbiB3aXRoIGB3YWl0Rm9yKClgLCB3ZSBjYW4gZ3VhcmFudGVlXG4gKiB0aGF0IGBDb3VudHJ5U3RvcmVgIGlzIHVwZGF0ZWQgYmVmb3JlIHRoZSBjYWxsYmFjayB0aGF0IHVwZGF0ZXMgYENpdHlTdG9yZWBcbiAqIG5lZWRzIHRvIHF1ZXJ5IGl0cyBkYXRhLlxuICpcbiAqICAgQ2l0eVN0b3JlLmRpc3BhdGNoVG9rZW4gPSBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY291bnRyeS11cGRhdGUnKSB7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIG1heSBub3QgYmUgdXBkYXRlZC5cbiAqICAgICAgIGZsaWdodERpc3BhdGNoZXIud2FpdEZvcihbQ291bnRyeVN0b3JlLmRpc3BhdGNoVG9rZW5dKTtcbiAqICAgICAgIC8vIGBDb3VudHJ5U3RvcmUuY291bnRyeWAgaXMgbm93IGd1YXJhbnRlZWQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiAgICAgICAvLyBTZWxlY3QgdGhlIGRlZmF1bHQgY2l0eSBmb3IgdGhlIG5ldyBjb3VudHJ5XG4gKiAgICAgICBDaXR5U3RvcmUuY2l0eSA9IGdldERlZmF1bHRDaXR5Rm9yQ291bnRyeShDb3VudHJ5U3RvcmUuY291bnRyeSk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgdXNhZ2Ugb2YgYHdhaXRGb3IoKWAgY2FuIGJlIGNoYWluZWQsIGZvciBleGFtcGxlOlxuICpcbiAqICAgRmxpZ2h0UHJpY2VTdG9yZS5kaXNwYXRjaFRva2VuID1cbiAqICAgICBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICAgIHN3aXRjaCAocGF5bG9hZC5hY3Rpb25UeXBlKSB7XG4gKiAgICAgICAgIGNhc2UgJ2NvdW50cnktdXBkYXRlJzpcbiAqICAgICAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NpdHlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAgICAgRmxpZ2h0UHJpY2VTdG9yZS5wcmljZSA9XG4gKiAgICAgICAgICAgICBnZXRGbGlnaHRQcmljZVN0b3JlKENvdW50cnlTdG9yZS5jb3VudHJ5LCBDaXR5U3RvcmUuY2l0eSk7XG4gKiAgICAgICAgICAgYnJlYWs7XG4gKlxuICogICAgICAgICBjYXNlICdjaXR5LXVwZGF0ZSc6XG4gKiAgICAgICAgICAgRmxpZ2h0UHJpY2VTdG9yZS5wcmljZSA9XG4gKiAgICAgICAgICAgICBGbGlnaHRQcmljZVN0b3JlKENvdW50cnlTdG9yZS5jb3VudHJ5LCBDaXR5U3RvcmUuY2l0eSk7XG4gKiAgICAgICAgICAgYnJlYWs7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgYGNvdW50cnktdXBkYXRlYCBwYXlsb2FkIHdpbGwgYmUgZ3VhcmFudGVlZCB0byBpbnZva2UgdGhlIHN0b3JlcydcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIGluIG9yZGVyOiBgQ291bnRyeVN0b3JlYCwgYENpdHlTdG9yZWAsIHRoZW5cbiAqIGBGbGlnaHRQcmljZVN0b3JlYC5cbiAqL1xuXG4gIGZ1bmN0aW9uIERpc3BhdGNoZXIoKSB7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzUGVuZGluZyA9IHt9O1xuICAgIHRoaXMuJERpc3BhdGNoZXJfaXNIYW5kbGVkID0ge307XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9wZW5kaW5nUGF5bG9hZCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aXRoIGV2ZXJ5IGRpc3BhdGNoZWQgcGF5bG9hZC4gUmV0dXJuc1xuICAgKiBhIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgd2FpdEZvcigpYC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgaWQgPSBfcHJlZml4ICsgX2xhc3RJRCsrO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzW2lkXSA9IGNhbGxiYWNrO1xuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNhbGxiYWNrIGJhc2VkIG9uIGl0cyB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS51bnJlZ2lzdGVyPWZ1bmN0aW9uKGlkKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3NbaWRdLFxuICAgICAgJ0Rpc3BhdGNoZXIudW5yZWdpc3RlciguLi4pOiBgJXNgIGRvZXMgbm90IG1hcCB0byBhIHJlZ2lzdGVyZWQgY2FsbGJhY2suJyxcbiAgICAgIGlkXG4gICAgKTtcbiAgICBkZWxldGUgdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3NbaWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgdGhlIGNhbGxiYWNrcyBzcGVjaWZpZWQgdG8gYmUgaW52b2tlZCBiZWZvcmUgY29udGludWluZyBleGVjdXRpb25cbiAgICogb2YgdGhlIGN1cnJlbnQgY2FsbGJhY2suIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgYnkgYSBjYWxsYmFjayBpblxuICAgKiByZXNwb25zZSB0byBhIGRpc3BhdGNoZWQgcGF5bG9hZC5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBpZHNcbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLndhaXRGb3I9ZnVuY3Rpb24oaWRzKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0Rpc3BhdGNoaW5nLFxuICAgICAgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBNdXN0IGJlIGludm9rZWQgd2hpbGUgZGlzcGF0Y2hpbmcuJ1xuICAgICk7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGlkcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBpZCA9IGlkc1tpaV07XG4gICAgICBpZiAodGhpcy4kRGlzcGF0Y2hlcl9pc1BlbmRpbmdbaWRdKSB7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICB0aGlzLiREaXNwYXRjaGVyX2lzSGFuZGxlZFtpZF0sXG4gICAgICAgICAgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBDaXJjdWxhciBkZXBlbmRlbmN5IGRldGVjdGVkIHdoaWxlICcgK1xuICAgICAgICAgICd3YWl0aW5nIGZvciBgJXNgLicsXG4gICAgICAgICAgaWRcbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzW2lkXSxcbiAgICAgICAgJ0Rpc3BhdGNoZXIud2FpdEZvciguLi4pOiBgJXNgIGRvZXMgbm90IG1hcCB0byBhIHJlZ2lzdGVyZWQgY2FsbGJhY2suJyxcbiAgICAgICAgaWRcbiAgICAgICk7XG4gICAgICB0aGlzLiREaXNwYXRjaGVyX2ludm9rZUNhbGxiYWNrKGlkKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBwYXlsb2FkIHRvIGFsbCByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBheWxvYWRcbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoPWZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdGhpcy4kRGlzcGF0Y2hlcl9pc0Rpc3BhdGNoaW5nLFxuICAgICAgJ0Rpc3BhdGNoLmRpc3BhdGNoKC4uLik6IENhbm5vdCBkaXNwYXRjaCBpbiB0aGUgbWlkZGxlIG9mIGEgZGlzcGF0Y2guJ1xuICAgICk7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9zdGFydERpc3BhdGNoaW5nKHBheWxvYWQpO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrcykge1xuICAgICAgICBpZiAodGhpcy4kRGlzcGF0Y2hlcl9pc1BlbmRpbmdbaWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9pbnZva2VDYWxsYmFjayhpZCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfc3RvcERpc3BhdGNoaW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGlzIERpc3BhdGNoZXIgY3VycmVudGx5IGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuaXNEaXNwYXRjaGluZz1mdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4kRGlzcGF0Y2hlcl9pc0Rpc3BhdGNoaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjYWxsYmFjayBzdG9yZWQgd2l0aCB0aGUgZ2l2ZW4gaWQuIEFsc28gZG8gc29tZSBpbnRlcm5hbFxuICAgKiBib29ra2VlcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuJERpc3BhdGNoZXJfaW52b2tlQ2FsbGJhY2s9ZnVuY3Rpb24oaWQpIHtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzUGVuZGluZ1tpZF0gPSB0cnVlO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzW2lkXSh0aGlzLiREaXNwYXRjaGVyX3BlbmRpbmdQYXlsb2FkKTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzSGFuZGxlZFtpZF0gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgYm9va2tlZXBpbmcgbmVlZGVkIHdoZW4gZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuJERpc3BhdGNoZXJfc3RhcnREaXNwYXRjaGluZz1mdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfaXNQZW5kaW5nW2lkXSA9IGZhbHNlO1xuICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0hhbmRsZWRbaWRdID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuJERpc3BhdGNoZXJfcGVuZGluZ1BheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGJvb2trZWVwaW5nIHVzZWQgZm9yIGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLiREaXNwYXRjaGVyX3N0b3BEaXNwYXRjaGluZz1mdW5jdGlvbigpIHtcbiAgICB0aGlzLiREaXNwYXRjaGVyX3BlbmRpbmdQYXlsb2FkID0gbnVsbDtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgfTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChmYWxzZSkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudDtcbn0gZWxzZSB7XG4gICAgdmFyIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXTtcblxuICAgIGlmICghZG9jY3kpIHtcbiAgICAgICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddID0gbWluRG9jO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG59XG4iLCJpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG4iLCJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgdG9rZW5pemUgPSBmdW5jdGlvbigvKlN0cmluZyovIHN0ciwgLypSZWdFeHAqLyByZSwgLypGdW5jdGlvbj8qLyBwYXJzZURlbGltLCAvKk9iamVjdD8qLyBpbnN0YW5jZSl7XG4gIC8vIHN1bW1hcnk6XG4gIC8vICAgIFNwbGl0IGEgc3RyaW5nIGJ5IGEgcmVndWxhciBleHByZXNzaW9uIHdpdGggdGhlIGFiaWxpdHkgdG8gY2FwdHVyZSB0aGUgZGVsaW1ldGVyc1xuICAvLyBwYXJzZURlbGltOlxuICAvLyAgICBFYWNoIGdyb3VwIChleGNsdWRpbmcgdGhlIDAgZ3JvdXApIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAgLy8gICAgYSB2YWx1ZSwgaXQncyBhZGRlZCB0byB0aGUgbGlzdCBvZiB0b2tlbnMuXG4gIC8vIGluc3RhbmNlOlxuICAvLyAgICBVc2VkIGFzIHRoZSBcInRoaXMnIGluc3RhbmNlIHdoZW4gY2FsbGluZyBwYXJzZURlbGltXG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIG1hdGNoLCBjb250ZW50LCBsYXN0SW5kZXggPSAwO1xuICB3aGlsZShtYXRjaCA9IHJlLmV4ZWMoc3RyKSl7XG4gICAgY29udGVudCA9IHN0ci5zbGljZShsYXN0SW5kZXgsIHJlLmxhc3RJbmRleCAtIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgaWYoY29udGVudC5sZW5ndGgpe1xuICAgICAgdG9rZW5zLnB1c2goY29udGVudCk7XG4gICAgfVxuICAgIGlmKHBhcnNlRGVsaW0pe1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRGVsaW0uYXBwbHkoaW5zdGFuY2UsIG1hdGNoLnNsaWNlKDEpLmNvbmNhdCh0b2tlbnMubGVuZ3RoKSk7XG4gICAgICBpZih0eXBlb2YgcGFyc2VkICE9ICd1bmRlZmluZWQnKXtcbiAgICAgICAgaWYocGFyc2VkLnNwZWNpZmllciA9PT0gJyUnKXtcbiAgICAgICAgICB0b2tlbnMucHVzaCgnJScpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0b2tlbnMucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgfVxuICBjb250ZW50ID0gc3RyLnNsaWNlKGxhc3RJbmRleCk7XG4gIGlmKGNvbnRlbnQubGVuZ3RoKXtcbiAgICB0b2tlbnMucHVzaChjb250ZW50KTtcbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufVxuXG52YXIgRm9ybWF0dGVyID0gZnVuY3Rpb24oLypTdHJpbmcqLyBmb3JtYXQpe1xuICB2YXIgdG9rZW5zID0gW107XG4gIHRoaXMuX21hcHBlZCA9IGZhbHNlO1xuICB0aGlzLl9mb3JtYXQgPSBmb3JtYXQ7XG4gIHRoaXMuX3Rva2VucyA9IHRva2VuaXplKGZvcm1hdCwgdGhpcy5fcmUsIHRoaXMuX3BhcnNlRGVsaW0sIHRoaXMpO1xufVxuXG5Gb3JtYXR0ZXIucHJvdG90eXBlLl9yZSA9IC9cXCUoPzpcXCgoW1xcd19dKylcXCl8KFsxLTldXFxkKilcXCQpPyhbMCArXFwtXFwjXSopKFxcKnxcXGQrKT8oXFwuKT8oXFwqfFxcZCspP1tobExdPyhbXFwlYnNjZGVFZkZnR2lvT3V4WF0pL2c7XG5Gb3JtYXR0ZXIucHJvdG90eXBlLl9wYXJzZURlbGltID0gZnVuY3Rpb24obWFwcGluZywgaW50bWFwcGluZywgZmxhZ3MsIG1pbldpZHRoLCBwZXJpb2QsIHByZWNpc2lvbiwgc3BlY2lmaWVyKXtcbiAgaWYobWFwcGluZyl7XG4gICAgdGhpcy5fbWFwcGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1hcHBpbmc6IG1hcHBpbmcsXG4gICAgaW50bWFwcGluZzogaW50bWFwcGluZyxcbiAgICBmbGFnczogZmxhZ3MsXG4gICAgX21pbldpZHRoOiBtaW5XaWR0aCwgLy8gTWF5IGJlIGRlcGVuZGVudCBvbiBwYXJhbWV0ZXJzXG4gICAgcGVyaW9kOiBwZXJpb2QsXG4gICAgX3ByZWNpc2lvbjogcHJlY2lzaW9uLCAvLyBNYXkgYmUgZGVwZW5kZW50IG9uIHBhcmFtZXRlcnNcbiAgICBzcGVjaWZpZXI6IHNwZWNpZmllclxuICB9O1xufTtcbkZvcm1hdHRlci5wcm90b3R5cGUuX3NwZWNpZmllcnMgPSB7XG4gIGI6IHtcbiAgICBiYXNlOiAyLFxuICAgIGlzSW50OiB0cnVlXG4gIH0sXG4gIG86IHtcbiAgICBiYXNlOiA4LFxuICAgIGlzSW50OiB0cnVlXG4gIH0sXG4gIHg6IHtcbiAgICBiYXNlOiAxNixcbiAgICBpc0ludDogdHJ1ZVxuICB9LFxuICBYOiB7XG4gICAgZXh0ZW5kOiBbJ3gnXSxcbiAgICB0b1VwcGVyOiB0cnVlXG4gIH0sXG4gIGQ6IHtcbiAgICBiYXNlOiAxMCxcbiAgICBpc0ludDogdHJ1ZVxuICB9LFxuICBpOiB7XG4gICAgZXh0ZW5kOiBbJ2QnXVxuICB9LFxuICB1OiB7XG4gICAgZXh0ZW5kOiBbJ2QnXSxcbiAgICBpc1Vuc2lnbmVkOiB0cnVlXG4gIH0sXG4gIGM6IHtcbiAgICBzZXRBcmc6IGZ1bmN0aW9uKHRva2VuKXtcbiAgICAgIGlmKCFpc05hTih0b2tlbi5hcmcpKXtcbiAgICAgICAgdmFyIG51bSA9IHBhcnNlSW50KHRva2VuLmFyZyk7XG4gICAgICAgIGlmKG51bSA8IDAgfHwgbnVtID4gMTI3KXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2hhcmFjdGVyIGNvZGUgcGFzc2VkIHRvICVjIGluIHByaW50ZicpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuLmFyZyA9IGlzTmFOKG51bSkgPyAnJyArIG51bSA6IFN0cmluZy5mcm9tQ2hhckNvZGUobnVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHM6IHtcbiAgICBzZXRNYXhXaWR0aDogZnVuY3Rpb24odG9rZW4pe1xuICAgICAgdG9rZW4ubWF4V2lkdGggPSAodG9rZW4ucGVyaW9kID09ICcuJykgPyB0b2tlbi5wcmVjaXNpb24gOiAtMTtcbiAgICB9XG4gIH0sXG4gIGU6IHtcbiAgICBpc0RvdWJsZTogdHJ1ZSxcbiAgICBkb3VibGVOb3RhdGlvbjogJ2UnXG4gIH0sXG4gIEU6IHtcbiAgICBleHRlbmQ6IFsnZSddLFxuICAgIHRvVXBwZXI6IHRydWVcbiAgfSxcbiAgZjoge1xuICAgIGlzRG91YmxlOiB0cnVlLFxuICAgIGRvdWJsZU5vdGF0aW9uOiAnZidcbiAgfSxcbiAgRjoge1xuICAgIGV4dGVuZDogWydmJ11cbiAgfSxcbiAgZzoge1xuICAgIGlzRG91YmxlOiB0cnVlLFxuICAgIGRvdWJsZU5vdGF0aW9uOiAnZydcbiAgfSxcbiAgRzoge1xuICAgIGV4dGVuZDogWydnJ10sXG4gICAgdG9VcHBlcjogdHJ1ZVxuICB9LFxuICBPOiB7XG4gICAgaXNPYmplY3Q6IHRydWVcbiAgfSxcbn07XG5Gb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKC8qbWl4ZWQuLi4qLyBmaWxsZXIpe1xuICBpZih0aGlzLl9tYXBwZWQgJiYgdHlwZW9mIGZpbGxlciAhPSAnb2JqZWN0Jyl7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgcmVxdWlyZXMgYSBtYXBwaW5nJyk7XG4gIH1cblxuICB2YXIgc3RyID0gJyc7XG4gIHZhciBwb3NpdGlvbiA9IDA7XG4gIGZvcih2YXIgaSA9IDAsIHRva2VuOyBpIDwgdGhpcy5fdG9rZW5zLmxlbmd0aDsgaSsrKXtcbiAgICB0b2tlbiA9IHRoaXMuX3Rva2Vuc1tpXTtcbiAgICBcbiAgICBpZih0eXBlb2YgdG9rZW4gPT0gJ3N0cmluZycpe1xuICAgICAgc3RyICs9IHRva2VuO1xuICAgIH1lbHNle1xuICAgICAgaWYodGhpcy5fbWFwcGVkKXtcbiAgICAgICAgaWYodHlwZW9mIGZpbGxlclt0b2tlbi5tYXBwaW5nXSA9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGtleSAnICsgdG9rZW4ubWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4uYXJnID0gZmlsbGVyW3Rva2VuLm1hcHBpbmddO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKHRva2VuLmludG1hcHBpbmcpe1xuICAgICAgICAgIHBvc2l0aW9uID0gcGFyc2VJbnQodG9rZW4uaW50bWFwcGluZykgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBvc2l0aW9uID49IGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmludGYgYXJndW1lbnRzLCBpbnN1ZmZpY2llbnQgZm9yIFxcJycgKyB0aGlzLl9mb3JtYXQgKyAnXFwnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4uYXJnID0gYXJndW1lbnRzW3Bvc2l0aW9uKytdO1xuICAgICAgfVxuXG4gICAgICBpZighdG9rZW4uY29tcGlsZWQpe1xuICAgICAgICB0b2tlbi5jb21waWxlZCA9IHRydWU7XG4gICAgICAgIHRva2VuLnNpZ24gPSAnJztcbiAgICAgICAgdG9rZW4uemVyb1BhZCA9IGZhbHNlO1xuICAgICAgICB0b2tlbi5yaWdodEp1c3RpZnkgPSBmYWxzZTtcbiAgICAgICAgdG9rZW4uYWx0ZXJuYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZmxhZ3MgPSB7fTtcbiAgICAgICAgZm9yKHZhciBmaSA9IHRva2VuLmZsYWdzLmxlbmd0aDsgZmktLTspe1xuICAgICAgICAgIHZhciBmbGFnID0gdG9rZW4uZmxhZ3MuY2hhckF0KGZpKTtcbiAgICAgICAgICBmbGFnc1tmbGFnXSA9IHRydWU7XG4gICAgICAgICAgc3dpdGNoKGZsYWcpe1xuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgIHRva2VuLnNpZ24gPSAnICc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgIHRva2VuLnNpZ24gPSAnKyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICAgIHRva2VuLnplcm9QYWQgPSAoZmxhZ3NbJy0nXSkgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgIHRva2VuLnJpZ2h0SnVzdGlmeSA9IHRydWU7XG4gICAgICAgICAgICAgIHRva2VuLnplcm9QYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgdG9rZW4uYWx0ZXJuYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdiYWQgZm9ybWF0dGluZyBmbGFnIFxcJycgKyB0b2tlbi5mbGFncy5jaGFyQXQoZmkpICsgJ1xcJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuLm1pbldpZHRoID0gKHRva2VuLl9taW5XaWR0aCkgPyBwYXJzZUludCh0b2tlbi5fbWluV2lkdGgpIDogMDtcbiAgICAgICAgdG9rZW4ubWF4V2lkdGggPSAtMTtcbiAgICAgICAgdG9rZW4udG9VcHBlciA9IGZhbHNlO1xuICAgICAgICB0b2tlbi5pc1Vuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIHRva2VuLmlzSW50ID0gZmFsc2U7XG4gICAgICAgIHRva2VuLmlzRG91YmxlID0gZmFsc2U7XG4gICAgICAgIHRva2VuLmlzT2JqZWN0ID0gZmFsc2U7XG4gICAgICAgIHRva2VuLnByZWNpc2lvbiA9IDE7XG4gICAgICAgIGlmKHRva2VuLnBlcmlvZCA9PSAnLicpe1xuICAgICAgICAgIGlmKHRva2VuLl9wcmVjaXNpb24pe1xuICAgICAgICAgICAgdG9rZW4ucHJlY2lzaW9uID0gcGFyc2VJbnQodG9rZW4uX3ByZWNpc2lvbik7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0b2tlbi5wcmVjaXNpb24gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaXhpbnMgPSB0aGlzLl9zcGVjaWZpZXJzW3Rva2VuLnNwZWNpZmllcl07XG4gICAgICAgIGlmKHR5cGVvZiBtaXhpbnMgPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzcGVjaWZpZXIgXFwnJyArIHRva2VuLnNwZWNpZmllciArICdcXCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZihtaXhpbnMuZXh0ZW5kKXtcbiAgICAgICAgICB2YXIgcyA9IHRoaXMuX3NwZWNpZmllcnNbbWl4aW5zLmV4dGVuZF07XG4gICAgICAgICAgZm9yKHZhciBrIGluIHMpe1xuICAgICAgICAgICAgbWl4aW5zW2tdID0gc1trXVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgbWl4aW5zLmV4dGVuZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGwgaW4gbWl4aW5zKXtcbiAgICAgICAgICB0b2tlbltsXSA9IG1peGluc1tsXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZih0eXBlb2YgdG9rZW4uc2V0QXJnID09ICdmdW5jdGlvbicpe1xuICAgICAgICB0b2tlbi5zZXRBcmcodG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBpZih0eXBlb2YgdG9rZW4uc2V0TWF4V2lkdGggPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgIHRva2VuLnNldE1heFdpZHRoKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgaWYodG9rZW4uX21pbldpZHRoID09ICcqJyl7XG4gICAgICAgIGlmKHRoaXMuX21hcHBlZCl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcqIHdpZHRoIG5vdCBzdXBwb3J0ZWQgaW4gbWFwcGVkIGZvcm1hdHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbi5taW5XaWR0aCA9IHBhcnNlSW50KGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICAgIGlmKGlzTmFOKHRva2VuLm1pbldpZHRoKSl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgYXJndW1lbnQgZm9yICogd2lkdGggYXQgcG9zaXRpb24gJyArIHBvc2l0aW9uICsgJyBpcyBub3QgYSBudW1iZXIgaW4gJyArIHRoaXMuX2Zvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVnYXRpdmUgd2lkdGggbWVhbnMgcmlnaHRKdXN0aWZ5XG4gICAgICAgIGlmICh0b2tlbi5taW5XaWR0aCA8IDApIHtcbiAgICAgICAgICB0b2tlbi5yaWdodEp1c3RpZnkgPSB0cnVlO1xuICAgICAgICAgIHRva2VuLm1pbldpZHRoID0gLXRva2VuLm1pbldpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRva2VuLl9wcmVjaXNpb24gPT0gJyonICYmIHRva2VuLnBlcmlvZCA9PSAnLicpe1xuICAgICAgICBpZih0aGlzLl9tYXBwZWQpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignKiBwcmVjaXNpb24gbm90IHN1cHBvcnRlZCBpbiBtYXBwZWQgZm9ybWF0cycpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuLnByZWNpc2lvbiA9IHBhcnNlSW50KGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICAgIGlmKGlzTmFOKHRva2VuLnByZWNpc2lvbikpe1xuICAgICAgICAgIHRocm93IEVycm9yKCd0aGUgYXJndW1lbnQgZm9yICogcHJlY2lzaW9uIGF0IHBvc2l0aW9uICcgKyBwb3NpdGlvbiArICcgaXMgbm90IGEgbnVtYmVyIGluICcgKyB0aGlzLl9mb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZ2F0aXZlIHByZWNpc2lvbiBtZWFucyB1bnNwZWNpZmllZFxuICAgICAgICBpZiAodG9rZW4ucHJlY2lzaW9uIDwgMCkge1xuICAgICAgICAgIHRva2VuLnByZWNpc2lvbiA9IDE7XG4gICAgICAgICAgdG9rZW4ucGVyaW9kID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHRva2VuLmlzSW50KXtcbiAgICAgICAgLy8gYSBzcGVjaWZpZWQgcHJlY2lzaW9uIG1lYW5zIG5vIHplcm8gcGFkZGluZ1xuICAgICAgICBpZih0b2tlbi5wZXJpb2QgPT0gJy4nKXtcbiAgICAgICAgICB0b2tlbi56ZXJvUGFkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JtYXRJbnQodG9rZW4pO1xuICAgICAgfWVsc2UgaWYodG9rZW4uaXNEb3VibGUpe1xuICAgICAgICBpZih0b2tlbi5wZXJpb2QgIT0gJy4nKXtcbiAgICAgICAgICB0b2tlbi5wcmVjaXNpb24gPSA2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9ybWF0RG91YmxlKHRva2VuKTsgXG4gICAgICB9ZWxzZSBpZih0b2tlbi5pc09iamVjdCl7XG4gICAgICAgIHRoaXMuZm9ybWF0T2JqZWN0KHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZml0RmllbGQodG9rZW4pO1xuXG4gICAgICBzdHIgKz0gJycgKyB0b2tlbi5hcmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5Gb3JtYXR0ZXIucHJvdG90eXBlLl96ZXJvczEwID0gJzAwMDAwMDAwMDAnO1xuRm9ybWF0dGVyLnByb3RvdHlwZS5fc3BhY2VzMTAgPSAnICAgICAgICAgICc7XG5Gb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdEludCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIHZhciBpID0gcGFyc2VJbnQodG9rZW4uYXJnKTtcbiAgaWYoIWlzRmluaXRlKGkpKXsgLy8gaXNOYU4oZikgfHwgZiA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgZiA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpXG4gICAgLy8gYWxsb3cgdGhpcyBvbmx5IGlmIGFyZyBpcyBudW1iZXJcbiAgICBpZih0eXBlb2YgdG9rZW4uYXJnICE9ICdudW1iZXInKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IGFyZ3VtZW50IFxcJycgKyB0b2tlbi5hcmcgKyAnXFwnIG5vdCBhbiBpbnRlZ2VyOyBwYXJzZUludCByZXR1cm5lZCAnICsgaSk7XG4gICAgfVxuICAgIC8vcmV0dXJuICcnICsgaTtcbiAgICBpID0gMDtcbiAgfVxuXG4gIC8vIGlmIG5vdCBiYXNlIDEwLCBtYWtlIG5lZ2F0aXZlcyBiZSBwb3NpdGl2ZVxuICAvLyBvdGhlcndpc2UsICgtMTApLnRvU3RyaW5nKDE2KSBpcyAnLWEnIGluc3RlYWQgb2YgJ2ZmZmZmZmY2J1xuICBpZihpIDwgMCAmJiAodG9rZW4uaXNVbnNpZ25lZCB8fCB0b2tlbi5iYXNlICE9IDEwKSl7XG4gICAgaSA9IDB4ZmZmZmZmZmYgKyBpICsgMTtcbiAgfSBcblxuICBpZihpIDwgMCl7XG4gICAgdG9rZW4uYXJnID0gKC0gaSkudG9TdHJpbmcodG9rZW4uYmFzZSk7XG4gICAgdGhpcy56ZXJvUGFkKHRva2VuKTtcbiAgICB0b2tlbi5hcmcgPSAnLScgKyB0b2tlbi5hcmc7XG4gIH1lbHNle1xuICAgIHRva2VuLmFyZyA9IGkudG9TdHJpbmcodG9rZW4uYmFzZSk7XG4gICAgLy8gbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhcmd1bWVudCAwIHdpdGggcHJlY2lzaW9uPT0wIGlzIGZvcm1hdHRlZCBhcyAnJ1xuICAgIGlmKCFpICYmICF0b2tlbi5wcmVjaXNpb24pe1xuICAgICAgdG9rZW4uYXJnID0gJyc7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLnplcm9QYWQodG9rZW4pO1xuICAgIH1cbiAgICBpZih0b2tlbi5zaWduKXtcbiAgICAgIHRva2VuLmFyZyA9IHRva2VuLnNpZ24gKyB0b2tlbi5hcmc7XG4gICAgfVxuICB9XG4gIGlmKHRva2VuLmJhc2UgPT0gMTYpe1xuICAgIGlmKHRva2VuLmFsdGVybmF0aXZlKXtcbiAgICAgIHRva2VuLmFyZyA9ICcweCcgKyB0b2tlbi5hcmc7XG4gICAgfVxuICAgIHRva2VuLmFyZyA9IHRva2VuLnRvVXBwZXIgPyB0b2tlbi5hcmcudG9VcHBlckNhc2UoKSA6IHRva2VuLmFyZy50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGlmKHRva2VuLmJhc2UgPT0gOCl7XG4gICAgaWYodG9rZW4uYWx0ZXJuYXRpdmUgJiYgdG9rZW4uYXJnLmNoYXJBdCgwKSAhPSAnMCcpe1xuICAgICAgdG9rZW4uYXJnID0gJzAnICsgdG9rZW4uYXJnO1xuICAgIH1cbiAgfVxufTtcbkZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0RG91YmxlID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgdmFyIGYgPSBwYXJzZUZsb2F0KHRva2VuLmFyZyk7XG4gIGlmKCFpc0Zpbml0ZShmKSl7IC8vIGlzTmFOKGYpIHx8IGYgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IGYgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxuICAgIC8vIGFsbG93IHRoaXMgb25seSBpZiBhcmcgaXMgbnVtYmVyXG4gICAgaWYodHlwZW9mIHRva2VuLmFyZyAhPSAnbnVtYmVyJyl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBhcmd1bWVudCBcXCcnICsgdG9rZW4uYXJnICsgJ1xcJyBub3QgYSBmbG9hdDsgcGFyc2VGbG9hdCByZXR1cm5lZCAnICsgZik7XG4gICAgfVxuICAgIC8vIEM5OSBzYXlzIHRoYXQgZm9yICdmJzpcbiAgICAvLyAgIGluZmluaXR5IC0+ICdbLV1pbmYnIG9yICdbLV1pbmZpbml0eScgKCdbLV1JTkYnIG9yICdbLV1JTkZJTklUWScgZm9yICdGJylcbiAgICAvLyAgIE5hTiAtPiBhIHN0cmluZyAgc3RhcnRpbmcgd2l0aCAnbmFuJyAoJ05BTicgZm9yICdGJylcbiAgICAvLyB0aGlzIGlzIG5vdCBjb21tb25seSBpbXBsZW1lbnRlZCB0aG91Z2guXG4gICAgLy9yZXR1cm4gJycgKyBmO1xuICAgIGYgPSAwO1xuICB9XG5cbiAgc3dpdGNoKHRva2VuLmRvdWJsZU5vdGF0aW9uKSB7XG4gICAgY2FzZSAnZSc6IHtcbiAgICAgIHRva2VuLmFyZyA9IGYudG9FeHBvbmVudGlhbCh0b2tlbi5wcmVjaXNpb24pOyBcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdmJzoge1xuICAgICAgdG9rZW4uYXJnID0gZi50b0ZpeGVkKHRva2VuLnByZWNpc2lvbik7IFxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ2cnOiB7XG4gICAgICAvLyBDIHNheXMgdXNlICdlJyBub3RhdGlvbiBpZiBleHBvbmVudCBpcyA8IC00IG9yIGlzID49IHByZWNcbiAgICAgIC8vIEVDTUFTY3JpcHQgZm9yIHRvUHJlY2lzaW9uIHNheXMgdXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIGV4cG9uZW50IGlzID49IHByZWMsXG4gICAgICAvLyB0aG91Z2ggc3RlcCAxNyBvZiB0b1ByZWNpc2lvbiBpbmRpY2F0ZXMgYSB0ZXN0IGZvciA8IC02IHRvIGZvcmNlIGV4cG9uZW50aWFsLlxuICAgICAgaWYoTWF0aC5hYnMoZikgPCAwLjAwMDEpe1xuICAgICAgICAvL3ByaW50KCdmb3JjaW5nIGV4cG9uZW50aWFsIG5vdGF0aW9uIGZvciBmPScgKyBmKTtcbiAgICAgICAgdG9rZW4uYXJnID0gZi50b0V4cG9uZW50aWFsKHRva2VuLnByZWNpc2lvbiA+IDAgPyB0b2tlbi5wcmVjaXNpb24gLSAxIDogdG9rZW4ucHJlY2lzaW9uKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0b2tlbi5hcmcgPSBmLnRvUHJlY2lzaW9uKHRva2VuLnByZWNpc2lvbik7IFxuICAgICAgfVxuXG4gICAgICAvLyBJbiBDLCB1bmxpa2UgJ2YnLCAnZ0cnIHJlbW92ZXMgdHJhaWxpbmcgMHMgZnJvbSBmcmFjdGlvbmFsIHBhcnQsIHVubGVzcyBhbHRlcm5hdGl2ZSBmb3JtYXQgZmxhZyAoJyMnKS5cbiAgICAgIC8vIEJ1dCBFQ01BU2NyaXB0IGZvcm1hdHMgdG9QcmVjaXNpb24gYXMgMC4wMDEwMDAwMC4gU28gcmVtb3ZlIHRyYWlsaW5nIDBzLlxuICAgICAgaWYoIXRva2VuLmFsdGVybmF0aXZlKXsgXG4gICAgICAgIC8vcHJpbnQoJ3JlcGxhY2luZyB0cmFpbGluZyAwIGluIFxcJycgKyBzICsgJ1xcJycpO1xuICAgICAgICB0b2tlbi5hcmcgPSB0b2tlbi5hcmcucmVwbGFjZSgvKFxcLi4qW14wXSkwKmUvLCAnJDFlJyk7XG4gICAgICAgIC8vIGlmIGZyYWN0aW9uYWwgcGFydCBpcyBlbnRpcmVseSAwLCByZW1vdmUgaXQgYW5kIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgdG9rZW4uYXJnID0gdG9rZW4uYXJnLnJlcGxhY2UoL1xcLjAqZS8sICdlJykucmVwbGFjZSgvXFwuMCQvLCcnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZG91YmxlIG5vdGF0aW9uIFxcJycgKyB0b2tlbi5kb3VibGVOb3RhdGlvbiArICdcXCcnKTtcbiAgfVxuXG4gIC8vIEMgc2F5cyB0aGF0IGV4cG9uZW50IG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAvLyBCdXQgRUNNQVNjcmlwdCBkb2VzIG5vdDsgdG9FeHBvbmVudGlhbCByZXN1bHRzIGluIHRoaW5ncyBsaWtlICcxLjAwMDAwMGUtOCcgYW5kICcxLjAwMDAwMGUrOCcuXG4gIC8vIE5vdGUgdGhhdCBzLnJlcGxhY2UoL2UoW1xcK1xcLV0pKFxcZCkvLCAnZSQxMCQyJykgd29uJ3Qgd29yayBiZWNhdXNlIG9mIHRoZSAnJDEwJyBpbnN0ZWFkIG9mICckMScuXG4gIC8vIEFuZCByZXBsYWNlKHJlLCBmdW5jKSBpc24ndCBzdXBwb3J0ZWQgb24gSUU1MCBvciBTYWZhcmkxLlxuICB0b2tlbi5hcmcgPSB0b2tlbi5hcmcucmVwbGFjZSgvZVxcKyhcXGQpJC8sICdlKzAkMScpLnJlcGxhY2UoL2VcXC0oXFxkKSQvLCAnZS0wJDEnKTtcblxuICAvLyBpZiBhbHQsIGVuc3VyZSBhIGRlY2ltYWwgcG9pbnRcbiAgaWYodG9rZW4uYWx0ZXJuYXRpdmUpe1xuICAgIHRva2VuLmFyZyA9IHRva2VuLmFyZy5yZXBsYWNlKC9eKFxcZCspJC8sJyQxLicpO1xuICAgIHRva2VuLmFyZyA9IHRva2VuLmFyZy5yZXBsYWNlKC9eKFxcZCspZS8sJyQxLmUnKTtcbiAgfVxuXG4gIGlmKGYgPj0gMCAmJiB0b2tlbi5zaWduKXtcbiAgICB0b2tlbi5hcmcgPSB0b2tlbi5zaWduICsgdG9rZW4uYXJnO1xuICB9XG5cbiAgdG9rZW4uYXJnID0gdG9rZW4udG9VcHBlciA/IHRva2VuLmFyZy50b1VwcGVyQ2FzZSgpIDogdG9rZW4uYXJnLnRvTG93ZXJDYXNlKCk7XG59O1xuRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXRPYmplY3QgPSBmdW5jdGlvbih0b2tlbikge1xuICAvLyBJZiBubyBwcmVjaXNpb24gaXMgc3BlY2lmaWVkLCB0aGVuIHJlc2V0IGl0IHRvIG51bGwgKGluZmluaXRlIGRlcHRoKS5cbiAgdmFyIHByZWNpc2lvbiA9ICh0b2tlbi5wZXJpb2QgPT09ICcuJykgPyB0b2tlbi5wcmVjaXNpb24gOiBudWxsO1xuICB0b2tlbi5hcmcgPSB1dGlsLmluc3BlY3QodG9rZW4uYXJnLCAhdG9rZW4uYWx0ZXJuYXRpdmUsIHByZWNpc2lvbik7XG59O1xuRm9ybWF0dGVyLnByb3RvdHlwZS56ZXJvUGFkID0gZnVuY3Rpb24odG9rZW4sIC8qSW50Ki8gbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IChhcmd1bWVudHMubGVuZ3RoID09IDIpID8gbGVuZ3RoIDogdG9rZW4ucHJlY2lzaW9uO1xuICB2YXIgbmVnYXRpdmUgPSBmYWxzZTtcbiAgaWYodHlwZW9mIHRva2VuLmFyZyAhPSBcInN0cmluZ1wiKXtcbiAgICB0b2tlbi5hcmcgPSBcIlwiICsgdG9rZW4uYXJnO1xuICB9XG4gIGlmICh0b2tlbi5hcmcuc3Vic3RyKDAsMSkgPT09ICctJykge1xuICAgIG5lZ2F0aXZlID0gdHJ1ZTtcbiAgICB0b2tlbi5hcmcgPSB0b2tlbi5hcmcuc3Vic3RyKDEpO1xuICB9XG5cbiAgdmFyIHRlbmxlc3MgPSBsZW5ndGggLSAxMDtcbiAgd2hpbGUodG9rZW4uYXJnLmxlbmd0aCA8IHRlbmxlc3Mpe1xuICAgIHRva2VuLmFyZyA9ICh0b2tlbi5yaWdodEp1c3RpZnkpID8gdG9rZW4uYXJnICsgdGhpcy5femVyb3MxMCA6IHRoaXMuX3plcm9zMTAgKyB0b2tlbi5hcmc7XG4gIH1cbiAgdmFyIHBhZCA9IGxlbmd0aCAtIHRva2VuLmFyZy5sZW5ndGg7XG4gIHRva2VuLmFyZyA9ICh0b2tlbi5yaWdodEp1c3RpZnkpID8gdG9rZW4uYXJnICsgdGhpcy5femVyb3MxMC5zdWJzdHJpbmcoMCwgcGFkKSA6IHRoaXMuX3plcm9zMTAuc3Vic3RyaW5nKDAsIHBhZCkgKyB0b2tlbi5hcmc7XG4gIGlmIChuZWdhdGl2ZSkgdG9rZW4uYXJnID0gJy0nICsgdG9rZW4uYXJnO1xufTtcbkZvcm1hdHRlci5wcm90b3R5cGUuZml0RmllbGQgPSBmdW5jdGlvbih0b2tlbikge1xuICBpZih0b2tlbi5tYXhXaWR0aCA+PSAwICYmIHRva2VuLmFyZy5sZW5ndGggPiB0b2tlbi5tYXhXaWR0aCl7XG4gICAgcmV0dXJuIHRva2VuLmFyZy5zdWJzdHJpbmcoMCwgdG9rZW4ubWF4V2lkdGgpO1xuICB9XG4gIGlmKHRva2VuLnplcm9QYWQpe1xuICAgIHRoaXMuemVyb1BhZCh0b2tlbiwgdG9rZW4ubWluV2lkdGgpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnNwYWNlUGFkKHRva2VuKTtcbn07XG5Gb3JtYXR0ZXIucHJvdG90eXBlLnNwYWNlUGFkID0gZnVuY3Rpb24odG9rZW4sIC8qSW50Ki8gbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IChhcmd1bWVudHMubGVuZ3RoID09IDIpID8gbGVuZ3RoIDogdG9rZW4ubWluV2lkdGg7XG4gIGlmKHR5cGVvZiB0b2tlbi5hcmcgIT0gJ3N0cmluZycpe1xuICAgIHRva2VuLmFyZyA9ICcnICsgdG9rZW4uYXJnO1xuICB9XG4gIHZhciB0ZW5sZXNzID0gbGVuZ3RoIC0gMTA7XG4gIHdoaWxlKHRva2VuLmFyZy5sZW5ndGggPCB0ZW5sZXNzKXtcbiAgICB0b2tlbi5hcmcgPSAodG9rZW4ucmlnaHRKdXN0aWZ5KSA/IHRva2VuLmFyZyArIHRoaXMuX3NwYWNlczEwIDogdGhpcy5fc3BhY2VzMTAgKyB0b2tlbi5hcmc7XG4gIH1cbiAgdmFyIHBhZCA9IGxlbmd0aCAtIHRva2VuLmFyZy5sZW5ndGg7XG4gIHRva2VuLmFyZyA9ICh0b2tlbi5yaWdodEp1c3RpZnkpID8gdG9rZW4uYXJnICsgdGhpcy5fc3BhY2VzMTAuc3Vic3RyaW5nKDAsIHBhZCkgOiB0aGlzLl9zcGFjZXMxMC5zdWJzdHJpbmcoMCwgcGFkKSArIHRva2VuLmFyZztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgc3RyZWFtLCBmb3JtYXQ7XG4gIGlmKGFyZ3NbMF0gaW5zdGFuY2VvZiByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW0pe1xuICAgIHN0cmVhbSA9IGFyZ3Muc2hpZnQoKTtcbiAgfVxuICBmb3JtYXQgPSBhcmdzLnNoaWZ0KCk7XG4gIHZhciBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKGZvcm1hdCk7XG4gIHZhciBzdHJpbmcgPSBmb3JtYXR0ZXIuZm9ybWF0LmFwcGx5KGZvcm1hdHRlciwgYXJncyk7XG4gIGlmKHN0cmVhbSl7XG4gICAgc3RyZWFtLndyaXRlKHN0cmluZyk7XG4gIH1lbHNle1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkZvcm1hdHRlciA9IEZvcm1hdHRlcjtcblxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlNaXJyb3JcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgb2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaiksXG4gICAgJ2tleU1pcnJvciguLi4pOiBBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nXG4gICkgOiBpbnZhcmlhbnQob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpKTtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcbiIsImNvbnN0IGtleU1pcnJvciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9rZXlNaXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3Ioe1xuICAgIE1JU1NJT05fU1RBUlRFRCA6IG51bGwsXG4gICAgTUlTU0lPTl9TVE9QUEVEIDogbnVsbCxcbiAgICBNSVNTSU9OX1JFU0VUIDogbnVsbCxcbiAgICBNSVNTSU9OX0NPTVBMRVRFRCA6IG51bGwsXG4gICAgQVBQX1NUQVRFIDogbnVsbCxcblxuICAgIEFERF9NRVNTQUdFIDogbnVsbCxcblxuICAgIC8vQUNUSU9OU1xuICAgIEdFVF9FVkVOVFMgOiBudWxsLFxuICAgIFNFVF9FVkVOVFMgOiBudWxsLFxuICAgIFRSSUdHRVJfRVZFTlQgOiBudWxsLFxuICAgIEFEVkFOQ0VfQ0hBUFRFUiA6IG51bGwsXG4gICAgQ09NUExFVEVfTUlTU0lPTiA6IG51bGwsXG5cbiAgICAvLyBTQ0lFTkNFIFRFQU0gRVZFTlRTXG4gICAgU0NJRU5DRV9DSEVDS19SQURJQVRJT04gOiBudWxsLFxuXG4gICAgLy8gQVNUUk9OQVVUIFRFQU0gRVZFTlRTXG4gICAgQVNUX0NIRUNLX1ZJVEFMUyA6IG51bGwsXG5cbiAgICAvLyBDT01NVU5JQ0FUSU9OIFRFQU0gRVZFTlRTXG4gICAgQ09NTV9JTkZPUk1fQVNUUk9OQVVUIDogbnVsbCxcbiAgICBDT01NX0NIRUNLX1NBVF9MSU5LOiBudWxsLFxuXG5cbiAgICAvLyBTRUNVUklUWSBURUFNIEVWRU5UU1xuICAgIFNFVF9ISUdIX0MwMiA6IG51bGwsXG4gICAgU0VDVVJJVFlfQ0hFQ0tfREFUQV9UUkFOU0ZFUiA6IG51bGwsXG5cblxuICAgIFNFVF9IRUFSVF9SQVRFX0hJR0ggOiBudWxsLFxuICAgIFNFVF9IRUFSVF9SQVRFX01FRElVTSA6IG51bGwsXG4gICAgU0VUX0hFQVJUX1JBVEVfTE9XIDogbnVsbFxufSk7XG4iXX0=
