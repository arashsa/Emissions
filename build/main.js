(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./app/main.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var document = require('global/document');
var window = require('global/window');
var serverCommunication = require('./client-api');

// the actual rigging of the application is done in the router!
var router = require('./router-container');

var AppDispatcher = require('./appdispatcher');
var constants = require('./constants/RouterConstants');

serverCommunication.setup();

// the mission timer gets out sync if losing focus, so resync with server every time the window regains focus
window.onfocus = serverCommunication.askForMissionTime;

// run startup actions - usually only relevant when developing
require('./client-bootstrap').run();

router.run(function (Handler, state) {
    // pass the state down into the RouteHandlers, as that will make
    // the router related properties available on each RH. Taken from Upgrade tips for React Router
    React.render(React.createElement(Handler, state), document.body);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","./client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","./client-bootstrap":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-bootstrap.js","./constants/RouterConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/RouterConstants.js","./router-container":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js","global/document":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/global/document.js","global/window":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/global/window.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/AstroTeamActionCreators.js":[function(require,module,exports){
'use strict';

var Dispatcher = require('../appdispatcher');
var MConstants = require('../constants/MissionConstants');
var AstConstants = require('../constants/AstroTeamConstants');
var MessageActionCreators = require('./MessageActionCreators');
var utils = require('../utils');

// lazy load due to avoid circular dependencies
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
var getServerAPI = lazyRequire('../client-api');
var getMissionAC = lazyRequire('./MissionActionCreators');
// for browserify to work it needs to find these magic strings
require('./MissionActionCreators');
require('../client-api');
var TimerActionCreators = require('./TimerActionCreators');

window.__astActions = module.exports = {

    /* in units per minute */
    setOxygenConsumption: function setOxygenConsumption(units) {
        getServerAPI().setOxygenConsumption(units);
    },

    heartRateRead: function heartRateRead(rate) {
        var text, level;
        if (rate < 90) {
            level = 'info';
            text = 'Fine verdier';
        } else if (rate > 120) {
            text = 'Veldig høye verdier!';
            level = 'danger';
        } else {
            text = 'Ganske høy hjerterytme. Grunn til bekymring?';
            level = 'warning';
        }

        MessageActionCreators.addMessage({ text: text, level: level, duration: 20 });
    },

    startMonitorTask: function startMonitorTask() {

        TimerActionCreators.resetTimer(AstConstants.HEART_RATE_TIMER);
        TimerActionCreators.resetTimer(AstConstants.RESPIRATION_TIMER);
        getMissionAC().startTask('astronaut', 'breathing_timer');
    }

};

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","./MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","./TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

var AppDispatcher = require('../appdispatcher'),
    uuid = require('./../utils').uuid,
    constants = require('../constants/MessageConstants');

var actions = {

    /**
     * @param msg.text the message
     * @param [msg.id] the message id. if not given, one will be created
     * @param [msg.level] same as bootstrap's alert classes: [success, info, warning, danger]
     * @param [msg.duration] {Number} optional duration for transient messages
     *
     * @returns {string} the message id
     */
    addMessage: function addMessage(msg) {
        var id = msg.id;

        if (!id) {
            id = uuid();
            msg.id = id;
        }

        if (!msg.level) {
            msg.level = 'success';
        }

        AppDispatcher.dispatch({
            action: constants.MESSAGE_ADDED,
            data: msg
        });

        if (msg.duration) {
            setTimeout(function () {
                return actions.removeMessage(msg.id);
            }, msg.duration * 1000);
        }

        return id;
    },

    /**
     * msg with default duration of 5 seconds
     * @param msg
     * @param [duration] default of 5 seconds
     *
     * @see #addMessage() for more params
     * @returns {string} the message id
     */
    addTransientMessage: function addTransientMessage(msg) {
        var duration = arguments[1] === undefined ? 5 : arguments[1];

        return actions.addMessage(_Object$assign({ duration: duration }, msg));
    },

    removeMessage: function removeMessage(id) {
        AppDispatcher.dispatch({
            action: constants.REMOVE_MESSAGE,
            data: id
        });
    }

};

// prevent new properties from being added or removed
_Object$freeze(actions);
window.__MessageActions = actions;
module.exports = actions;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MessageConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MessageConstants.js","./../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher'),
    MissionConstants = require('../constants/MissionConstants'),
    router = require('./../router-container');

// lazy load due to circular dependencies
var serverAPI = (function () {
    var api;

    return function () {
        if (!api) {
            api = require('../client-api');
        }
        return api;
    };
})();

var tmp = {

    startMission: function startMission() {
        serverAPI().startMission();
    },

    stopMission: function stopMission() {
        serverAPI().stopMission();
    },

    resetMission: function resetMission() {
        serverAPI().resetMission();
    },

    missionStarted: function missionStarted() {
        AppDispatcher.dispatch({ action: MissionConstants.MISSION_STARTED_EVENT });
    },

    missionStopped: function missionStopped() {
        AppDispatcher.dispatch({ action: MissionConstants.MISSION_STOPPED_EVENT });
    },

    missionWasReset: function missionWasReset() {
        AppDispatcher.dispatch({ action: MissionConstants.MISSION_WAS_RESET });
        serverAPI().askForAppState();
    },

    missionCompleted: function missionCompleted() {
        //AppDispatcher.dispatch({action: MissionConstants.MISSION_COMPLETED_EVENT});
        router.transitionTo('/completed');
    },

    completeMission: function completeMission() {
        serverAPI().completeMission();
    },

    receivedEvents: function receivedEvents(eventsCollection) {
        AppDispatcher.dispatch(_Object$assign({}, eventsCollection, { action: MissionConstants.RECEIVED_EVENTS }));
    },

    askForEvents: function askForEvents() {
        serverAPI().askForEvents();
    },

    introWasRead: function introWasRead(teamId) {
        AppDispatcher.dispatch({ action: MissionConstants.INTRODUCTION_READ, teamName: teamId });
        serverAPI().sendTeamStateChange();
    },

    changeScrubber: function changeScrubber() {
        serverAPI().askToChangeScrubFilter();
    },

    startTask: function startTask(teamId, taskId) {
        AppDispatcher.dispatch({ action: MissionConstants.START_TASK, teamId: teamId, taskId: taskId });
        serverAPI().sendTeamStateChange();
    },

    taskCompleted: function taskCompleted(teamId, taskId) {
        AppDispatcher.dispatch({ action: MissionConstants.COMPLETED_TASK, taskId: taskId, teamId: teamId });
        serverAPI().sendTeamStateChange();

        // also publish this to server as separate event? - maybe to trigger something at certain point?
    },

    askToStartNextChapter: function askToStartNextChapter() {
        serverAPI().askToStartNextChapter();
    },

    askToTriggerEvent: function askToTriggerEvent(uuid) {
        serverAPI().triggerEvent(uuid);
    },

    setMissionTime: function setMissionTime(elapsedSeconds) {
        AppDispatcher.dispatch({
            action: MissionConstants.MISSION_TIME_SYNC,
            data: { elapsedMissionTime: elapsedSeconds }
        });
    }

};

window.__MissionAC = tmp;
module.exports = tmp;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./../router-container":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js":[function(require,module,exports){
'use strict';

var AppDispatcher = require('../appdispatcher');
var RadiationStore = require('./../stores/radiation-store');
var ScienceTeamConstants = require('../constants/ScienceTeamConstants');
var MissionConstants = require('../constants/MissionConstants');
var MessageActionsCreators = require('./MessageActionCreators');
var TimerActionCreators = require('../actions/TimerActionCreators');
var api = require('../client-api');

var missionActionCreators = (function () {
    var tmp;

    return function () {
        if (!tmp) tmp = require('../actions/MissionActionCreators');
        return tmp;
    };
})();

var actions = {

    startSampleTask: function startSampleTask() {
        AppDispatcher.dispatch({ action: ScienceTeamConstants.SCIENCE_CLEAR_RADIATION_SAMPLES });
        missionActionCreators().startTask('science', 'sample');
        this.resetSamplingTimer();
    },

    completeTask: function completeTask(taskId) {
        missionActionCreators().taskCompleted('science', taskId);
    },

    resetSamplingTimer: function resetSamplingTimer() {
        TimerActionCreators.resetTimer(ScienceTeamConstants.SCIENCE_TIMER_1);
    },

    takeRadiationSample: function takeRadiationSample() {
        AppDispatcher.dispatch({
            action: ScienceTeamConstants.SCIENCE_TAKE_RADIATION_SAMPLE
        });
    },

    averageRadiationCalculated: function averageRadiationCalculated(average) {
        var samples = RadiationStore.getSamples();

        if (samples.length) {
            var sum = samples.reduce(function (prev, current) {
                return prev + current;
            }, 0),
                trueCalculatedAverage = sum / samples.length,
                diffInPercent = 100 * Math.abs((trueCalculatedAverage - average) / trueCalculatedAverage);

            if (diffInPercent > 15) {
                MessageActionsCreators.addTransientMessage({ text: 'Mulig det gjennomsnittet ble litt feil.' });
            }
        }

        AppDispatcher.dispatch({
            action: ScienceTeamConstants.SCIENCE_AVG_RADIATION_CALCULATED,
            data: { average: average }
        });

        if (average > ScienceTeamConstants.SCIENCE_AVG_RAD_RED_THRESHOLD) {
            MessageActionsCreators.addTransientMessage({
                text: 'Veldig høyt radioaktivt nivå detektert. Varsle sikkerhetsteamet umiddelbart!',
                level: 'danger',
                id: ScienceTeamConstants.SCIENCE_RADIATION_WARNING_MSG
            }, 30);
        } else if (average > ScienceTeamConstants.SCIENCE_AVG_RAD_ORANGE_THRESHOLD) {
            MessageActionsCreators.addTransientMessage({
                text: 'Høye verdier av radioaktivitet. Følg med på om det går nedover igjen',
                level: 'warning',
                id: ScienceTeamConstants.SCIENCE_RADIATION_WARNING_MSG
            }, 10);
        }

        this.completeTask('average');
    },

    /**
     * Set the radiation level that will be reported to the view layer
     * The reported radiation will generated values in the range given by the parameters
     *
     * We are not actually receiving a stream of values from the server, as that could
     * be very resource heavy. Instead we generate random values between the given values,
     * which to the user will look the same.
     * @param min
     * @param max
     */
    setRadiationLevel: function setRadiationLevel(min, max) {
        AppDispatcher.dispatch({
            action: ScienceTeamConstants.SCIENCE_RADIATION_LEVEL_CHANGED,
            data: { min: min, max: max }
        });
    },

    addToTotalRadiationLevel: function addToTotalRadiationLevel(amount) {

        var total = amount + RadiationStore.getTotalLevel();

        if (total > ScienceTeamConstants.SCIENCE_TOTAL_RADIATION_VERY_SERIOUS_THRESHOLD) {
            MessageActionsCreators.addTransientMessage({
                id: 'science_high_radiation_level',
                text: 'Faretruende høyt strålingsnivå!',
                level: 'danger'
            }, 30);
        } else if (total > ScienceTeamConstants.SCIENCE_TOTAL_RADIATION_SERIOUS_THRESHOLD) {
            MessageActionsCreators.addTransientMessage({
                id: 'science_high_radiation_level',
                text: 'Høyt strålingsnivå!',
                level: 'warning'
            }, 30);
        }

        AppDispatcher.dispatch({
            action: ScienceTeamConstants.SCIENCE_TOTAL_RADIATION_LEVEL_CHANGED,
            data: { total: total, added: amount }
        });

        this.completeTask('addtotal');
    }

};

window.__ScienceActions = actions;
module.exports = actions;

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","./../stores/radiation-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/radiation-store.js","./MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/SecurityTeamActionCreators.js":[function(require,module,exports){
'use strict';

var MessageActionCreators = require('../actions/MessageActionCreators');

// lazy load due to avoid circular dependencies
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
var getMissionAC = lazyRequire('./MissionActionCreators');
var getServerAPI = lazyRequire('../client-api');
// for browserify to work it needs to find these magic strings
require('./MissionActionCreators');
require('../client-api');

var actions = module.exports = {
    startDataTransferCheck: function startDataTransferCheck() {
        getMissionAC().startTask('security', 'signal_test');
    },

    endDataQualityTest: function endDataQualityTest(goodOutcome) {
        if (!goodOutcome) {
            MessageActionCreators.addMessage({
                text: 'Kvaliteten på kommunikasjonssignalet er for dårlig. Er reparasjonen fullført?',
                level: 'warning',
                duration: 10
            });
        } else {
            MessageActionCreators.addMessage({
                text: 'TEST OK', duration: 2, level: 'info'
            });
            actions.sendReadyForSafeMode();
        }
        getMissionAC().taskCompleted('security', 'signal_test');
    },

    endDataTransferTest: function endDataTransferTest(goodOutcome) {
        if (!goodOutcome) {
            MessageActionCreators.addMessage({
                text: 'Overføringen av data var for ustabil. Testen feilet.',
                level: 'warning',
                duration: 10
            });
            getMissionAC().taskCompleted('security', 'signal_test');
        } else {
            MessageActionCreators.addMessage({
                text: 'TEST OK', duration: 2, level: 'info'
            });
        }
    },

    sendReadyForSafeMode: function sendReadyForSafeMode() {
        getServerAPI().setReadyForSafeMode();
    },

    setInSafeMode: function setInSafeMode() {
        getServerAPI().setInSafeMode();
    }
};

window.__SecTeamActions = actions;

},{"../actions/MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","../client-api":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js","./MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js":[function(require,module,exports){
'use strict';

var AppDispatcher = require('../appdispatcher');
var constants = require('../constants/TimerConstants');

var actions = {

    startTimer: function startTimer(id) {
        AppDispatcher.dispatch({ action: constants.START_TIMER, data: { timerId: id } });
    },

    resetTimer: function resetTimer(id) {
        AppDispatcher.dispatch({ action: constants.RESET_TIMER, data: { timerId: id } });
    },

    stopTimer: function stopTimer(id) {
        AppDispatcher.dispatch({ action: constants.STOP_TIMER, data: { timerId: id } });
    },

    setTimer: function setTimer(timerId, time) {
        AppDispatcher.dispatch({
            action: constants.SET_TIMER,
            data: {
                remainingTime: time,
                timerId: timerId
            }
        });
    }

};

module.exports = actions;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/TimerConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/TimerConstants.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js":[function(require,module,exports){
/*
 * Dispatcher - a singleton
 *
 * This is essentially the main driver in the Flux architecture
 * @see http://facebook.github.io/flux/docs/overview.html
*/

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _require = require('flux');

var Dispatcher = _require.Dispatcher;

var AppDispatcher = _Object$assign(new Dispatcher(), {});

window.__AppDispatcher = AppDispatcher;
module.exports = AppDispatcher;

// optional methods

},{"babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","flux":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-api.js":[function(require,module,exports){
(function (global){
'use strict';

var AppDispatcher = require('./appdispatcher');
var io = (typeof window !== "undefined" ? window.io : typeof global !== "undefined" ? global.io : null);
var socket = io();
var MissionConstants = require('./constants/MissionConstants');
var MissionActionCreators = require('./actions/MissionActionCreators');
var MessageActionCreators = require('./actions/MessageActionCreators');
var ScienceTeamActionCreators = require('./actions/ScienceActionCreators');
var SecurityTeamActionCreators = require('./actions/SecurityTeamActionCreators');
var AstroTeamTeamActionCreators = require('./actions/AstroTeamActionCreators');
var RadiationStore = require('./stores/radiation-store');
var TimerStore = require('./stores/timer-store');
var TaskStore = require('./stores/task-store');
var IntroductionStore = require('./stores/introduction-store');
var Router = require('./router-container');
var EventConstants = require('../server/EventConstants');

var api = {

    setup: function setup() {
        var _this = this;

        socket.on('connect', function () {
            console.log('Connected to server WebSocket');
            console.log('Asking server for app state');
            api.askForAppState();
            MessageActionCreators.removeMessage('disconnect message');
        });

        socket.on('disconnect', function () {
            MessageActionCreators.addMessage({
                id: 'disconnect message',
                text: 'Mistet kontakt med serveren. Last siden på nytt',
                level: 'danger'
            });
        });

        socket.on(EventConstants.MISSION_STARTED, function (appState) {
            MissionActionCreators.missionStarted();
            _this._appStateReceived(appState);
        });
        socket.on(EventConstants.MISSION_STOPPED, function () {
            return MissionActionCreators.missionStopped();
        });
        socket.on(EventConstants.MISSION_COMPLETED, function () {
            return MissionActionCreators.missionCompleted();
        });
        socket.on(EventConstants.MISSION_RESET, function () {
            return MissionActionCreators.missionWasReset();
        });

        socket.on(EventConstants.SET_EVENTS, MissionActionCreators.receivedEvents);
        socket.on(EventConstants.ADD_MESSAGE, function (serverMsg) {
            if (serverMsg.audience && serverMsg.audience !== Router.getTeamId()) return;

            MessageActionCreators.addMessage(serverMsg);
        });

        socket.on('mission time', MissionActionCreators.setMissionTime);

        socket.on(EventConstants.APP_STATE, function (state) {
            _this._appStateReceived(state);
        });

        // if the client misses the message/event it is lost ... and the current_event will be unchanged :-(
        // TODO: store it server_side in the teamState before sending
        socket.on(EventConstants.AST_CHECK_VITALS, function () {
            AstroTeamTeamActionCreators.startMonitorTask();
        });

        socket.on(EventConstants.SCIENCE_CHECK_RADIATION, function () {
            ScienceTeamActionCreators.startSampleTask();
        });

        socket.on(EventConstants.SECURITY_CHECK_DATA_TRANSFER, function () {
            SecurityTeamActionCreators.startDataTransferCheck();
        });
    },

    startMission: function startMission() {
        socket.emit('start mission');
    },

    stopMission: function stopMission() {
        socket.emit('stop mission');
    },

    resetMission: function resetMission() {
        socket.emit('reset mission');
    },

    askToStartNextChapter: function askToStartNextChapter() {
        socket.emit(EventConstants.ADVANCE_CHAPTER);
    },

    triggerEvent: function triggerEvent(uuid) {
        socket.emit(EventConstants.TRIGGER_EVENT, uuid);
    },

    /*
     * Send the client held state (for the current team) to server on change
     * The most important bits are held on server, and is not transferred back,
     * such as if the mission is running, the current chapter, etc.
     *
     * This is important to store on the server in case we drop the connection and reconnect in other session
     */
    sendTeamStateChange: function sendTeamStateChange() {
        var teamId = arguments[0] === undefined ? Router.getTeamId() : arguments[0];

        var state = {};

        state.team = teamId;
        state.introduction_read = IntroductionStore.isIntroductionRead(teamId);
        state.current_task = TaskStore.getCurrentTaskId(teamId);

        if (teamId === 'science') {
            state.radiation = RadiationStore.getState();
        }

        socket.emit('set team state', state);
    },

    completeMission: function completeMission() {
        socket.emit(EventConstants.COMPLETE_MISSION);
    },

    /*
     * This is only stubbed out until server communication is up and running
     */
    askForAppState: function askForAppState() {
        socket.emit('get app state');
    },

    askForMissionTime: function askForMissionTime() {
        socket.emit('get mission time');
    },

    askToChangeScrubFilter: function askToChangeScrubFilter() {
        socket.emit('set scrub filter changed');
    },

    _appStateReceived: function _appStateReceived(appState) {
        AppDispatcher.dispatch({ action: MissionConstants.RECEIVED_APP_STATE, appState: appState });
    },

    askForEvents: function askForEvents() {
        socket.emit(EventConstants.GET_EVENTS);
    },

    setOxygenConsumption: function setOxygenConsumption(units) {
        socket.emit('set oxygen consumption', units);
    },

    setReadyForSafeMode: function setReadyForSafeMode() {
        socket.emit('ready for safe mode');
    },

    setInSafeMode: function setInSafeMode() {
        socket.emit('set in safe mode');
    },

    // meant for testing - not actual client use
    setOxygenLevel: function setOxygenLevel(units) {
        socket.emit('set oxygen remaining', units);
    }

};

window.__api = api;
module.exports = api;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../server/EventConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/server/EventConstants.js","./actions/AstroTeamActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/AstroTeamActionCreators.js","./actions/MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","./actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","./actions/ScienceActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js","./actions/SecurityTeamActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/SecurityTeamActionCreators.js","./appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","./constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./router-container":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js","./stores/introduction-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/introduction-store.js","./stores/radiation-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/radiation-store.js","./stores/task-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/task-store.js","./stores/timer-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/client-bootstrap.js":[function(require,module,exports){
/* Script to bootstrap the application */

'use strict';

var MissionActionCreators = require('./actions/MissionActionCreators'),
    MessageActionCreators = require('./actions/MessageActionCreators'),
    ScienceActionCreators = require('./actions/ScienceActionCreators'),
    ScienceConstants = require('./constants/ScienceTeamConstants'),
    TimerActionCreators = require('./actions/TimerActionCreators'),
    AppDispatcher = require('./appdispatcher');

AppDispatcher.register(function (payload) {
    console.log('DEBUG AppDispatcher.dispatch', payload);
});

function run() {

    // SETTINGS
    MissionActionCreators.startMission();
}

module.exports = { run: run };

},{"./actions/MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","./actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","./actions/ScienceActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js","./actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","./appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","./constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/app.react.js":[function(require,module,exports){
(function (global){
'use strict';

var _extends = require('babel-runtime/helpers/extends')['default'];

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);

var RouteHandler = Router.RouteHandler;

var Header = require('./header.react');

var MessageList = require('./message-list.react');
var MissionStateStore = require('../stores/mission-state-store');

var App = React.createClass({
    displayName: 'App',

    mixins: [],

    getInitialState: function getInitialState() {
        return { isMissionRunning: MissionStateStore.isMissionRunning() };
    },

    componentWillMount: function componentWillMount() {
        MissionStateStore.addChangeListener(this._handleMissionStateChange);
    },

    componentDidMount: function componentDidMount() {
        console.log('App.componentDidMount');
    },

    componentWillUnmount: function componentWillUnmount() {
        MissionStateStore.removeChangeListener(this._handleMissionStateChange);
    },

    _handleMissionStateChange: function _handleMissionStateChange() {
        this.setState({ isMissionRunning: MissionStateStore.isMissionRunning() });
    },

    render: function render() {

        return React.createElement(
            'div',
            { className: 'container' },
            React.createElement(Header, null),
            React.createElement(RouteHandler, _extends({}, this.props, this.state)),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement('footer', { id: 'main-footer' })
            )
        );
    }
});

module.exports = App;
/* this is the important part */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/mission-state-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/mission-state-store.js","./header.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/header.react.js","./message-list.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/message-list.react.js","babel-runtime/helpers/extends":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/extends.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/astronaut-task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var HeartRateChart = require('./heart-rate-chart.react');
var BreathRateChart = require('./breath-rate-chart.react');
var TimerPanel = require('./timer-panel.react');
var TimerActionCreators = require('../actions/TimerActionCreators');
var OxygenStore = require('../stores/oxygen-store');
var AstronautConstants = require('../constants/AstroTeamConstants');
var AstronautActionCreators = require('../actions/AstroTeamActionCreators');

var _require = require('../utils');

var parseNumber = _require.parseNumber;

TimerActionCreators.setTimer(AstronautConstants.RESPIRATION_TIMER, 15);
TimerActionCreators.setTimer(AstronautConstants.HEART_RATE_TIMER, 10);

// lazy load due to avoid circular dependencies
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
var getMissionAC = lazyRequire('../actions/MissionActionCreators');
// for browserify to work it needs to find these magic strings
require('../actions/MissionActionCreators');

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},

    propTypes: {},

    mixins: [],

    getInitialState: function getInitialState() {
        return this._getState();
    },
    componentWillMount: function componentWillMount() {
        var _this = this;

        OxygenStore.addChangeListener(function () {
            return _this._updateState();
        });
    },

    _indicatorColor: function _indicatorColor() {
        return this.state.oxygenStore.colorIndicator;
    },

    _updateState: function _updateState() {
        this.setState(this._getState());
    },

    _getState: function _getState() {
        return {
            oxygenStore: OxygenStore.getState()
        };
    },

    _handleBreathRate: function _handleBreathRate(e) {
        e.preventDefault();
        var el = React.findDOMNode(this.refs['breath-rate']);
        AstronautActionCreators.setOxygenConsumption(parseNumber(el.value));
        getMissionAC().taskCompleted('astronaut', 'breathing_calculate');
    },

    _handleHeartRate: function _handleHeartRate(e) {
        e.preventDefault();
        var el = React.findDOMNode(this.refs['heart-rate-input']);
        AstronautActionCreators.heartRateRead(parseNumber(el.value));
        getMissionAC().taskCompleted('astronaut', 'heartrate_calculate');
    },

    render: function render() {

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'ul',
                    null,
                    React.createElement(
                        'li',
                        null,
                        'Luftstatus:',
                        React.createElement('div', {
                            className: 'circle ',
                            style: { display: 'inline-block', backgroundColor: this._indicatorColor() }
                        })
                    ),
                    React.createElement(
                        'li',
                        null,
                        'Forbruk : ',
                        this.state.oxygenStore.consumptionPerMinute
                    ),
                    React.createElement(
                        'li',
                        null,
                        'Gjenstående oksygen: ',
                        this.state.oxygenStore.remaining,
                        ' enheter'
                    )
                )
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'col-md-6' },
                    React.createElement(
                        'h2',
                        null,
                        'Pust'
                    ),
                    React.createElement(BreathRateChart, { height: 240 })
                ),
                React.createElement(
                    'div',
                    { className: 'col-md-6' },
                    React.createElement(
                        'h2',
                        null,
                        'Hjerteslag'
                    ),
                    React.createElement(HeartRateChart, { height: 240 })
                ),
                React.createElement(TimerPanel, { timerId: AstronautConstants.RESPIRATION_TIMER, className: 'col-md-6' }),
                React.createElement(TimerPanel, { timerId: AstronautConstants.HEART_RATE_TIMER, className: 'col-md-6' })
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'col-xs-6' },
                    React.createElement(
                        'fieldset',
                        { disabled: false },
                        React.createElement(
                            'h3',
                            null,
                            'Beregnet luftforbruk'
                        ),
                        React.createElement(
                            'form',
                            { onSubmit: this._handleBreathRate },
                            React.createElement(
                                'select',
                                { ref: 'breath-rate' },
                                React.createElement(
                                    'option',
                                    { value: 1 },
                                    '1 enhet per minutt'
                                ),
                                React.createElement(
                                    'option',
                                    { value: 2 },
                                    '2 enheter per minutt'
                                )
                            ),
                            React.createElement(
                                'button',
                                { className: 'btn btn-primary' },
                                'Evaluer'
                            )
                        )
                    )
                ),
                React.createElement(
                    'div',
                    { className: 'col-xs-6' },
                    React.createElement(
                        'fieldset',
                        { disabled: false },
                        React.createElement(
                            'h3',
                            null,
                            'Beregnet hjerterytme'
                        ),
                        React.createElement(
                            'form',
                            { onSubmit: this._handleHeartRate },
                            React.createElement('input', { ref: 'heart-rate-input', type: 'number', min: '50', max: '200' }),
                            React.createElement(
                                'button',
                                { className: 'btn btn-primary' },
                                'Evaluer'
                            )
                        )
                    )
                )
            )
        );
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/AstroTeamActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/AstroTeamActionCreators.js","../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../stores/oxygen-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/oxygen-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./breath-rate-chart.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/breath-rate-chart.react.js","./heart-rate-chart.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/heart-rate-chart.react.js","./timer-panel.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer-panel.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/breath-rate-chart.react.js":[function(require,module,exports){
(function (global){
/**
 * THIS DESIGN ONLY SUPPORTS ONE CHART AS THEY *SHARE* STATE
 * For a non-stupid design, do something like the
 * implementation in the article by Nicolas Hery:
 * http://nicolashery.com/integrating-d3js-visualizations-in-a-react-app
 *
 * Chart code more or less copied from the prototype by Leo Martin Westby
 */
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var AmCharts = (typeof window !== "undefined" ? window.AmCharts : typeof global !== "undefined" ? global.AmCharts : null);
var BreathRateStore = require('../stores/breath-rate-store');

var _require = require('../utils');

var randomInt = _require.randomInt;

//Lung volume in ml before and after inhalation
var lowVolume = 2000;
var highVolume = 3000;

//Millivolts displayed on the Y axis of the ECG graph
var highMV = 1;
var lowMV = 0;

var breathRateSamples = [];
var chart;

//Configure the charts
function initChart(domElement) {
    chart = new AmCharts.AmSerialChart();

    chart.marginTop = 20;
    chart.marginRight = 10;
    chart.autoMarginOffset = 5;
    chart.dataProvider = breathRateSamples;
    chart.categoryField = 'timestamp';

    //X Axis
    var categoryAxis = chart.categoryAxis;
    categoryAxis.dashLength = 1;
    categoryAxis.gridAlpha = 0.1;
    categoryAxis.axisColor = '#DADADA';
    categoryAxis.autoGridCount = false;
    categoryAxis.gridCount = 15;
    categoryAxis.forceShowField = 'forceShow';
    //categoryAxis.title = "Seconds";

    //Hide every label that is not explicitly shown
    categoryAxis.labelFunction = function (valueText, object) {
        if (object.forceShow) {
            return valueText;
        }
    };

    //Y Axis
    var valueAxis = new AmCharts.ValueAxis();
    valueAxis.axisAlpha = 0.2;
    valueAxis.dashLength = 1;
    valueAxis.minimum = lowVolume;
    valueAxis.maximum = highVolume * 1.1;
    valueAxis.title = 'Lungevolum (ml)';
    chart.addValueAxis(valueAxis);

    //Line
    var graph = new AmCharts.AmGraph();
    graph.type = 'smoothedLine';
    graph.valueField = 'volume';
    graph.lineThickness = 1.5;
    graph.lineColor = '#b5030d';
    chart.addGraph(graph);

    chart.write(domElement);
}

var breathRateBuffer;
var breathRateBufferIndex;
var msUntilNextBreathRateBufferFrame;

//Fills the breath rate buffer with samples from the specified range
//The breath rate buffer contains twice as many samples as the breath rate chart and is used to animate the chart
function createBreathRateSamples(min, max) {
    breathRateBuffer = [];
    breathRateBufferIndex = 0;
    msUntilNextBreathRateBufferFrame = 0;

    var breathsPerMinute = randomInt(min, max);
    var msBetweenBreaths = 60 * 1000 / breathsPerMinute;
    var msUntilNextBreath = msBetweenBreaths;

    for (var i = 0; i <= 120; i++) {
        var lungVolume;

        if (msUntilNextBreath <= 0) {
            lungVolume = highVolume;
            msUntilNextBreath = msBetweenBreaths;
        } else {
            lungVolume = lowVolume * 1.05;
        }

        //The resolution of the chart is two samples per second
        breathRateBuffer.push({ timestamp: i / 2, volume: lungVolume });
        msUntilNextBreath -= 500;
    }
}

var chartUpdater;

//Animates the breath rate and heart rate charts
function startEventLoop() {
    var startTime = Date.now();
    var msSinceLastUpdate = 0;
    var msSinceStart = 0;
    var updateFrequency = 400;
    stopEventLoop();

    chartUpdater = setInterval(function () {
        msSinceLastUpdate = Date.now() - startTime - msSinceStart;
        msUntilNextBreathRateBufferFrame -= msSinceLastUpdate;
        msSinceStart = Date.now() - startTime;

        if (msUntilNextBreathRateBufferFrame <= 0) {
            var framesMissed = Math.floor(msUntilNextBreathRateBufferFrame * -1 / 500 + 1);

            for (var i = 0; i < framesMissed; i++) {
                breathRateBufferIndex++;

                if (breathRateBufferIndex >= breathRateBuffer.length) {
                    breathRateBufferIndex = 0;
                }

                breathRateSamples.push(breathRateBuffer[breathRateBufferIndex]);

                //When the chart grows to 30 seconds, start cutting off the oldest sample to give the chart a sliding effect
                if (breathRateSamples.length > 60) {
                    breathRateSamples.shift();
                }
            }

            msUntilNextBreathRateBufferFrame = 250;
        }

        //Always show from 0 to 30 seconds on the X axis
        if (breathRateSamples.length >= 60) {
            for (var i = 0; i < breathRateSamples.length; i++) {
                breathRateSamples[i].timestamp = Math.floor(i / (breathRateSamples.length - 1) * 30);
            }
        }

        //Only show every 5th timestamp
        for (var i = 0; i < breathRateSamples.length; i++) {
            breathRateSamples[i].forceShow = breathRateSamples[i].timestamp % 5 == 0 && (i == 0 || breathRateSamples[i - 1].timestamp % 5 != 0);
        }

        chart.validateData();
    }, updateFrequency);
}

function stopEventLoop() {
    clearInterval(chartUpdater);
    breathRateSamples.length = 0;
    chart.validateData();
}

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},

    propTypes: {
        height: React.PropTypes.number.isRequired,
        width: React.PropTypes.number
    },

    mixins: [],

    getInitialState: function getInitialState() {
        return this._getChartState();
    },

    componentWillMount: function componentWillMount() {
        var _this = this;

        this._updateChart();
        BreathRateStore.addChangeListener(function () {
            return _this._updateChart();
        });
    },

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        initChart(el);
        startEventLoop();
    },

    componentWillUnmount: function componentWillUnmount() {
        chart && chart.clear();
        stopEventLoop();
    },

    componentDidUnmount: function componentDidUnmount() {
        chart = null;
    },

    componentDidUpdate: function componentDidUpdate() {},

    // this chart is responsible for drawing itself
    shouldComponentUpdate: function shouldComponentUpdate() {
        return false;
    },

    // Private methods
    _updateChart: function _updateChart() {
        this.setState(this._getChartState());
        createBreathRateSamples(this.state.min, this.state.max);
    },

    _getChartState: function _getChartState() {
        return BreathRateStore.getState();
    },

    _onChange: function _onChange() {},

    render: function render() {

        // if you don't specify width it will max out to 100% (which is ok)
        return React.createElement('div', {
            style: { width: this.props.width + 'px', height: this.props.height + 'px' },
            className: this.props.className
        });
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/breath-rate-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/breath-rate-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/communication-task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var OxygenStore = require('../stores/oxygen-store');

var _require = require('../utils');

var parseNumber = _require.parseNumber;

var _require2 = require('../utils');

var randomInt = _require2.randomInt;

var MissionStateStore = require('../stores/mission-state-store');

// lazy load due to avoid circular dependencies
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
var getMissionAC = lazyRequire('../actions/MissionActionCreators');
// for browserify to work it needs to find these magic strings
require('../actions/MissionActionCreators');

var lowThreshold = 30,
    mediumThreshold = 70;

var satellites = [{ name: 'Satelitt 1', freq: { min: 2.8, max: 3.4 }, reception: 90, color: 'green' }, { name: 'Satelitt 2', freq: { min: 2.1, max: 2.5 }, reception: 30, color: 'red' }, { name: 'Satelitt 3', freq: { min: 3.6, max: 4 }, reception: 60, color: 'orange' }];

function color(reception) {
    if (reception > mediumThreshold) {
        return 'green';
    }
    if (reception > lowThreshold) {
        return 'orange';
    }
    return 'red';
}

var i = 0;
function newValues() {
    satellites[(i + 0) % 3].reception = randomInt(25, 65);
    satellites[(i + 1) % 3].reception = randomInt(45, 85);
    satellites[(i + 2) % 3].reception = randomInt(25, 65);
    i++;

    chart && chart.validateData();
}

var currentChapter;

MissionStateStore.addChangeListener(function () {
    var isNewChapter = currentChapter !== MissionStateStore.currentChapter();
    currentChapter = MissionStateStore.currentChapter();

    if (isNewChapter && currentChapter !== 3) {
        newValues();
    }
});

var chart;
function initGraph(domElement) {
    chart = new AmCharts.AmSerialChart();

    chart.dataProvider = satellites;
    chart.categoryField = 'name';

    //X axis
    var categoryAxis = chart.categoryAxis;
    categoryAxis.gridPosition = 'start';

    //Y axis
    var valueAxis = new AmCharts.ValueAxis();
    valueAxis.axisAlpha = 0;
    valueAxis.minimum = 0;
    valueAxis.maximum = 100;
    valueAxis.title = 'Mottak';
    valueAxis.position = 'left';
    chart.addValueAxis(valueAxis);

    //Line
    var graph = new AmCharts.AmGraph();
    graph.valueField = 'reception';
    graph.colorField = 'color';
    graph.lineAlpha = 0.2;
    graph.fillAlphas = 0.8;
    graph.type = 'column';
    graph.showBalloon = false;
    chart.addGraph(graph);

    chart.write(domElement);

    return chart;
}

var SatelliteReceptionChart = React.createClass({
    displayName: 'SatelliteReceptionChart',

    propTypes: {},

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        initGraph(el);
    },

    render: function render() {
        return React.createElement('div', { className: this.props.className, style: this.props.style });
    }

});

var SatelliteTable = React.createClass({
    displayName: 'SatelliteTable',

    propTypes: {
        satellites: React.PropTypes.array.isRequired
    },

    render: function render() {

        return React.createElement(
            'div',
            this.props,
            React.createElement(
                'table',
                { className: 'table table-bordered table-striped ' },
                React.createElement(
                    'thead',
                    null,
                    React.createElement(
                        'tr',
                        null,
                        React.createElement(
                            'th',
                            null,
                            'Satelitt'
                        ),
                        React.createElement(
                            'th',
                            null,
                            'Frekvensområde'
                        )
                    )
                ),
                React.createElement(
                    'tbody',
                    null,
                    this.props.satellites.map(function (sat, i) {
                        return React.createElement(
                            'tr',
                            { key: i },
                            React.createElement(
                                'td',
                                null,
                                sat.name
                            ),
                            React.createElement(
                                'td',
                                null,
                                sat.freq.min,
                                ' - ',
                                sat.freq.max
                            )
                        );
                    })
                )
            )
        );
    }

});

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},

    propTypes: {},

    mixins: [],

    getInitialState: function getInitialState() {
        return {
            chosenSatellite: satellites[0]
        };
    },
    componentWillMount: function componentWillMount() {},

    componentWillUnmount: function componentWillUnmount() {},

    _getState: function _getState() {
        return {};
    },

    render: function render() {

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(SatelliteTable, { satellites: satellites, className: 'col-sm-6' }),
                React.createElement(SatelliteReceptionChart, { style: { height: '250px' }, className: 'col-sm-6' })
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'h3',
                    null,
                    'Velg satelitt og tilhørende frekvensområde'
                ),
                React.createElement(
                    'select',
                    null,
                    satellites.map(function (sat) {
                        return React.createElement(
                            'option',
                            { key: sat.name, value: sat.name },
                            sat.name
                        );
                    })
                ),
                React.createElement(
                    'h4',
                    null,
                    'Velg frekvens:'
                ),
                React.createElement('input', { type: 'number' })
            )
        );
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../stores/mission-state-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/mission-state-store.js","../stores/oxygen-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/oxygen-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/dialogs.react.js":[function(require,module,exports){
(function (global){
// needed to avoid compilation error
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

module.exports = {
    science_intro: React.createElement(
        'div',
        null,
        React.createElement(
            'p',
            null,
            'Dere skal overvåke strålingsnivået astronatuen utsettes for. Dere må da passe på at astronauten ikke blir utsatt for strålingsnivåer som er skadelig.'
        ),
        React.createElement(
            'p',
            null,
            'Ved hjelp av instrumentene som er tilgjengelig må dere jevnlig ta prøver og regne ut verdiene for gjennomsnittlig og totalt strålingsnivå. Finner dere ut at nivåene er blitt farlig høye ',
            React.createElement(
                'em',
                null,
                'må'
            ),
            ' dere si fra til oppdragslederen så vi kan få ut astronauten!'
        ),
        React.createElement(
            'p',
            null,
            'Er oppdraget forstått?'
        )
    ),

    astronaut_intro: React.createElement(
        'div',
        null,
        React.createElement(
            'p',
            null,
            'Deres jobb er å sikre at det er nok oksygen for å gjennomføre oppdraget. Her er det viktig å jevnlig sjekke hvor fort astronaut Steigen puster og hvor fort hjertet hennes slår.'
        ),
        React.createElement(
            'p',
            null,
            'Finner dere ut at astronaut Steigen ikke vil ha nok luft til å gjennomføre oppdraget ',
            React.createElement(
                'em',
                null,
                'må'
            ),
            ' dere si fra til oppdragslederen så vi kan avbryte i tide.'
        )
    ),

    communication_intro: React.createElement(
        'div',
        null,
        React.createElement(
            'p',
            null,
            'Deres mål er å holde kommunikasjonen oppe, og kommunisere med oppdragskoordinator og astronauten. Om nødvendig må dere kanskje bytte til en annen kommunikasjonssatelitt.'
        ),
        React.createElement(
            'p',
            null,
            'Dere skal også informere astronauten om eventuelle beskjeder fra Andaøya Space Center (ASC), og likeledes informere ASC om hendelser eller beskjeder fra astronauten.'
        )
    ),

    security_intro: React.createElement(
        'div',
        null,
        React.createElement(
            'p',
            null,
            'Deres hovedoppgave er å innhente informasjon fra de forskjellige gruppene og bestemme dere for hva som skal gjøres. Her må dere samarbeide godt med oppdragskoordinatoren (',
            React.createElement(
                'em',
                null,
                'mission commander'
            ),
            ')!'
        ),
        React.createElement(
            'p',
            null,
            'Dere må også holde et øye på indikatoren som sier om det er nok luft til å gjennomføre oppdraget, samt sjekke om karbondioksidskrubberen må skiftes slik at astronauten ikke kveles.'
        ),
        React.createElement(
            'p',
            null,
            'Deres må også sjekke at kommunikasjonsstatusen og datakvaliteten er god når reparasjonen er utført.'
        )
    )

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/dummy-render.mixin.js":[function(require,module,exports){
'use strict';

module.exports = {
    render: function render() {
        throw new Error('DUMMY_RENDER. This react component is not for presentational purposes');
    }
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/full-screen-video.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

var player;
function onYouTubeIframeAPIReady() {
    console.log('onYouTubeIframeAPIReady');
    player = new YT.Player('player', {
        events: {
            onReady: onPlayerReady
        }
    });
}

function playVideo() {
    player.seekTo(96);
    player.playVideo();

    // stop video after ten seconds
    setTimeout(function () {
        player.stopVideo(player);
        playVideo();
    }, 10000);
}

function onPlayerReady(event) {
    //event.target.mute();
    player.mute();
    playVideo();
}

window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;

module.exports = React.createClass({
    displayName: 'exports',

    /* https://developers.google.com/youtube/iframe_api_reference#Getting_Started */
    componentDidMount: function componentDidMount() {
        console.log('componentDidMount');
        var tag = document.createElement('script');

        tag.src = 'https://www.youtube.com/iframe_api';
        document.head.appendChild(tag);
    },

    render: function render() {
        var rickRolled = 'http://www.youtube.com/embed/oHg5SJYRHA0?autoplay=1';
        var origin = location.protocol + '//' + location.host;
        var solarStorm = 'http://www.youtube.com/embed/DU4hpsistDk?&start=96&enablejsapi=1&origin=' + origin;
        var video = solarStorm;

        //return <div />
        return React.createElement('iframe', { id: 'player',
            style: { position: 'absolute', top: 0, right: 0, width: '100%', height: '100%' },
            src: video,
            frameBorder: '0', allowFullScreen: true });
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/header.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var Link = Router.Link;

var Header = React.createClass({
    displayName: 'Header',

    render: function render() {
        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'header',
                    { id: 'narom-header' },
                    React.createElement(
                        'div',
                        null,
                        React.createElement('img', { className: 'narom-logo-img', src: '/images/logo.png' }),
                        'NAROM e-Mission prototype'
                    )
                )
            ),
            React.createElement(
                'div',
                { id: 'main-header', className: 'row' },
                React.createElement(
                    Link,
                    { to: '/' },
                    React.createElement(
                        'header',
                        null,
                        React.createElement(
                            'h1',
                            { className: '' },
                            'Under en solstorm'
                        )
                    )
                )
            )
        );
    }
});

module.exports = Header;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/heart-rate-chart.react.js":[function(require,module,exports){
(function (global){
/**
 * THIS DESIGN ONLY SUPPORTS ONE CHART AS THEY *SHARE* STATE
 * For a non-stupid design, do something like the
 * implementation in the article by Nicolas Hery:
 * http://nicolashery.com/integrating-d3js-visualizations-in-a-react-app
 *
 * Chart code more or less copied from the prototype by Leo Martin Westby
 */
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var AmCharts = (typeof window !== "undefined" ? window.AmCharts : typeof global !== "undefined" ? global.AmCharts : null);

var _require = require('../utils');

var randomInt = _require.randomInt;

var HeartStore = require('../stores/heart-rate-store');

var chart;
var heartRateSamples = [];

var heartRateBuffer;
var heartRateBufferIndex;
var msUntilNextHeartRateBufferFrame;

//Millivolts displayed on the Y axis of the ECG graph
var highMV = 1;
var lowMV = 0;

var chartUpdater;

function initChart(domElement) {

    chart = new AmCharts.AmSerialChart();

    chart.marginTop = 20;
    chart.marginRight = 10;
    chart.autoMarginOffset = 5;
    chart.dataProvider = heartRateSamples;
    chart.categoryField = 'timestamp';

    //X Axis
    var categoryAxis = chart.categoryAxis;
    categoryAxis.dashLength = 1;
    categoryAxis.gridAlpha = 0.1;
    categoryAxis.axisColor = '#DADADA';
    categoryAxis.forceShowField = 'forceShow';
    //categoryAxis.title = "Seconds";

    //Hide every label that is not explicitly shown
    categoryAxis.labelFunction = function (valueText, object) {
        if (object.forceShow) {
            return valueText;
        }
    };

    //Y Axis
    var valueAxis = new AmCharts.ValueAxis();
    valueAxis.axisAlpha = 0.2;
    valueAxis.dashLength = 1;
    valueAxis.minimum = lowMV;
    valueAxis.maximum = highMV * 1.1;
    valueAxis.title = 'mV';
    chart.addValueAxis(valueAxis);

    //Line
    var graph = new AmCharts.AmGraph();

    graph.valueField = 'mV';
    graph.type = 'smoothedLine';
    graph.lineThickness = 1;
    graph.lineColor = '#b5030d';
    chart.addGraph(graph);

    chart.write(domElement);
}

//Fills the heart rate buffer with samples from the specified range
//The heart rate buffer contains twice as many samples as the heart rate chart and is used to animate the chart
function createHeartRateSamples(min, max) {
    heartRateBuffer = [];
    heartRateBufferIndex = 0;
    msUntilNextHeartRateBufferFrame = 0;

    var beatsPerMinute = randomInt(min, max);
    var msBetweenBeats = 60 * 1000 / beatsPerMinute;
    var msUntilNextBeat = msBetweenBeats;

    for (var i = 0; i <= 200; i++) {
        var mV;

        if (msUntilNextBeat <= 0) {
            mV = highMV;
            msUntilNextBeat = msBetweenBeats;
        } else {
            mV = Math.random() * 0.2;
        }

        //The resolution of the chart is ten samples per second
        heartRateBuffer.push({ timestamp: i / 10, mV: mV });
        msUntilNextBeat -= 50;
    }
}

//Animates the  heart rate charts
function startEventLoop() {
    var startTime = Date.now();
    var msSinceLastUpdate = 0;
    var msSinceStart = 0;
    var updateFrequency = 400;
    stopEventLoop();

    chartUpdater = setInterval(function () {
        msSinceLastUpdate = Date.now() - startTime - msSinceStart;
        msUntilNextHeartRateBufferFrame -= msSinceLastUpdate;
        msSinceStart = Date.now() - startTime;

        if (msUntilNextHeartRateBufferFrame <= 0) {
            var framesMissed = Math.floor(msUntilNextHeartRateBufferFrame * -1 / 100 + 1);

            for (var i = 0; i < framesMissed; i++) {
                heartRateBufferIndex++;

                if (heartRateBufferIndex >= heartRateBuffer.length) {
                    heartRateBufferIndex = 0;
                }

                heartRateSamples.push(heartRateBuffer[heartRateBufferIndex]);

                //When the chart grows to 10 seconds, start cutting off the oldest sample to give the chart a sliding effect
                if (heartRateSamples.length > 100) {
                    heartRateSamples.shift();
                }
            }

            msUntilNextHeartRateBufferFrame = 100;
        }

        //Always show from 0 to 10 seconds on the X axis
        if (heartRateSamples.length >= 100) {
            for (var i = 0; i < heartRateSamples.length; i++) {
                heartRateSamples[i].timestamp = Math.floor(i / (heartRateSamples.length - 1) * 10);
            }
        }

        //Only show every 5th timestamp
        for (var i = 0; i < heartRateSamples.length; i++) {
            heartRateSamples[i].forceShow = heartRateSamples[i].timestamp % 5 == 0 && (i == 0 || heartRateSamples[i - 1].timestamp % 5 != 0);
        }

        chart.validateData();
    }, updateFrequency);
}

function stopEventLoop() {
    clearInterval(chartUpdater);
    heartRateSamples.length = 0;
    chart.validateData();
}

var HeartRateChart = React.createClass({
    displayName: 'HeartRateChart',

    statics: {},

    propTypes: {
        height: React.PropTypes.number.isRequired,
        width: React.PropTypes.number
    },

    mixins: [],

    getInitialState: function getInitialState() {
        return this._getChartState();
    },

    componentWillMount: function componentWillMount() {
        var _this = this;

        this._updateChart();
        HeartStore.addChangeListener(function () {
            return _this._updateChart();
        });
    },

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        initChart(el);
        startEventLoop();
    },

    componentWillReceiveProps: function componentWillReceiveProps() {},

    componentWillUnmount: function componentWillUnmount() {
        chart && chart.clear();
        stopEventLoop();
    },

    componentDidUnmount: function componentDidUnmount() {
        chart = null;
    },

    componentDidUpdate: function componentDidUpdate() {},

    // this chart is responsible for drawing itself
    shouldComponentUpdate: function shouldComponentUpdate() {
        return false;
    },

    // Private methods
    _updateChart: function _updateChart() {
        this.setState(this._getChartState());
        createHeartRateSamples(this.state.min, this.state.max);
    },

    _getChartState: function _getChartState() {
        return HeartStore.getState();
    },

    _onChange: function _onChange() {},

    render: function render() {

        // if you don't specify width it will max out to 100% (which is ok)
        return React.createElement('div', {
            style: { width: this.props.width + 'px', height: this.props.height + 'px' },
            className: this.props.className
        });
    }

});

module.exports = HeartRateChart;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/heart-rate-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/heart-rate-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/index-app.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var Link = Router.Link;

module.exports = React.createClass({
    displayName: 'exports',

    render: function render() {
        return React.createElement(
            'div',
            null,
            React.createElement(
                'h3',
                null,
                'Velg lag'
            ),
            React.createElement(
                'ul',
                null,
                React.createElement(
                    'li',
                    null,
                    React.createElement(
                        Link,
                        { to: 'team-root', params: { teamId: 'science' } },
                        'Forskningsgruppa'
                    )
                ),
                React.createElement(
                    'li',
                    null,
                    React.createElement(
                        Link,
                        { to: 'team-root', params: { teamId: 'astronaut' } },
                        'Astronautgruppa'
                    )
                ),
                React.createElement(
                    'li',
                    null,
                    React.createElement(
                        Link,
                        { to: 'team-root', params: { teamId: 'security' } },
                        'Sikkerhetsgruppa'
                    )
                ),
                React.createElement(
                    'li',
                    null,
                    React.createElement(
                        Link,
                        { to: 'team-root', params: { teamId: 'communication' } },
                        'Kommunikasjonsgruppa'
                    )
                )
            )
        );
    }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/introduction-screen.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var dialogs = require('./dialogs.react');

var _require = require('../utils');

var cleanRootPath = _require.cleanRootPath;

var RouteStore = require('../stores/route-store');
var IntroStore = require('../stores/introduction-store');

var IntroductionScreen = React.createClass({
    displayName: 'IntroductionScreen',

    mixins: [],

    contextTypes: {
        router: React.PropTypes.func
    },

    statics: {
        willTransitionTo: function willTransitionTo(transition) {
            var teamId = cleanRootPath(transition.path);

            if (IntroStore.isIntroductionRead(teamId)) {
                console.log('Introduction read earlier');
                transition.redirect('team-task', { taskId: 'sample', teamId: teamId });
            }
        }
    },

    _handleClick: function _handleClick() {
        var MissionActionCreators = require('../actions/MissionActionCreators');

        var teamId = RouteStore.getTeamId();
        MissionActionCreators.introWasRead(teamId);
        this.context.router.transitionTo('team-task', { taskId: 'sample', teamId: teamId });
    },

    render: function render() {
        var teamId = RouteStore.getTeamId();
        var introText = dialogs[teamId + '_intro'] || React.createElement(
            'p',
            null,
            'Mangler oppdrag'
        );

        return React.createElement(
            'div',
            { className: 'row jumbotron introscreen' },
            React.createElement(
                'h2',
                null,
                'Mål for oppdraget'
            ),
            introText,
            React.createElement(
                'button',
                {
                    className: 'btn btn-primary btn-lg',
                    onClick: this._handleClick
                },
                'Jeg forstår'
            )
        );
    }
});

module.exports = IntroductionScreen;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../stores/introduction-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/introduction-store.js","../stores/route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./dialogs.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/dialogs.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/message-list.react.js":[function(require,module,exports){
(function (global){
'use strict';

var _extends = require('babel-runtime/helpers/extends')['default'];

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var actions = require('../actions/MessageActionCreators');

var ListMessageWrapper = React.createClass({
    displayName: 'ListMessageWrapper',

    propTypes: {
        level: React.PropTypes.string.isRequired,
        text: React.PropTypes.string.isRequired,
        id: React.PropTypes.string.isRequired
    },

    render: function render() {
        var _this = this;

        var button = undefined;

        if (this.props.dismissable) {
            button = React.createElement(
                'button',
                {
                    type: 'button',
                    className: 'close',
                    onClick: function () {
                        return actions.removeMessage(_this.props.id);
                    }
                },
                React.createElement(
                    'span',
                    null,
                    '×'
                )
            );
        }

        return React.createElement(
            'li',
            { className: 'alert alert-dismissible alert-' + this.props.level },
            button,
            this.props.text
        );
    }
});

var MessageList = React.createClass({
    displayName: 'MessageList',

    render: function render() {
        var hidden = this.props.messages.length === 0 ? 'hide' : '';
        var classes = (this.props.className || '') + ' messagebox ' + hidden;

        return React.createElement(
            'ul',
            { className: classes },
            this.props.messages.map(function (msg) {
                return React.createElement(ListMessageWrapper, _extends({ key: msg.id }, msg));
            })
        );
    }

});

module.exports = MessageList;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MessageActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MessageActionCreators.js","babel-runtime/helpers/extends":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/extends.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-commander.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Link = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null).Link;
var MissionStore = require('../stores/mission-state-store');
var MissionTimer = require('./mission-timer.react');
var EventStore = require('../stores/event-store');
var utils = require('../utils');
var getMissionAC = (function () {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require('../actions/MissionActionCreators');
        return tmp;
    };
})();

var EventTable = React.createClass({
    displayName: 'EventTable',

    propTypes: {
        events: React.PropTypes.array.isRequired,
        triggerDisabled: React.PropTypes.bool
    },

    render: function render() {
        var _this = this;

        return React.createElement(
            'table',
            { className: 'table' },
            React.createElement(
                'thead',
                null,
                React.createElement(
                    'tr',
                    null,
                    React.createElement(
                        'th',
                        null,
                        'Time'
                    ),
                    React.createElement(
                        'th',
                        null,
                        'Description'
                    ),
                    React.createElement(
                        'th',
                        null,
                        'Value'
                    ),
                    React.createElement(
                        'th',
                        null,
                        'Trigger'
                    )
                )
            ),
            React.createElement(
                'tbody',
                null,
                this.props.events.map(function (ev) {
                    return React.createElement(
                        'tr',
                        { key: ev.id },
                        React.createElement(
                            'td',
                            null,
                            ev.triggerTime
                        ),
                        React.createElement(
                            'td',
                            null,
                            ev.short_description
                        ),
                        React.createElement(
                            'td',
                            null,
                            JSON.stringify(ev.value || '')
                        ),
                        React.createElement(
                            'td',
                            null,
                            React.createElement(
                                'button',
                                { className: 'btn btn-primary ' + (_this.props.triggerDisabled && 'disabled'),
                                    onClick: function () {
                                        return getMissionAC().askToTriggerEvent(ev.id);
                                    }
                                },
                                'Trigger'
                            )
                        )
                    );
                })
            )
        );
    }
});

var App = React.createClass({
    displayName: 'App',

    componentWillMount: function componentWillMount() {
        var ac = getMissionAC();
        ac.askForEvents();

        EventStore.addChangeListener(this._onChange);
        MissionStore.addChangeListener(this._onChange);
    },

    componentDidMount: function componentDidMount() {
        var _this2 = this;

        this._interval = setInterval(function () {
            _this2.setState({ chapterTime: _this2.state.chapterTime + 1 });
        }, 1000);
    },

    componentWillUnmount: function componentWillUnmount() {
        clearInterval(this._interval);
        EventStore.removeChangeListener(this._onChange);
        MissionStore.removeChangeListener(this._onChange);
    },

    getInitialState: function getInitialState() {
        return {
            completedEvents: [],
            overdueEvents: [],
            remainingEvents: [],
            running: MissionStore.isMissionRunning(),
            chapter: MissionStore.currentChapter(),
            chapterTime: MissionStore.chapterTime()
        };
    },

    _onChange: function _onChange() {
        this.setState({
            completedEvents: EventStore.completed(),
            overdueEvents: EventStore.overdue(),
            remainingEvents: EventStore.remaining(),
            running: MissionStore.isMissionRunning(),
            chapter: MissionStore.currentChapter(),
            chapterTime: MissionStore.chapterTime(),
            safeMode: MissionStore.isSatelliteInSafeMode()
        });
    },

    render: function render() {

        var status;

        if (!this.state.running) {
            status = React.createElement(
                'p',
                { id: 'missionTime' },
                'Oppdraget har ikke startet'
            );
        }

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                null,
                React.createElement(
                    'h3',
                    null,
                    'Status'
                ),
                status,
                React.createElement(
                    'dl',
                    null,
                    React.createElement(
                        'dt',
                        null,
                        'Nåværende kapittel:'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        this.state.chapter
                    ),
                    React.createElement(
                        'dt',
                        null,
                        'Tid brukt i kapittel'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        this.state.chapterTime
                    ),
                    React.createElement(
                        'dt',
                        null,
                        'Total tid'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        React.createElement(MissionTimer, null)
                    )
                ),
                'Satellite in safe mode? ',
                this.state.safeMode ? 'Yes' : 'No'
            ),
            React.createElement(
                'div',
                null,
                React.createElement(
                    'button',
                    { className: 'btn btn-primary', onClick: getMissionAC().startMission },
                    'Start oppdrag'
                ),
                React.createElement(
                    'button',
                    { className: 'btn btn-primary', onClick: getMissionAC().stopMission },
                    'Stop'
                ),
                React.createElement(
                    'button',
                    { className: 'btn btn-primary', onClick: getMissionAC().askToStartNextChapter },
                    'Neste kapittel'
                ),
                React.createElement(
                    'button',
                    { className: 'btn btn-primary', onClick: getMissionAC().resetMission },
                    'Begynn på nytt'
                )
            ),
            React.createElement(
                'button',
                { className: 'btn btn-primary', onClick: getMissionAC().completeMission },
                'Oppdrag utført'
            ),
            React.createElement(
                'button',
                { className: 'btn btn-primary', onClick: getMissionAC().changeScrubber },
                'Bytt scrubber'
            ),
            React.createElement(
                'h2',
                null,
                'Chapter events'
            ),
            React.createElement(
                'h3',
                null,
                'remaining'
            ),
            React.createElement(EventTable, { key: 'foo', events: this.state.remainingEvents }),
            React.createElement(
                'h3',
                null,
                'overdue'
            ),
            React.createElement(EventTable, { events: this.state.overdueEvents }),
            React.createElement(
                'h3',
                null,
                'completed'
            ),
            React.createElement(EventTable, { triggerDisabled: true, events: this.state.completedEvents })
        );
    }

});

module.exports = App;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../stores/event-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/event-store.js","../stores/mission-state-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/mission-state-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./mission-timer.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-timer.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-timer.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null),
    TimerStore = require('../stores/timer-store'),
    Timer = require('./timer.react');

var MissionTimer = React.createClass({
    displayName: 'MissionTimer',

    getInitialState: function getInitialState() {
        return { elapsed: TimerStore.getElapsedMissionTime() };
    },

    componentDidMount: function componentDidMount() {
        TimerStore.addChangeListener(this._handleTimeChange);
    },

    componentWillUnmount: function componentWillUnmount() {
        TimerStore.removeChangeListener(this._handleTimeChange);
    },

    _handleTimeChange: function _handleTimeChange() {
        this.setState({
            elapsed: TimerStore.getElapsedMissionTime()
        });
    },

    render: function render() {
        return React.createElement(Timer, { className: this.props.className, timeInSeconds: this.state.elapsed });
    }
});

module.exports = MissionTimer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/timer-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js","./timer.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/not-found.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

var NotFound = React.createClass({
    displayName: 'NotFound',

    render: function render() {
        return React.createElement(
            'div',
            { className: 'container' },
            React.createElement(
                'div',
                { className: 'row jumbotron' },
                React.createElement(
                    'div',
                    null,
                    'Ojsann. Tror du har gått deg vill, jeg'
                )
            )
        );
    }
});

module.exports = NotFound;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/overlay.react.js":[function(require,module,exports){
(function (global){
/*
 * Simple component that overlays a section, signalling a disabled state
 *
 * Dependant on working CSS, of course: the parent must be positioned (relative, absolute, ...)
 * Loosely based http://stackoverflow.com/questions/3627283/how-to-dim-other-div-on-clicking-input-box-using-jquery
 */
"use strict";

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

module.exports = React.createClass({
    displayName: "exports",

    propTypes: {
        active: React.PropTypes.bool.isRequired
    },

    render: function render() {
        return this.props.active ? React.createElement("div", { className: "overlay" }) : null;
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-chart.react.js":[function(require,module,exports){
(function (global){
/**
 * THIS DESIGN ONLY SUPPORTS ONE CHART AS THEY *SHARE* STATE
 * For a non-stupid design, do something like the
 * implementation in the article by Nicolas Hery:
 * http://nicolashery.com/integrating-d3js-visualizations-in-a-react-app
 *
 * Chart code more or less copied from the prototype by Leo Martin Westby
 */
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var AmCharts = (typeof window !== "undefined" ? window.AmCharts : typeof global !== "undefined" ? global.AmCharts : null);
var constants = require('../constants/ScienceTeamConstants');

var chart, chartUpdater, getNewValue, updateFrequency, maxSeconds;
var radiationSamples = [];

var _require = require('../utils');

var randomInt = _require.randomInt;

function initChart(domElement) {

    chart = new AmCharts.AmSerialChart();

    chart.marginTop = 20;
    chart.marginRight = 0;
    chart.marginLeft = 0;
    chart.autoMarginOffset = 0;
    chart.dataProvider = radiationSamples;
    chart.categoryField = 'timestamp';

    //X axis
    var categoryAxis = chart.categoryAxis;
    categoryAxis.dashLength = 1;
    categoryAxis.gridAlpha = 0.15;
    categoryAxis.axisColor = '#DADADA';
    categoryAxis.title = 'Seconds';

    //Y axis
    var valueAxis = new AmCharts.ValueAxis();
    valueAxis.axisAlpha = 0.2;
    valueAxis.dashLength = 1;
    valueAxis.title = 'μSv/h';
    valueAxis.minimum = constants.SCIENCE_RADIATION_MIN;
    valueAxis.maximum = constants.SCIENCE_RADIATION_MAX;
    chart.addValueAxis(valueAxis);

    //Line
    var graph = new AmCharts.AmGraph();
    graph.valueField = 'radiation';
    graph.bullet = 'round';
    graph.bulletBorderColor = '#FFFFFF';
    graph.bulletBorderThickness = 2;
    graph.lineThickness = 2;
    graph.lineColor = '#b5030d';
    graph.negativeLineColor = '#228B22';
    graph.negativeBase = 60;
    graph.hideBulletsCount = 50;
    chart.addGraph(graph);

    //Mouseover
    var chartCursor = new AmCharts.ChartCursor();
    chartCursor.cursorPosition = 'mouse';
    chart.addChartCursor(chartCursor);
    chart.write(domElement);
}

//Adds a new radiation sample to the chart every few seconds
function startEventLoop() {
    var startTime = Date.now();
    stopEventLoop();

    chartUpdater = setInterval(function () {
        var secondsPassed = (Date.now() - startTime) / 1000;

        radiationSamples.push({
            timestamp: Math.floor(secondsPassed + 0.5),
            radiation: getNewValue()
        });

        //When the chart grows, start cutting off the oldest sample to give the chart a sliding effect
        if (radiationSamples.length > maxSeconds / updateFrequency) {
            radiationSamples.shift();
        }

        chart.validateData();
    }, updateFrequency * 1000);
}

function stopEventLoop() {
    clearInterval(chartUpdater);
}

var RadiationChart = React.createClass({
    displayName: 'RadiationChart',

    statics: {},

    propTypes: {
        updateFrequencySeconds: React.PropTypes.number.isRequired,
        maxSecondsShown: React.PropTypes.number.isRequired,
        getNewValue: React.PropTypes.func.isRequired,
        height: React.PropTypes.number.isRequired,
        width: React.PropTypes.number
    },

    mixins: [],

    componentWillMount: function componentWillMount() {
        updateFrequency = this.props.updateFrequencySeconds;
        maxSeconds = this.props.maxSecondsShown;
        getNewValue = this.props.getNewValue;
    },

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        initChart(el);
        startEventLoop();
    },

    componentWillReceiveProps: function componentWillReceiveProps() {},

    componentWillUnmount: function componentWillUnmount() {
        chart && chart.clear();
        stopEventLoop();
    },

    componentDidUnmount: function componentDidUnmount() {
        chart = null;
        //radiationSamples.length = 0;
    },

    componentDidUpdate: function componentDidUpdate() {},

    // this chart is responsible for drawing itself
    shouldComponentUpdate: function shouldComponentUpdate() {
        return false;
    },

    // Private methods

    render: function render() {

        // if you don't specify width it will max out to 100% (which is ok)
        return React.createElement('div', {
            style: { width: this.props.width + 'px', height: this.props.height + 'px' },
            className: this.props.className
        });
    }

});

module.exports = RadiationChart;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-sampler.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null),
    TimerStore = require('../stores/timer-store'),
    MissionActionCreators = require('../actions/MissionActionCreators'),
    TimerActionCreators = require('../actions/TimerActionCreators'),
    ScienceActionCreators = require('../actions/ScienceActionCreators'),
    constants = require('../constants/ScienceTeamConstants');

var RadiationSampler = React.createClass({
    displayName: 'RadiationSampler',

    propTypes: {
        requiredSamples: React.PropTypes.number.isRequired,
        radiationStoreState: React.PropTypes.object.isRequired
    },

    componentWillMount: function componentWillMount() {
        TimerStore.addChangeListener(this._handleTimerChange);
    },

    componentDidUpdate: function componentDidUpdate() {
        if (this.state.timerActive) {
            var el = React.findDOMNode(this.refs['sample-button']);
            el.focus();
        }
    },

    componentWillUnmount: function componentWillUnmount() {
        TimerStore.removeChangeListener(this._handleTimerChange);
    },

    getInitialState: function getInitialState() {
        return { timerActive: false };
    },

    _isDisabled: function _isDisabled() {
        return !this.state.timerActive;
    },

    _handleTimerChange: function _handleTimerChange() {
        var audio = React.findDOMNode(this.refs.geigerSound);
        var timerActive = TimerStore.isRunning(constants.SCIENCE_TIMER_1);

        this.setState({ timerActive: timerActive });

        if (timerActive && audio.paused) {
            audio.play();
        } else if (!timerActive && !audio.paused) {
            audio.pause();
        }
    },

    _handleClick: function _handleClick() {
        ScienceActionCreators.takeRadiationSample();

        if (this.props.radiationStoreState.samples.length + 1 >= this.props.requiredSamples) {
            TimerActionCreators.stopTimer(constants.SCIENCE_TIMER_1);
            ScienceActionCreators.completeTask('sample');
        }
    },

    render: function render() {
        var disabled, classes;

        classes = 'btn btn-primary';

        if (this._isDisabled()) {
            classes += ' disabled';
        }

        return React.createElement(
            'section',
            { className: 'radiation-sampler ' + this.props.className },
            React.createElement('div', { className: 'radiation-sampler__padder clearfix visible-xs-block' }),
            React.createElement(
                'audio',
                { ref: 'geigerSound', loop: true },
                React.createElement('source', { src: '/sounds/AOS04595_Electric_Geiger_Counter_Fast.wav', type: 'audio/wav' })
            ),
            React.createElement(
                'div',
                null,
                React.createElement(
                    'button',
                    {
                        ref: 'sample-button',
                        className: classes,
                        onClick: this._handleClick
                    },
                    'Ta strålingsprøve'
                )
            )
        );
    }

});

module.exports = RadiationSampler;
/* Avoid floating into previous block */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../actions/ScienceActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js","../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","../stores/timer-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-table.react.js":[function(require,module,exports){
(function (global){
"use strict";

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);

module.exports = React.createClass({
    displayName: "exports",

    statics: {},
    propTypes: {
        samples: React.PropTypes.array.isRequired,
        minimalRowsToShow: React.PropTypes.number
    },

    // Private methods

    getDefaultProps: function getDefaultProps() {
        return { minimalRowsToShow: 0 };
    },

    render: function render() {
        var sampleRows = this.props.samples.map(function (val, i) {
            return React.createElement(
                "tr",
                { key: i },
                React.createElement(
                    "th",
                    { scope: "row" },
                    i + 1
                ),
                React.createElement(
                    "td",
                    null,
                    val
                )
            );
        }),
            missingRows = this.props.minimalRowsToShow - sampleRows.length,
            fillRows = undefined;

        if (missingRows > 0) {
            fillRows = [];

            while (missingRows--) {
                fillRows.push(React.createElement(
                    "tr",
                    { key: fillRows.length },
                    React.createElement("th", { scope: "row" }),
                    React.createElement(
                        "td",
                        null,
                        " "
                    )
                ));
            }
        }

        return React.createElement(
            "div",
            { className: this.props.className },
            React.createElement(
                "h3",
                null,
                "Prøveresultater"
            ),
            React.createElement(
                "table",
                { className: " table table-bordered" },
                React.createElement(
                    "caption",
                    null,
                    "Strålingspartikler per sekund (p/s)"
                ),
                React.createElement(
                    "thead",
                    null,
                    React.createElement(
                        "tr",
                        null,
                        React.createElement(
                            "th",
                            { scope: "col" },
                            "Prøvenummer"
                        ),
                        React.createElement(
                            "th",
                            { scope: "col" },
                            "p/s"
                        )
                    )
                ),
                React.createElement(
                    "tbody",
                    null,
                    sampleRows,
                    fillRows
                )
            )
        );
    }

});
/* Needs filler to not collapse cell */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/science-task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var TimerPanel = require('./timer-panel.react');
var RadiationChart = require('./radiation-chart.react.js');
var RadiationSampleButton = require('./radiation-sampler.react');
var Overlay = require('./overlay.react');
var RadiationTable = require('./radiation-table.react');
var RadiationStore = require('../stores/radiation-store');
var actions = require('../actions/ScienceActionCreators');
var utils = require('../utils');
var ScienceTeamConstants = require('../constants/ScienceTeamConstants');
var TimerActionCreators = require('../actions/TimerActionCreators');

// SETTINGS
TimerActionCreators.setTimer(ScienceTeamConstants.SCIENCE_TIMER_1, 30);

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},
    propTypes: {
        appstate: React.PropTypes.object.isRequired
    },
    mixins: [],

    // life cycle methods
    getInitialState: function getInitialState() {
        return {
            radiation: RadiationStore.getState()
        };
    },

    getDefaultProps: function getDefaultProps() {
        return {};
    },

    componentWillMount: function componentWillMount() {
        RadiationStore.addChangeListener(this._handleRadiationChange);
    },

    componentWillReceiveProps: function componentWillReceiveProps() {},

    componentWillUnmount: function componentWillUnmount() {
        RadiationStore.removeChangeListener(this._handleRadiationChange);
    },

    // Private methods

    _handleRadiationChange: function _handleRadiationChange() {
        this.setState({
            radiation: RadiationStore.getState()
        });
    },

    _handleAverageRadiationSubmit: function _handleAverageRadiationSubmit(e) {
        var el = React.findDOMNode(this.refs['average-input']),
            val = el.value.trim();

        e.preventDefault();

        if (!val.length) {
            return;
        }var average = utils.parseNumber(val);
        el.value = '';

        if (average) {
            actions.averageRadiationCalculated(average);
        }
    },

    _handleAddToTotalSubmit: function _handleAddToTotalSubmit(e) {
        e.preventDefault();

        var el = React.findDOMNode(this.refs['add-to-total']);
        var val = el.value.trim();
        if (!val.length) {
            return;
        }var number = utils.parseNumber(val);

        if (!isNaN(number)) {
            actions.addToTotalRadiationLevel(number);
        }
    },

    /*
     * Helper
     * @param {string} taskName name
     * @returns {boolean} true if the current task id equals the name passed in
     */
    _isCurrentTask: function _isCurrentTask(taskName) {
        return this.props.appstate.taskStore.currentTaskId === taskName;
    },

    _radiationStatus: function _radiationStatus() {
        var num = this.state.radiation.lastCalculatedAverage,
            color;

        if (num === null) {
            return 'Ikke beregnet';
        }

        if (num > ScienceTeamConstants.SCIENCE_AVG_RAD_RED_THRESHOLD) {
            color = 'red';
        } else if (num > ScienceTeamConstants.SCIENCE_AVG_RAD_ORANGE_THRESHOLD) {
            color = 'orange';
        } else {
            color = 'green';
        }

        return React.createElement(
            'div',
            {
                className: 'radiation-indicator circle col-xs-2',
                style: { backgroundColor: color }
            },
            num
        );
    },

    render: function render() {
        var showSampleInput = this._isCurrentTask('sample'),
            showAverageInput = this._isCurrentTask('average'),
            showAddToTotalInput = this._isCurrentTask('addtotal');

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'dl',
                    { className: 'radiation-values col-xs-6 ' },
                    React.createElement(
                        'dt',
                        null,
                        'Totalt strålingsnivå'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        this.state.radiation.total
                    ),
                    React.createElement(
                        'dt',
                        null,
                        'Sist innlest strålingsnivå'
                    ),
                    React.createElement(
                        'dd',
                        null,
                        this._radiationStatus(),
                        ' '
                    )
                ),
                React.createElement(RadiationTable, {
                    minimalRowsToShow: 4,
                    samples: this.state.radiation.samples,
                    className: 'col-xs-6 ' })
            ),
            React.createElement('hr', null),
            React.createElement(
                'div',
                { className: 'instruments' },
                React.createElement(
                    'fieldset',
                    { disabled: !showSampleInput, className: 'instruments__section row overlayable' },
                    React.createElement(Overlay, { active: !showSampleInput }),
                    React.createElement(
                        'h3',
                        { className: 'col-xs-12' },
                        'Ta prøver'
                    ),
                    React.createElement(TimerPanel, { className: 'col-xs-12 col-sm-8', timerId: ScienceTeamConstants.SCIENCE_TIMER_1 }),
                    React.createElement(RadiationSampleButton, {
                        className: 'col-xs-5 col-sm-4',
                        radiationStoreState: this.state.radiation,
                        requiredSamples: 4
                    })
                ),
                React.createElement('hr', null),
                React.createElement(
                    'div',
                    { className: 'row overlayable' },
                    React.createElement(Overlay, { active: !showAverageInput }),
                    React.createElement(
                        'section',
                        { className: 'radiation-input instruments__section col-xs-12 col-sm-6' },
                        React.createElement(
                            'div',
                            { className: 'row' },
                            React.createElement(
                                'h3',
                                { className: 'col-xs-12' },
                                'Gjennomsnittlig stråling'
                            ),
                            React.createElement(
                                'fieldset',
                                { className: 'col-xs-8', disabled: !showAverageInput },
                                React.createElement(
                                    'form',
                                    { onSubmit: this._handleAverageRadiationSubmit },
                                    React.createElement('input', { ref: 'average-input',
                                        type: 'number',
                                        step: '0.1',
                                        min: '1',
                                        max: '100',
                                        className: 'radiation-input__input'
                                    }),
                                    React.createElement(
                                        'button',
                                        { className: 'btn btn-primary' },
                                        'Evaluer'
                                    )
                                )
                            )
                        )
                    )
                ),
                React.createElement('hr', null),
                React.createElement(
                    'div',
                    { className: 'row overlayable' },
                    React.createElement(Overlay, { active: !showAddToTotalInput }),
                    React.createElement(
                        'fieldset',
                        { className: 'radiation-input col-xs-8', disabled: !showAddToTotalInput },
                        React.createElement(
                            'h3',
                            null,
                            'Legg verdi til total'
                        ),
                        React.createElement(
                            'form',
                            { onSubmit: this._handleAddToTotalSubmit },
                            React.createElement(
                                'select',
                                { ref: 'add-to-total', className: 'radiation-input__input' },
                                React.createElement(
                                    'option',
                                    { value: '0' },
                                    '0'
                                ),
                                React.createElement(
                                    'option',
                                    { value: '15' },
                                    '15'
                                ),
                                React.createElement(
                                    'option',
                                    { value: '50' },
                                    '50'
                                )
                            ),
                            React.createElement(
                                'button',
                                { className: 'btn btn-primary' },
                                'Evaluer'
                            )
                        )
                    )
                )
            )
        );
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/ScienceActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/ScienceActionCreators.js","../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","../stores/radiation-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/radiation-store.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./overlay.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/overlay.react.js","./radiation-chart.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-chart.react.js","./radiation-sampler.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-sampler.react.js","./radiation-table.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/radiation-table.react.js","./timer-panel.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer-panel.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/security-task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var CO2Store = require('../stores/carbon-dioxide-store');
var OxygenStore = require('../stores/oxygen-store');
var CommunicationQualityStore = require('../stores/communication-quality-store');
var SecurityTeamAC = require('../actions/SecurityTeamActionCreators');

var chart = null;
var chartData = [{ title: 'Luft', value: 100 }];

function init(domElem) {
    chart = new AmCharts.AmPieChart();
    chart.valueField = 'value';
    chart.titleField = 'title';
    chart.dataProvider = chartData;
    chart.write(domElem);
}

var PieChart = React.createClass({
    displayName: 'PieChart',

    propTypes: {
        height: React.PropTypes.string.isRequired,
        width: React.PropTypes.string
    },

    componentWillMount: function componentWillMount() {
        var _this = this;

        CO2Store.addChangeListener(function () {
            return _this._updateData();
        });
    },

    componentDidMount: function componentDidMount() {
        var el = React.findDOMNode(this);
        init(el);
    },

    shouldComponentUpdate: function shouldComponentUpdate() {
        return false;
    },

    _updateData: function _updateData() {
        var co2 = CO2Store.co2Level();
        chartData.length = 0;
        chartData.push({ title: 'Annen luft', value: 100 - co2 });
        chartData.push({ title: 'CO₂', value: co2 });

        chart.validateData();
    },

    render: function render() {
        return React.createElement('div', { style: { height: this.props.height, width: this.props.width } });
    }
});

var ProgressBar = React.createClass({
    displayName: 'ProgressBar',

    propTypes: {
        progress: React.PropTypes.number.isRequired,
        max: React.PropTypes.number.isRequired,
        active: React.PropTypes.bool.isRequired,
        className: React.PropTypes.string
    },

    render: function render() {
        var val = this.props.progress,
            max = this.props.max;
        return React.createElement(
            'div',
            { className: 'progress' },
            React.createElement(
                'div',
                {
                    className: 'progress-bar progress-bar-striped ' + this.props.className + (this.props.active ? ' active' : ''),
                    style: { width: val * max + '%' },
                    role: 'progressbar' },
                Math.min(Math.round(val * max), max),
                '%'
            )
        );
    }
});

module.exports = React.createClass({
    displayName: 'exports',

    statics: {},

    propTypes: {},

    mixins: [],

    getInitialState: function getInitialState() {
        var state = this._getState();
        state.commProgress = 0;
        state.qualityProgress = 0;
        state.dataQualityFailing = true;
        state.readyForSafeMode = false;
        return state;
    },

    componentWillMount: function componentWillMount() {
        var _this2 = this;

        OxygenStore.addChangeListener(function () {
            return _this2._updateState();
        });
        CommunicationQualityStore.addChangeListener(function () {
            return _this2._updateState();
        });
    },

    componentWillUnmount: function componentWillUnmount() {},

    _startQualityProgressBar: function _startQualityProgressBar() {
        var _this3 = this;

        var ms = 500,
            totalDuration = 5 * 1000;
        this.setState({ qualityProgress: 0 });

        var tmp = setInterval(function () {
            var number = _this3.state.qualityProgress;
            number += ms / totalDuration;

            if (number >= 1) {
                clearInterval(tmp);
                SecurityTeamAC.endDataQualityTest(!_this3.state.dataQualityFailing);
                setTimeout(function () {
                    return _this3.setState({ qualityProgress: 0 });
                }, 9000);
            }

            _this3.setState({ qualityProgress: number });
        }, ms);
    },

    _startTransferProgressBar: function _startTransferProgressBar() {
        var _this4 = this;

        var ms = 500,
            totalDuration = 5 * 1000;
        this.setState({ commProgress: 0 });

        var tmp = setInterval(function () {
            var number = _this4.state.commProgress;
            number += ms / totalDuration;

            if (number >= 1) {
                clearInterval(tmp);
                SecurityTeamAC.endDataTransferTest(!_this4.state.dataTransferFailing);
                setTimeout(function () {
                    return _this4.setState({ commProgress: 0 });
                }, 9000);
            }

            _this4.setState({ commProgress: number });
        }, ms);
    },

    _qualityActive: function _qualityActive() {
        return this.state.qualityProgress < 1;
    },

    _commActive: function _commActive() {
        return this.state.commProgress < 1;
    },

    _updateState: function _updateState() {
        this.setState(this._getState());
    },

    _indicatorColor: function _indicatorColor() {
        return this.state.oxygenStore.colorIndicator;
    },

    _getState: function _getState() {
        return {
            oxygenStore: OxygenStore.getState(),
            dataQualityFailing: CommunicationQualityStore.qualityTestShouldFail(),
            dataTransferFailing: CommunicationQualityStore.transferTestShould(),
            readyForSafeMode: CommunicationQualityStore.readyForSafeMode()
        };
    },

    render: function render() {

        var indicator = React.createElement('div', {
            className: 'circle ',
            style: { display: 'inline-block', backgroundColor: this._indicatorColor() }
        });

        return React.createElement(
            'div',
            null,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'col-sm-6' },
                    React.createElement(
                        'button',
                        {
                            style: { marginBottom: '20px' },
                            className: 'btn btn-primary ' + (this.state.readyForSafeMode ? '' : 'disabled'),
                            onClick: SecurityTeamAC.setInSafeMode
                        },
                        'Send i SAFE MODE'
                    ),
                    React.createElement(
                        'ul',
                        { className: '' },
                        React.createElement(
                            'li',
                            null,
                            'Scrubfilter byttet: ',
                            CO2Store.filterChanged() ? 'ja' : 'nei'
                        ),
                        React.createElement(
                            'li',
                            null,
                            'Oksygenindikator: ',
                            indicator,
                            ' '
                        )
                    )
                ),
                React.createElement(
                    'div',
                    { className: 'col-xs-12 col-sm-6' },
                    React.createElement(
                        'h3',
                        null,
                        'Innhold karbondioksid i drakten av total luftmengde'
                    ),
                    React.createElement(PieChart, { height: '200px' })
                )
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: '' },
                    React.createElement(
                        'p',
                        { className: '' },
                        'Kommunikasjon og data'
                    ),
                    React.createElement(
                        'p',
                        null,
                        'Kommunikasjonsstatus '
                    ),
                    React.createElement(ProgressBar, {
                        max: 100,
                        active: this._commActive(),
                        className: this.state.dataTransferFailing ? !this._commActive() ? 'progress-bar-danger' : '' : '',
                        progress: this.state.commProgress }),
                    React.createElement(
                        'button',
                        { onClick: this._startTransferProgressBar,
                            className: 'btn btn-primary' },
                        'Test'
                    ),
                    React.createElement(
                        'p',
                        null,
                        'Datakvalitet'
                    ),
                    React.createElement(ProgressBar, {
                        max: 100,
                        active: this._qualityActive(),
                        className: this.state.dataQualityFailing ? !this._qualityActive() ? 'progress-bar-danger' : '' : '',
                        progress: this.state.qualityProgress }),
                    React.createElement(
                        'button',
                        { className: 'btn btn-primary ' + (this.state.dataTransferFailing ? 'disabled' : ''),
                            onClick: this._startQualityProgressBar
                        },
                        'Test'
                    )
                )
            )
        );
    }

});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/SecurityTeamActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/SecurityTeamActionCreators.js","../stores/carbon-dioxide-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/carbon-dioxide-store.js","../stores/communication-quality-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/communication-quality-store.js","../stores/oxygen-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/oxygen-store.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/task.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var MessageStore = require('../stores/message-store');
var TaskStore = require('../stores/task-store');
var RouteStore = require('../stores/route-store');
var MessageList = require('./message-list.react');
var IntroductionScreen = require('./introduction-screen.react.js');
var TeamDisplayer = require('./team-displayer.react');
var MissionTimer = require('./mission-timer.react.js');
var ScienceTask = require('./science-task.react');
var AstronautTask = require('./astronaut-task.react');
var CommunicationTask = require('./communication-task.react.js');
var SecurityTask = require('./security-task.react.js');
var _require = require('util');

var format = _require.format;

// lazyrequire
function lazyRequire(path) {
    var tmp = null;
    return function () {
        if (!tmp) tmp = require(path);
        return tmp;
    };
}
if (false) {
    require('../actions/MissionActionCreators');
}
var getMissionAC = lazyRequire('../actions/MissionActionCreators');

function urlOfTask(taskId) {
    return format('/%s/task/%s', RouteStore.getTeamId(), taskId);
}

function transitionToCurrentTask(transitionFunction) {
    var currentTaskId = TaskStore.getCurrentTaskId();

    // this logic is fragile - if you should suddenly decide to visit another team
    // _after_ you have started a task, the team+task combo is invalid -> 404
    if (currentTaskId !== RouteStore.getTaskId()) {
        var to = urlOfTask(currentTaskId);
        transitionFunction(to);
    }
}

var Task = React.createClass({
    displayName: 'Task',

    contextTypes: {
        router: React.PropTypes.func
    },

    mixins: [],

    statics: {
        willTransitionTo: function willTransitionTo(transition) {
            transitionToCurrentTask(transition.redirect.bind(transition));
        }
    },

    componentDidMount: function componentDidMount() {},

    componentWillMount: function componentWillMount() {
        MessageStore.addChangeListener(this._onChange);
        TaskStore.addChangeListener(this._onChange);
        //console.log('componentWillMount');
    },

    componentWillUnmount: function componentWillUnmount() {
        //console.log('componentWillUnmount');
        MessageStore.removeChangeListener(this._onChange);
        TaskStore.removeChangeListener(this._onChange);

        clearTimeout(this._stateTimeout);
    },

    componentDidUnmount: function componentDidUnmount() {},

    componentDidUpdate: function componentDidUpdate() {},

    getInitialState: function getInitialState() {
        var _this = this;

        setTimeout(function () {
            return _this.setState({ taskIsNew: false });
        }, 2000);

        return {
            messages: MessageStore.getMessages(),
            taskStore: TaskStore.getState(),
            taskIsNew: true
        };
    },

    _onChange: function _onChange() {
        var _this2 = this;

        this.setState({
            messages: MessageStore.getMessages(),
            taskStore: TaskStore.getState(),
            taskIsNew: true
        });

        var router = this.context.router;
        transitionToCurrentTask(router.transitionTo.bind(router));

        // a bit rudimentary - triggers on all changes, not just Task changes ...
        this._stateTimeout = setTimeout(function () {
            return _this2.setState({ taskIsNew: false });
        }, 2000);
    },

    _createSubTaskUI: function _createSubTaskUI() {
        switch (RouteStore.getTeamId()) {
            case 'science':
                return React.createElement(ScienceTask, { appstate: this.state });
            case 'astronaut':
                return React.createElement(AstronautTask, { appstate: this.state });
            case 'communication':
                return React.createElement(CommunicationTask, { appstate: this.state });
            case 'security':
                return React.createElement(SecurityTask, { appstate: this.state });
        }
    },

    _handleTaskOKClick: function _handleTaskOKClick() {
        getMissionAC().taskCompleted(RouteStore.getTeamId(), this.state.taskStore.currentTaskId);
    },

    render: function render() {
        var content = this._createSubTaskUI(),
            blink = this.state.taskIsNew ? 'blink' : '',
            teamNames = undefined,
            missionTimer = undefined;

        teamNames = React.createElement(
            'div',
            { id: 'team-name', className: '' },
            React.createElement(
                'header',
                { className: '' },
                React.createElement(TeamDisplayer, { className: '' })
            )
        );

        missionTimer = React.createElement(
            'section',
            { id: 'mission-timer', className: '' },
            React.createElement(MissionTimer, null)
        );

        if (!this.props.isMissionRunning) {
            var message = {
                id: 'not_used',
                text: 'Ikke klar. Venter på at oppdraget skal starte.',
                level: 'info'
            };

            return React.createElement(
                'div',
                null,
                teamNames,
                React.createElement(
                    'div',
                    { className: 'row' },
                    React.createElement(MessageList, { className: 'col-xs-12',
                        messages: [message] })
                )
            );
        }

        return React.createElement(
            'div',
            { className: '' },
            teamNames,
            missionTimer,
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(MessageList, { className: 'col-xs-12', messages: this.state.messages })
            ),
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'col-xs-12' },
                    React.createElement(
                        'div',
                        { className: 'jumbotron taskbox' },
                        React.createElement(
                            'h2',
                            { className: 'taskbox__header' },
                            'Oppgave'
                        ),
                        React.createElement(
                            'span',
                            { className: 'taskbox__text ' + blink },
                            ' ',
                            this.state.taskStore.currentTask,
                            ' '
                        ),
                        this.state.taskStore.plainInfo && React.createElement(
                            'button',
                            { className: 'btn-primary btn',
                                onClick: this._handleTaskOKClick
                            },
                            'OK'
                        )
                    )
                )
            ),
            content
        );
    }

});

module.exports = Task;

//console.log('componentDidUnmount');

//console.log('.componentDidUpdate');
/* if you want this to be sticky: http://codepen.io/senff/pen/ayGvD */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/MissionActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/MissionActionCreators.js","../stores/message-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/message-store.js","../stores/route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","../stores/task-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/task-store.js","./astronaut-task.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/astronaut-task.react.js","./communication-task.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/communication-task.react.js","./introduction-screen.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/introduction-screen.react.js","./message-list.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/message-list.react.js","./mission-timer.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-timer.react.js","./science-task.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/science-task.react.js","./security-task.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/security-task.react.js","./team-displayer.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/team-displayer.react.js","util":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/util.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/team-displayer.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var RouteStore = require('../stores/route-store');
var teamNames = require('../team-name-map');

var TeamWidget = React.createClass({
    displayName: 'TeamWidget',

    contextTypes: {
        router: React.PropTypes.func
    },

    mixins: [],

    _onChange: function _onChange() {
        this.forceUpdate();
    },

    componentDidMount: function componentDidMount() {},

    componentWillUnmount: function componentWillUnmount() {},

    teamName: function teamName() {
        return teamNames.nameMap[RouteStore.getTeamId()];
    },

    otherTeamNames: function otherTeamNames() {
        return teamNames.otherTeamNames(RouteStore.getTeamId());
    },

    render: function render() {

        return React.createElement(
            'div',
            { className: this.props.className + ' teamwidget' },
            React.createElement(
                'span',
                { className: 'active' },
                this.teamName()
            ),
            React.createElement(
                'span',
                { className: '' },
                ', ',
                this.otherTeamNames(),
                ' '
            )
        );
    }
});

module.exports = TeamWidget;

//RouteStore.addChangeListener(this._onChange);

//RouteStore.removeChangeListener(this._onChange);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../stores/route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","../team-name-map":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/team-name-map.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer-panel.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null),
    actions = require('../actions/TimerActionCreators'),
    Timer = require('./timer.react.js'),
    TimerStore = require('../stores/timer-store');

module.exports = React.createClass({
    displayName: 'exports',

    propTypes: {
        timerId: React.PropTypes.string.isRequired
    },

    getInitialState: function getInitialState() {
        return this._getTimerState();
    },

    componentDidMount: function componentDidMount() {
        TimerStore.addChangeListener(this._handleTimeStoreChange);
    },

    componentWillUnmount: function componentWillUnmount() {
        TimerStore.removeChangeListener(this._handleTimeStoreChange);
    },

    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
        return nextState.timeInSeconds !== this.state.timeInSeconds;
    },

    componentDidUpdate: function componentDidUpdate() {},

    _handleTimeStoreChange: function _handleTimeStoreChange() {
        this.setState(this._getTimerState());
    },

    _handleClick: function _handleClick() {
        actions.startTimer(this.props.timerId);
    },

    _getTimerState: function _getTimerState() {
        return {
            ready: TimerStore.isReadyToStart(this.props.timerId),
            timeInSeconds: TimerStore.getRemainingTime(this.props.timerId)
        };
    },

    render: function render() {
        return React.createElement(
            'section',
            { className: 'timer ' + this.props.className },
            React.createElement(
                'div',
                { className: 'row' },
                React.createElement(
                    'div',
                    { className: 'timer--button col-xs-5 ' },
                    React.createElement(
                        'button',
                        {
                            className: 'btn btn-primary ' + (this.state.ready ? '' : 'disabled'),
                            onClick: this._handleClick },
                        'Start klokka'
                    )
                ),
                React.createElement(
                    'div',
                    { className: 'timer--value col-xs-6 padding-xs-1' },
                    React.createElement(Timer, { timeInSeconds: this.state.timeInSeconds })
                )
            )
        );
    }
});

//console.log('TimerPanel.componentDidUpdate');

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../actions/TimerActionCreators":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/actions/TimerActionCreators.js","../stores/timer-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js","./timer.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/timer.react.js":[function(require,module,exports){
(function (global){
// This example can be modified to act as a countdown timer

'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null),
    printf = require('printf');

function pad(num) {
    return printf('%02d', num);
}

var Timer = React.createClass({
    displayName: 'Timer',

    propTypes: {
        timeInSeconds: React.PropTypes.number.isRequired
    },

    componentDidUpdate: function componentDidUpdate() {},

    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
        return nextProps.timeInSeconds !== this.props.timeInSeconds;
    },

    _minutes: function _minutes() {
        return pad(Math.max(0, this.props.timeInSeconds) / 60 >> 0);
    },

    _seconds: function _seconds() {
        return pad(Math.max(0, this.props.timeInSeconds) % 60);
    },

    _timeValue: function _timeValue() {
        return this._minutes() + ':' + this._seconds();
    },

    render: function render() {
        return React.createElement(
            'div',
            { className: 'timer-value' },
            ' ',
            this._timeValue()
        );
    }
});

module.exports = Timer;

//console.log('Timer.componentDidUpdate');

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"printf":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/printf/lib/printf.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js":[function(require,module,exports){
'use strict';

window.__astConst = module.exports = {
    GOOD_OXYGEN: 'GOOD_OXYGEN',
    WARN_OXYGEN: 'WARN_OXYGEN',
    CRITICAL_OXYGEN: 'CRITICAL_OXYGEN',
    LOW_RESP_RATE: 'LOW_RESP_RATE',
    HIGH_RESP_RATE: 'HIGH_RESP_RATE',

    /* remove? don't think they are used */
    SET_HEART_RATE: 'SET_HEART_RATE',
    SET_OXYGEN_LEVEL: 'SET_OXYGEN_LEVEL',
    SET_OXYGEN_CONSUMPTION: 'SET_OXYGEN_CONSUMPTION',

    HEART_RATE_TIMER: 'HEART_RATE_TIMER',
    RESPIRATION_TIMER: 'RESPIRATION_TIMER'
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MessageConstants.js":[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

module.exports = _Object$freeze({
    // events
    MESSAGE_ADDED: 'MESSAGE_ADDED',
    REMOVE_MESSAGE: 'REMOVE_MESSAGE'
});

},{"babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js":[function(require,module,exports){
'use strict';

module.exports = require('react/lib/keyMirror')({
    MISSION_TIME_SYNC: 'MISSION_TIME_SYNC',
    MISSION_STARTED_EVENT: 'MISSION_STARTED_EVENT',
    MISSION_STOPPED_EVENT: 'MISSION_STOPPED_EVENT',
    MISSION_COMPLETED_EVENT: 'MISSION_COMPLETED_EVENT',
    MISSION_WAS_RESET: 'MISSION_WAS_RESET',
    RECEIVED_EVENTS: null,
    INTRODUCTION_READ: 'INTRODUCTION_READ',
    START_TASK: 'START_TASK',
    COMPLETED_TASK: 'COMPLETED_TASK',
    ASK_FOR_APP_STATE: 'ASK_FOR_APP_STATE',
    RECEIVED_APP_STATE: 'RECEIVED_APP_STATE',
    SENDING_TEAM_STATE: 'SENDING_TEAM_STATE'
});

},{"react/lib/keyMirror":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/keyMirror.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/RouterConstants.js":[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

module.exports = _Object$freeze({
    // events
    ROUTE_CHANGED_EVENT: 'ROUTE_CHANGED_EVENT',
    ROUTER_AVAILABLE: 'ROUTER_AVAILABLE' });

},{"babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js":[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

module.exports = _Object$freeze({
    // ids
    SCIENCE_TIMER_1: 'SCIENCE_TIMER_1',
    SCIENCE_RADIATION_WARNING_MSG: 'SCIENCE_RADIATION_WARNING_MSG',

    SCIENCE_CLEAR_RADIATION_SAMPLES: 'SCIENCE_CLEAR_RADIATION_SAMPLES',

    // events
    SCIENCE_COUNTDOWN_TIMER_CHANGED: 'SCIENCE_COUNTDOWN_TIMER_CHANGED',
    SCIENCE_TAKE_RADIATION_SAMPLE: 'SCIENCE_TAKE_RADIATION_SAMPLE',
    SCIENCE_RADIATION_LEVEL_CHANGED: 'SCIENCE_RADIATION_LEVEL_CHANGED',
    SCIENCE_TOTAL_RADIATION_LEVEL_CHANGED: 'SCIENCE_TOTAL_RADIATION_LEVEL_CHANGED',
    SCIENCE_AVG_RADIATION_CALCULATED: 'SCIENCE_AVG_RADIATION_CALCULATED',

    // values
    SCIENCE_RADIATION_MIN: 0,
    SCIENCE_RADIATION_MAX: 100,
    SCIENCE_AVG_RAD_GREEN_VALUE: 0,
    SCIENCE_AVG_RAD_ORANGE_VALUE: 15,
    SCIENCE_AVG_RAD_RED_VALUE: 50,
    SCIENCE_AVG_RAD_ORANGE_THRESHOLD: 40,
    SCIENCE_AVG_RAD_RED_THRESHOLD: 75,
    SCIENCE_TOTAL_RADIATION_SERIOUS_THRESHOLD: 50,
    SCIENCE_TOTAL_RADIATION_VERY_SERIOUS_THRESHOLD: 75
});

},{"babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/TimerConstants.js":[function(require,module,exports){
'use strict';

module.exports = {
    SET_TIMER: 'SET_TIMER',
    START_TIMER: 'START_TIMER',
    STOP_TIMER: 'STOP_TIMER',
    RESET_TIMER: 'RESET_TIMER'
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js":[function(require,module,exports){
(function (global){
// proxy access to the router as first step in bringing it into the flux flow
// @see https://github.com/rackt/react-router/blob/master/docs/guides/flux.md

'use strict';

var router = null;

window.__router = module.exports = {
    transitionTo: function transitionTo(to, params, query) {
        return router.transitionTo(to, params, query);
    },

    getCurrentPathname: function getCurrentPathname() {
        return window.location.pathname;
    },

    getTeamId: function getTeamId() {
        return this.getCurrentPathname().split('/')[1];
    },

    getTaskId: function getTaskId() {
        return this.getCurrentPathname().split('/')[3];
    },

    run: function run() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return router.run.apply(router, args);
    }
};

var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var routes = require('./routes.react');

// By the time route config is require()-d,
// require('./router') already returns a valid object

router = Router.create({
    routes: routes,

    // Use the HTML5 History API for clean URLs
    location: Router.HistoryLocation
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./routes.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/routes.react.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/routes.react.js":[function(require,module,exports){
(function (global){
'use strict';

var React = (typeof window !== "undefined" ? window.React : typeof global !== "undefined" ? global.React : null);
var Router = (typeof window !== "undefined" ? window.ReactRouter : typeof global !== "undefined" ? global.ReactRouter : null);
var Route = Router.Route;
var NotFoundRoute = Router.NotFoundRoute;
var DefaultRoute = Router.DefaultRoute;

var App = require('./components/app.react');
var MissionCommanderApp = require('./components/mission-commander.react.js');
var IndexApp = require('./components/index-app.react');
var NotFound = require('./components/not-found.react');
var IntroScreen = require('./components/introduction-screen.react');
var SolarStorm = require('./components/full-screen-video.js');
var Task = require('./components/task.react');
var DummyRenderMixin = require('./components/dummy-render.mixin');

var _require = require('./utils');

var cleanRootPath = _require.cleanRootPath;

var teamNameMap = require('./team-name-map');

var RedirectToIntro = React.createClass({
    displayName: 'RedirectToIntro',

    statics: {
        willTransitionTo: function willTransitionTo(transition) {
            var teamId = cleanRootPath(transition.path);

            if (teamId in teamNameMap.nameMap) {
                transition.redirect(transition.path + '/intro');
            }
        }
    },

    //mixins : [DummyRenderMixin]
    render: function render() {
        return React.createElement(NotFound, null);
    }
});

var routes = React.createElement(
    Route,
    { name: 'app', path: '/', handler: App },
    React.createElement(Route, { name: 'job-completed', path: '/completed', handler: SolarStorm }),
    React.createElement(Route, { name: 'commander', handler: MissionCommanderApp }),
    React.createElement(Route, { name: 'team-root', path: '/:teamId', handler: RedirectToIntro }),
    React.createElement(Route, { name: 'team-intro', path: '/:teamId/intro', handler: IntroScreen }),
    React.createElement(Route, { name: 'team-task', path: '/:teamId/task/:taskId', handler: Task }),
    React.createElement(NotFoundRoute, { handler: NotFound }),
    React.createElement(DefaultRoute, { handler: IndexApp })
);

module.exports = routes;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./components/app.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/app.react.js","./components/dummy-render.mixin":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/dummy-render.mixin.js","./components/full-screen-video.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/full-screen-video.js","./components/index-app.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/index-app.react.js","./components/introduction-screen.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/introduction-screen.react.js","./components/mission-commander.react.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/mission-commander.react.js","./components/not-found.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/not-found.react.js","./components/task.react":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/components/task.react.js","./team-name-map":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/team-name-map.js","./utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js":[function(require,module,exports){
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var EventEmitter = require('events');
var CHANGE_EVENT = 'CHANGE_EVENT';

var path = null;

var BaseStore = (function (_EventEmitter) {
    function BaseStore() {
        _classCallCheck(this, BaseStore);

        if (_EventEmitter != null) {
            _EventEmitter.apply(this, arguments);
        }
    }

    _inherits(BaseStore, _EventEmitter);

    _createClass(BaseStore, [{
        key: 'emitChange',
        value: function emitChange() {
            this.emit(CHANGE_EVENT);
        }
    }, {
        key: 'addChangeListener',

        /**
         * @param {function} callback
         * @returns emitter, so calls can be chained.
         */
        value: function addChangeListener(callback) {
            return this.on(CHANGE_EVENT, callback);
        }
    }, {
        key: 'removeChangeListener',

        /**
         * @param {function} callback
         * @returns emitter, so calls can be chained.
         */
        value: function removeChangeListener(callback) {
            return this.removeListener(CHANGE_EVENT, callback);
        }
    }, {
        key: 'dispatcherIndex',
        value: undefined,
        enumerable: true
    }]);

    return BaseStore;
})(EventEmitter);

module.exports = BaseStore;

},{"babel-runtime/helpers/class-call-check":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/class-call-check.js","babel-runtime/helpers/create-class":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/create-class.js","babel-runtime/helpers/inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/inherits.js","events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/breath-rate-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MConstants = require('../constants/MissionConstants');
var AstConstants = require('../constants/AstroTeamConstants');
var BaseStore = require('./base-store');

var current = AstConstants.LOW_RESP_RATE;

var BreathRateStore = module.exports = _Object$assign(new BaseStore(), {

    getState: function getState() {
        if (current == AstConstants.LOW_RESP_RATE) {
            return { rate: current, min: 23, max: 28 };
        } else {
            return { rate: current, min: 45, max: 55 };
        }
    },

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {
            case MConstants.RECEIVED_APP_STATE:
                var appState = payload.appState;

                if (appState.breath_rate === 'high') {
                    current = AstConstants.HIGH_RESP_RATE;
                } else {
                    current = AstConstants.LOW_RESP_RATE;
                }

                BreathRateStore.emitChange();
                break;
        }

        return true;
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/carbon-dioxide-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MissionConstants = require('../constants/MissionConstants');
var BaseStore = require('./base-store');

var level = 0;
var filterChanged = false;

var CO2Store = module.exports = _Object$assign(new BaseStore(), {

    co2Level: function co2Level() {
        return level;
    },

    filterChanged: (function (_filterChanged) {
        function filterChanged() {
            return _filterChanged.apply(this, arguments);
        }

        filterChanged.toString = function () {
            return _filterChanged.toString();
        };

        return filterChanged;
    })(function () {
        return filterChanged;
    }),

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {
            case MissionConstants.RECEIVED_APP_STATE:
                var appState = payload.appState;

                level = appState.carbon_dioxide;
                filterChanged = appState.scrub_filter_changed;
                CO2Store.emitChange();
                break;
        }

        return true;
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/communication-quality-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var MissionConstants = require('../constants/MissionConstants');
var BaseStore = require('./base-store');
var qualityShouldFail = true;
var transferShouldFail = true;
var _readyForSafeMode = false;

var CommunicationQualityStore = module.exports = _Object$assign(new BaseStore(), {

    qualityTestShouldFail: function qualityTestShouldFail() {
        return qualityShouldFail;
    },

    transferTestShould: function transferTestShould() {
        return transferShouldFail;
    },

    readyForSafeMode: function readyForSafeMode() {
        return _readyForSafeMode;
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {

        if (payload.action === MissionConstants.RECEIVED_APP_STATE) {
            qualityShouldFail = payload.appState.quality_test_should_fail;
            transferShouldFail = payload.appState.transfer_test_should_fail;
            _readyForSafeMode = payload.appState.ready_for_safe_mode;

            CommunicationQualityStore.emitChange();
        }
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/event-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MConstants = require('../constants/MissionConstants');
var BaseStore = require('./base-store');

var eventsCollection = {
    remaining: [],
    completed: [],
    overdue: []
};

var EventStore = module.exports = window.__eventStore = _Object$assign(new BaseStore(), {

    remaining: function remaining() {
        return eventsCollection.remaining;
    },

    completed: function completed() {
        return eventsCollection.completed;
    },

    overdue: function overdue() {
        return eventsCollection.overdue;
    },

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {

            case MConstants.RECEIVED_EVENTS:
                eventsCollection.remaining = payload.remaining;
                eventsCollection.overdue = payload.overdue;
                eventsCollection.completed = payload.completed;
                EventStore.emitChange();

                break;
        }

        return true;
    })
});

//window.__eventStore = module.exports;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/heart-rate-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MConstants = require('../constants/MissionConstants');
var AstConstants = require('../constants/AstroTeamConstants');
var BaseStore = require('./base-store');

var current = { min: 60, max: 70 };

var HeartRateStore = module.exports = _Object$assign(new BaseStore(), {

    // om vi vil backe opp verdier på server må vi bruke denne storen
    getState: function getState() {
        return current;
    },

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {
            case MConstants.RECEIVED_APP_STATE:
                var rate = payload.appState.heart_rate;
                if (rate && rate.min && rate.max) {
                    current = rate;
                    HeartRateStore.emitChange();
                }
                break;
        }

        return true;
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/introduction-store.js":[function(require,module,exports){
/* Holds the state of whether introductions have been read */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');
var MissionConstants = require('../constants/MissionConstants');
var RouteStore = require('./route-store');

var introRead = {};

var IntroductionStore = _Object$assign(new BaseStore(), {

    setIntroductionRead: function setIntroductionRead(team) {
        introRead['intro_' + team] = true;
        this.emitChange();
    },

    isIntroductionRead: function isIntroductionRead(team) {
        if (!team) {
            throw new Error('Missing argument "team"');
        }

        return introRead['intro_' + team];
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;

        switch (action) {
            case MissionConstants.INTRODUCTION_READ:
                IntroductionStore.setIntroductionRead(payload.teamName);
                break;

            case MissionConstants.RECEIVED_APP_STATE:
                var teamId = RouteStore.getTeamId();

                var teamState = payload.appState[teamId];

                if (teamState && teamState.introduction_read) {
                    IntroductionStore.setIntroductionRead(teamState.team);
                }
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__IntroductionStore = IntroductionStore;
module.exports = IntroductionStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","./route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/message-store.js":[function(require,module,exports){
/* A store that can be queried for the current path */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _require = require('events');

var Emitter = _require.Emitter;

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');

var _require2 = require('../constants/MessageConstants');

var REMOVE_MESSAGE = _require2.REMOVE_MESSAGE;
var MESSAGE_ADDED = _require2.MESSAGE_ADDED;

var messages = {};

var MessageStore = _Object$assign(new BaseStore(), {

    reset: function reset() {
        messages = {};
        this.emitChange();
    },

    handleAddedMessage: function handleAddedMessage(data) {
        data.dismissable = data.dismissable === undefined ? true : data.dismissable;
        messages[data.id] = data;
        this.emitChange();
    },

    handleRemoveMessage: function handleRemoveMessage(id) {
        delete messages[id];
        this.emitChange();
    },

    /**
     * A list of all messages matching filter
     * @param [filter]
     * @returns []Message a Message = { text, id, level }
     */
    getMessages: function getMessages(filter) {
        if (!filter) {
            return _Object$keys(messages).map(function (msgKey) {
                return messages[msgKey];
            });
        } else throw new Error('UNIMPLEMENTED "filter" feature');
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;
        var data = payload.data;

        switch (action) {
            case MESSAGE_ADDED:
                MessageStore.handleAddedMessage(data);
                break;
            case REMOVE_MESSAGE:
                MessageStore.handleRemoveMessage(data);
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__MessageStore = MessageStore;
module.exports = MessageStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MessageConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MessageConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","babel-runtime/core-js/object/keys":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/keys.js","events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/mission-state-store.js":[function(require,module,exports){
/* A store that can be queried for the current path */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _require = require('events');

var Emitter = _require.Emitter;

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');

var _require2 = require('../constants/MissionConstants');

var MISSION_STARTED_EVENT = _require2.MISSION_STARTED_EVENT;
var MISSION_STOPPED_EVENT = _require2.MISSION_STOPPED_EVENT;
var RECEIVED_APP_STATE = _require2.RECEIVED_APP_STATE;

var missionRunning = false,
    missionHasBeenStopped = false;
var currentChapter = null;
var chapterTime = 0;
var inSafeMode = false;

var MissionStateStore = _Object$assign(new BaseStore(), {

    handleMissionStarted: function handleMissionStarted() {
        missionRunning = true;
        this.emitChange();
    },

    handleMissionStopped: function handleMissionStopped() {
        missionRunning = false;
        this.emitChange();
    },

    isSatelliteInSafeMode: function isSatelliteInSafeMode() {
        return inSafeMode;
    },

    isMissionRunning: function isMissionRunning() {
        return missionRunning;
    },

    isMissionStopped: function isMissionStopped() {
        return missionHasBeenStopped;
    },

    currentChapter: (function (_currentChapter) {
        function currentChapter() {
            return _currentChapter.apply(this, arguments);
        }

        currentChapter.toString = function () {
            return _currentChapter.toString();
        };

        return currentChapter;
    })(function () {
        return currentChapter;
    }),

    chapterTime: (function (_chapterTime) {
        function chapterTime() {
            return _chapterTime.apply(this, arguments);
        }

        chapterTime.toString = function () {
            return _chapterTime.toString();
        };

        return chapterTime;
    })(function () {
        return chapterTime;
    }),

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;

        switch (action) {
            case MISSION_STARTED_EVENT:
                return MissionStateStore.handleMissionStarted();

            case MISSION_STOPPED_EVENT:
                return MissionStateStore.handleMissionStopped();

            case RECEIVED_APP_STATE:
                var appState = payload.appState;
                missionRunning = appState.mission_running;
                currentChapter = appState.current_chapter;
                chapterTime = appState.elapsed_chapter_time;
                inSafeMode = appState.satellite_in_safe_mode;

                return MissionStateStore.emitChange();
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__MissionStateStore = MissionStateStore;
module.exports = MissionStateStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/oxygen-store.js":[function(require,module,exports){
'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var Dispatcher = require('../appdispatcher');
var MissionConstants = require('../constants/MissionConstants');
var AstConstants = require('../constants/AstroTeamConstants');
var BaseStore = require('./base-store');

var _status = AstConstants.GOOD_OXYGEN;
var consumptionPerMinute = null;
var remaining = 100;

var OxygenStore = module.exports = _Object$assign(new BaseStore(), {

    status: function status() {
        return _status;
    },

    statusAsColor: function statusAsColor() {
        switch (_status) {
            case AstConstants.CRITICAL_OXYGEN:
                return 'red';
            case AstConstants.WARN_OXYGEN:
                return 'orange';
            case AstConstants.GOOD_OXYGEN:
                return 'green';
        }
    },

    getState: function getState() {
        return {
            colorIndicator: this.statusAsColor(),
            consumptionPerMinute: consumptionPerMinute,
            remaining: remaining
        };
    },

    dispatcherIndex: Dispatcher.register(function (payload) {

        switch (payload.action) {
            case MissionConstants.RECEIVED_APP_STATE:
                var appState = payload.appState;

                if (appState.oxygen_consumption) {
                    consumptionPerMinute = appState.oxygen_consumption;

                    if (consumptionPerMinute > 1 && _status !== AstConstants.CRITICAL_OXYGEN) {
                        _status = AstConstants.WARN_OXYGEN;
                    } else if (consumptionPerMinute < 2) {
                        _status = AstConstants.GOOD_OXYGEN;
                    }

                    OxygenStore.emitChange();
                }

                if (appState.oxygen) {
                    remaining = appState.oxygen;
                    OxygenStore.emitChange();
                }
                break;
        }

        return true;
    })
});

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/AstroTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/AstroTeamConstants.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/radiation-store.js":[function(require,module,exports){
/* A singleton store that can be queried for remaining time */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');
var ScienceTeamConstants = require('../constants/ScienceTeamConstants');
var MissionConstants = require('../constants/MissionConstants');
var randomInt = require('../utils').randomInt;
var radiationRange = {
    min: 5,
    max: 20
};
var samples = [];
var totalRadiation = 0;
var lastCalculatedAverage = null;

var RadiationStore = _Object$assign(new BaseStore(), {

    _setRadiationLevel: function _setRadiationLevel(min, max) {
        radiationRange.min = min;
        radiationRange.max = max;
        this.emitChange();
    },

    _clearSamples: function _clearSamples() {
        samples = [];
        this.emitChange();
    },

    _takeSample: function _takeSample() {
        samples.push(this.getLevel());
        this.emitChange();
    },

    getLevel: function getLevel() {
        return randomInt(radiationRange.min, radiationRange.max);
    },

    getTotalLevel: function getTotalLevel() {
        return totalRadiation;
    },

    getSamples: function getSamples() {
        return samples.slice();
    },

    getState: function getState() {
        return {
            samples: samples.slice(0),
            total: totalRadiation,
            currentLevel: this.getLevel(),
            lastCalculatedAverage: lastCalculatedAverage
        };
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;
        var data = payload.data;

        switch (action) {
            case ScienceTeamConstants.SCIENCE_RADIATION_LEVEL_CHANGED:
                RadiationStore._setRadiationLevel(data.min, data.max);
                break;
            case ScienceTeamConstants.SCIENCE_TOTAL_RADIATION_LEVEL_CHANGED:
                totalRadiation = data.total;
                RadiationStore.emitChange();
                break;

            case ScienceTeamConstants.SCIENCE_TAKE_RADIATION_SAMPLE:
                RadiationStore._takeSample();
                break;
            case ScienceTeamConstants.SCIENCE_AVG_RADIATION_CALCULATED:
                lastCalculatedAverage = data.average;
                RadiationStore.emitChange();
                break;
            case ScienceTeamConstants.SCIENCE_CLEAR_RADIATION_SAMPLES:
                samples = [];
                RadiationStore.emitChange();
                break;

            case MissionConstants.RECEIVED_APP_STATE:
                var appState = payload.appState,
                    radiationLevel = appState.radiation_level;

                RadiationStore._setRadiationLevel(radiationLevel.low, radiationLevel.high);

                if (appState.science && appState.science.radiation) {
                    var radiationState = appState.science.radiation;
                    samples = radiationState.samples;
                    lastCalculatedAverage = radiationState.lastCalculatedAverage;
                    totalRadiation = radiationState.total;
                }

                RadiationStore.emitChange();
                break;

            case MissionConstants.MISSION_WAS_RESET:
                samples = [];
                lastCalculatedAverage = null;
                totalRadiation = 0;
                break;
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__RadiationStore = RadiationStore;
module.exports = RadiationStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","../constants/ScienceTeamConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/ScienceTeamConstants.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js":[function(require,module,exports){
/* A store that can be queried for the current path */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');

var _require = require('../constants/RouterConstants');

var ROUTE_CHANGED_EVENT = _require.ROUTE_CHANGED_EVENT;

var _require2 = require('../utils');

var cleanRootPath = _require2.cleanRootPath;

var router = require('../router-container');

var RouteStore = _Object$assign(new BaseStore(), {

    handleRouteChanged: function handleRouteChanged(state) {
        this.emitChange();
    },

    getTeamId: function getTeamId() {
        return router.getTeamId();
    },

    getTaskId: function getTaskId() {
        return router.getTaskId();
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;

        switch (action) {
            case ROUTE_CHANGED_EVENT:
                RouteStore.handleRouteChanged(payload.state);
                break;
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__RouteStore = RouteStore;
module.exports = RouteStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/RouterConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/RouterConstants.js","../router-container":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/router-container.js","../utils":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/task-store.js":[function(require,module,exports){
/* A store that can be queried for the current path */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');
var RouteStore = require('./route-store');
var MissionConstants = require('../constants/MissionConstants');

var awaitingNewInstructions = {
    text: 'Venter på nye instruksjoner ...'
};

var assignments = {
    science: {
        current: null,
        sample: {
            text: 'Start klokka og ta fire målinger jevnt fordelt utover de 30 sekundene',
            next: 'average'
        },
        average: {
            text: 'Regn ut gjennomsnittsverdien av strålingsverdiene dere fant. Skriv den inn i tekstfeltet.',
            next: 'addtotal'
        },
        addtotal: {
            text: 'Basert på fargen som ble indikert ved evaluering av gjennomsnittsverdien ' + 'skal vi nå legge til et tall til totalt funnet strålingsmengde.' + ' For grønn status man legge til 0, ' + ' for oransj status man legge til 15, ' + ' for rød status man legge til 50.' + ' Den totale strålingsverdien i kroppen skal helst ikke gå over 50, og aldri over 75!',
            next: 'awaiting'
        },
        awaiting: awaitingNewInstructions
    },

    astronaut: {
        current: null,
        awaiting: awaitingNewInstructions,
        breathing_timer: {
            text: 'Start klokka, og tell antall innpust (topper) på pustegrafen.',
            next: 'breathing_calculate',
            plain_info: true
        },
        breathing_calculate: {
            text: 'Hvor mange innpust blir det på ett minutt? Bruk tallet du finner til å regne ut oksygenforbruket pr minutt. Gjennomsnittlig oksygenforbruk med 25 innpust i minuttet er 1 oksygenenhet.',
            next: 'heartrate_timer'
        },
        heartrate_timer: {
            text: 'Start klokka og tell antall hjerteslag på ti sekunder',
            next: 'heartrate_calculate',
            plain_info: true
        },
        heartrate_calculate: {
            text: 'Finn nå ut hvor mange slag det blir i minuttet. Evaluer resultatet ved å skrive det inn i tekstfeltet.',
            next: 'awaiting'
        }
    },

    security: {
        current: null,
        awaiting: awaitingNewInstructions,

        scrubber: {
            text: 'NOT SURE ABOUT THIS ONE. I THINK IT WILL BE TRIGGERED WITHOUT ANY NEED FOR INSTRUCTIONS',
            next: 'awaiting'
        },

        signal_test: {
            text: 'Sjekk om dataoverføringer lar seg gjøre. Om det går bra kan dere teste om datakvaliteten er tilfredsstillende',
            next: 'awaiting'
        }
    },

    communication: {
        current: null,
        awaiting: awaitingNewInstructions,

        comm_check: {
            text: 'Sjekk status på kommunikasjonslinken. Om signalet er svakt bør en annen satelitt velges. ' + 'Om dere velger en annen satelitt må dere også velge en frekvens fra frekvensbåndet. ' + 'Det beste valget av frekvens er vanligvis midt i frekvensbåndet. '
        }

    }
};

var TaskStore = _Object$assign(new BaseStore(), {

    getCurrentTask: function getCurrentTask() {
        var teamId = RouteStore.getTeamId();
        var assignmentsForTeam = assignments[teamId];
        return assignmentsForTeam && assignmentsForTeam[this.getCurrentTaskId(teamId)] || 'Ingen oppgave funnet';
    },

    getCurrentTaskId: function getCurrentTaskId() {
        var teamId = arguments[0] === undefined ? RouteStore.getTeamId() : arguments[0];

        if (!teamId.length) {
            return null;
        }return assignments[teamId].current || 'awaiting';
    },

    getState: function getState() {
        return {
            currentTaskId: this.getCurrentTaskId(),
            currentTask: this.getCurrentTask().text,
            nextTaskId: this.getCurrentTask().next,
            plainInfo: this.getCurrentTask().plain_info
        };
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var taskId;
        var teamId;
        var currentTask;
        var teamTasks;

        switch (payload.action) {

            case MissionConstants.START_TASK:
                teamId = payload.teamId;
                taskId = payload.taskId;

                teamTasks = assignments[teamId];
                teamTasks.current = taskId;
                TaskStore.emitChange();
                break;

            case MissionConstants.COMPLETED_TASK:
                teamId = payload.teamId;
                taskId = payload.taskId;

                teamTasks = assignments[teamId];
                currentTask = teamTasks[taskId];
                teamTasks.current = currentTask.next;
                TaskStore.emitChange();
                break;

            case MissionConstants.RECEIVED_APP_STATE:
                teamId = RouteStore.getTeamId();

                var teamState = payload.appState[teamId];

                if (teamState && teamState.current_task) {
                    currentTask = teamState.current_task;
                    teamTasks = assignments[teamId];
                    teamTasks.current = currentTask;
                    TaskStore.emitChange();
                }

        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__TaskStore = TaskStore;
module.exports = TaskStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","./route-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/route-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/timer-store.js":[function(require,module,exports){
/* A singleton store that can be queried for remaining time */

'use strict';

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var check = require('check-types');
var AppDispatcher = require('../appdispatcher');
var BaseStore = require('./base-store');
var TimerConstants = require('../constants/TimerConstants');
var MissionConstants = require('../constants/MissionConstants');

// keeping state hidden in the module
var remainingTime = {},
    initialTime = {},
    intervalId = {},
    elapsedMissionTime = 0,
    missionTimer = null;

function reset(timerId) {
    stop(timerId);
    remainingTime[timerId] = initialTime[timerId];
}

function start(timerId) {
    assertExists(timerId);

    intervalId[timerId] = setInterval(function fn() {
        if (remainingTime[timerId] > 0) {
            remainingTime[timerId]--;
            TimerStore.emitChange();
        } else {
            stop(timerId);
        }
    }, 1000);
}

function stop(timerId) {
    assertExists(timerId);

    clearInterval(intervalId[timerId]);
    delete intervalId[timerId];
    TimerStore.emitChange();
}

function startMissionTimer() {
    stopMissionTimer();
    missionTimer = setInterval(function () {
        elapsedMissionTime++;
        TimerStore.emitChange();
    }, 1000);
}

function stopMissionTimer() {
    clearInterval(missionTimer);
}

/**
 * @param data.remainingTime {Number}
 * @param data.timerId {string}
 */
function handleRemainingTimeChanged(data) {
    var remaining = data.remainingTime;
    if (remaining <= 0) throw new TypeError('Got invalid remaining time :' + remaining);

    remainingTime[data.timerId] = remaining;
    initialTime[data.timerId] = remaining;
    TimerStore.emitChange();
}

function assertExists(timerId) {
    check.assert(timerId in remainingTime, 'No time set for timer with id ' + timerId);
}

var TimerStore = _Object$assign(new BaseStore(), {

    getRemainingTime: function getRemainingTime(timerId) {
        check.number(timerId);
        return remainingTime[timerId];
    },

    isRunning: function isRunning(timerId) {
        check.number(timerId);
        return !!intervalId[timerId];
    },

    /**
     * The timer is set (or has been reset), but not started
     * @param timerId
     * @returns true if ready, false if running or timed out
     */
    isReadyToStart: function isReadyToStart(timerId) {
        check.number(timerId);

        if (this.isRunning(timerId)) {
            return false;
        }return this.getRemainingTime(timerId) > 0;
    },

    getElapsedMissionTime: function getElapsedMissionTime() {
        return elapsedMissionTime;
    },

    dispatcherIndex: AppDispatcher.register(function (payload) {
        var action = payload.action;
        var data = payload.data;

        switch (action) {

            case TimerConstants.SET_TIMER:
                handleRemainingTimeChanged(data);
                break;

            case TimerConstants.START_TIMER:
                assertExists(data.timerId);

                // avoid setting up more than one timer
                if (!TimerStore.isRunning(data.timerId)) {
                    start(data.timerId);
                }
                break;

            case TimerConstants.STOP_TIMER:
                stop(data.timerId);
                break;

            case TimerConstants.RESET_TIMER:
                reset(data.timerId);
                break;

            case MissionConstants.MISSION_STARTED_EVENT:
                startMissionTimer();
                break;

            case MissionConstants.MISSION_STOPPED_EVENT:
                stopMissionTimer();
                break;

            case MissionConstants.RECEIVED_APP_STATE:
                var appState = payload.appState;

                elapsedMissionTime = appState.elapsed_mission_time;

                if (appState.mission_running) {
                    startMissionTimer();
                } else {
                    stopMissionTimer();
                }

                TimerStore.emitChange();
                break;

            case MissionConstants.MISSION_TIME_SYNC:
                elapsedMissionTime = data.elapsedMissionTime;
                TimerStore.emitChange();
                break;
        }

        return true; // No errors. Needed by promise in Dispatcher.
    })

});

window.__TimeStore = TimerStore;
module.exports = TimerStore;

},{"../appdispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/appdispatcher.js","../constants/MissionConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/MissionConstants.js","../constants/TimerConstants":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/constants/TimerConstants.js","./base-store":"/Users/carl-erik.kopseng/dev_priv/Emissions/app/stores/base-store.js","babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js","check-types":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/check-types/src/check-types.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/team-name-map.js":[function(require,module,exports){
'use strict';

var _Object$freeze = require('babel-runtime/core-js/object/freeze')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var teamMap = _Object$freeze({
    science: 'forskningsteam',
    communication: 'kommunikasjonsteam',
    security: 'sikkerhetsteam',
    astronaut: 'astronautteam'
});

function otherTeamNames(currentTeamId) {
    return _Object$keys(teamMap).filter(function (n) {
        return n !== currentTeamId && n !== 'leader';
    }).map(function (n) {
        return teamMap[n];
    }).join(', ');
}

module.exports = {
    nameMap: teamMap,
    otherTeamNames: otherTeamNames
};

},{"babel-runtime/core-js/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js","babel-runtime/core-js/object/keys":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/keys.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/app/utils.js":[function(require,module,exports){
'use strict';

function cleanRootPath(path) {
    // convert '/science/step1' => 'science'
    return path.replace(/\/?(\w+).*/, '$1');
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max + 1 - min)) + min;
}

/**
 * Standardize number parsing.
 * @param {string} str is a non-empty string
 * @returns {Number} - possibly NaN
 *
 * The standardization step of converting '1,23' -> '1.23' is strictly not needed when handling inputs from
 * input fields that have type='number', where this happens automatically.
 * The rest of the error handling is useful, none the less.
 */
function parseNumber(str) {
    if (! typeof str === 'string') {
        throw TypeError('This function expects strings. Got something else: ' + str);
    }

    // standardize the number format - removing Norwegian currency format
    var cleanedString = str.trim().replace(',', '.');

    if (!cleanedString.length) {
        throw TypeError('Got a blank string');
    }

    if (cleanedString.indexOf('.') !== -1) {
        return parseFloat(cleanedString, 10);
    } else {
        return parseInt(cleanedString, 10);
    }
}

// generates a UUID
// worlds smallest uuid lib. crazy shit :)
// @see https://gist.github.com/jed/982883
function b(a) {
    return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([10000000] + -1000 + -4000 + -8000 + -100000000000).replace(/[018]/g, b);
}

module.exports = {
    cleanRootPath: cleanRootPath, randomInt: randomInt, parseNumber: parseNumber, uuid: b
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js":[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/freeze.js":[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/freeze.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/keys.js":[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/class-call-check.js":[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/create-class.js":[function(require,module,exports){
"use strict";

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/extends.js":[function(require,module,exports){
"use strict";

var _Object$assign = require("babel-runtime/core-js/object/assign")["default"];

exports["default"] = _Object$assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/core-js/object/assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/helpers/inherits.js":[function(require,module,exports){
"use strict";

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/assign.js":[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/$').core.Object.assign;
},{"../../modules/$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js","../../modules/es6.object.assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/freeze.js":[function(require,module,exports){
require('../../modules/es6.object.statics-accept-primitives');
module.exports = require('../../modules/$').core.Object.freeze;
},{"../../modules/$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js","../../modules/es6.object.statics-accept-primitives":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.statics-accept-primitives.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/fn/object/keys.js":[function(require,module,exports){
require('../../modules/es6.object.statics-accept-primitives');
module.exports = require('../../modules/$').core.Object.keys;
},{"../../modules/$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js","../../modules/es6.object.statics-accept-primitives":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.statics-accept-primitives.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.assign.js":[function(require,module,exports){
var $ = require('./$');
// 19.1.2.1 Object.assign(target, source, ...)
/*eslint-disable no-unused-vars */
module.exports = Object.assign || function assign(target, source){
/*eslint-enable no-unused-vars */
  var T = Object($.assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = $.ES5Object(arguments[i++])
      , keys   = $.getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
};
},{"./$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.def.js":[function(require,module,exports){
var $          = require('./$')
  , global     = $.g
  , core       = $.core
  , isFunction = $.isFunction;
function ctx(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
}
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
function $def(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {}).prototype
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    if(isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & $def.B && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & $def.W && target[key] == out)!function(C){
      exp = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      exp.prototype = C.prototype;
    }(out);
    else exp = type & $def.P && isFunction(out) ? ctx(Function.call, out) : out;
    // export
    $.hide(exports, key, exp);
  }
}
module.exports = $def;
},{"./$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.fw.js":[function(require,module,exports){
module.exports = function($){
  $.FW   = false;
  $.path = $.core;
  return $;
};
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js":[function(require,module,exports){
'use strict';
var global = typeof self != 'undefined' ? self : Function('return this')()
  , core   = {}
  , defineProperty = Object.defineProperty
  , hasOwnProperty = {}.hasOwnProperty
  , ceil  = Math.ceil
  , floor = Math.floor
  , max   = Math.max
  , min   = Math.min;
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
  try {
    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
  } catch(e){ /* empty */ }
}();
var hide = createDefiner(1);
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
}
function desc(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return $.setDesc(object, key, desc(bitmap, value)); // eslint-disable-line no-use-before-define
  } : simpleSet;
}

function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
function assertDefined(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
}

var $ = module.exports = require('./$.fw')({
  g: global,
  core: core,
  html: global.document && document.documentElement,
  // http://jsperf.com/core-js-isobject
  isObject:   isObject,
  isFunction: isFunction,
  it: function(it){
    return it;
  },
  that: function(){
    return this;
  },
  // 7.1.4 ToInteger
  toInteger: toInteger,
  // 7.1.15 ToLength
  toLength: function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  },
  toIndex: function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  },
  has: function(it, key){
    return hasOwnProperty.call(it, key);
  },
  create:     Object.create,
  getProto:   Object.getPrototypeOf,
  DESC:       DESC,
  desc:       desc,
  getDesc:    Object.getOwnPropertyDescriptor,
  setDesc:    defineProperty,
  getKeys:    Object.keys,
  getNames:   Object.getOwnPropertyNames,
  getSymbols: Object.getOwnPropertySymbols,
  // Dummy, fix for not array-like ES3 string in es5 module
  assertDefined: assertDefined,
  ES5Object: Object,
  toObject: function(it){
    return $.ES5Object(assertDefined(it));
  },
  hide: hide,
  def: createDefiner(0),
  set: global.Symbol ? simpleSet : hide,
  mix: function(target, src){
    for(var key in src)hide(target, key, src[key]);
    return target;
  },
  each: [].forEach
});
if(typeof __e != 'undefined')__e = core;
if(typeof __g != 'undefined')__g = global;
},{"./$.fw":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.fw.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.assign.js":[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');
$def($def.S, 'Object', {assign: require('./$.assign')});
},{"./$.assign":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.assign.js","./$.def":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.def.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.statics-accept-primitives.js":[function(require,module,exports){
var $        = require('./$')
  , $def     = require('./$.def')
  , isObject = $.isObject
  , toObject = $.toObject;
function wrapObjectMethod(METHOD, MODE){
  var fn  = ($.core.Object || {})[METHOD] || Object[METHOD]
    , f   = 0
    , o   = {};
  o[METHOD] = MODE == 1 ? function(it){
    return isObject(it) ? fn(it) : it;
  } : MODE == 2 ? function(it){
    return isObject(it) ? fn(it) : true;
  } : MODE == 3 ? function(it){
    return isObject(it) ? fn(it) : false;
  } : MODE == 4 ? function getOwnPropertyDescriptor(it, key){
    return fn(toObject(it), key);
  } : MODE == 5 ? function getPrototypeOf(it){
    return fn(Object($.assertDefined(it)));
  } : function(it){
    return fn(toObject(it));
  };
  try {
    fn('z');
  } catch(e){
    f = 1;
  }
  $def($def.S + $def.F * f, 'Object', o);
}
wrapObjectMethod('freeze', 1);
wrapObjectMethod('seal', 1);
wrapObjectMethod('preventExtensions', 1);
wrapObjectMethod('isFrozen', 2);
wrapObjectMethod('isSealed', 2);
wrapObjectMethod('isExtensible', 3);
wrapObjectMethod('getOwnPropertyDescriptor', 4);
wrapObjectMethod('getPrototypeOf', 5);
wrapObjectMethod('keys');
wrapObjectMethod('getOwnPropertyNames');
},{"./$":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.js","./$.def":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/babel-runtime/node_modules/core-js/library/modules/$.def.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/browser-resolve/empty.js":[function(require,module,exports){

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding) {
  var self = this
  if (!(self instanceof Buffer)) return new Buffer(subject, encoding)

  var type = typeof subject
  var length

  if (type === 'number') {
    length = +subject
  } else if (type === 'string') {
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) {
    // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data)) subject = subject.data
    length = +subject.length
  } else {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (length > kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' +
      kMaxLength.toString(16) + ' bytes')
  }

  if (length < 0) length = 0
  else length >>>= 0 // coerce to uint32

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    self = Buffer._augment(new Uint8Array(length)) // eslint-disable-line consistent-this
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    self.length = length
    self._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    self._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++) {
        self[i] = subject.readUInt8(i)
      }
    } else {
      for (i = 0; i < length; i++) {
        self[i] = ((subject[i] % 256) + 256) % 256
      }
    }
  } else if (type === 'string') {
    self.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < length; i++) {
      self[i] = 0
    }
  }

  if (length > 0 && length <= Buffer.poolSize) self.parent = rootParent

  return self
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, totalLength) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function byteLength (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0

  if (length < 0 || offset < 0 || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, target_start, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (target_start >= target.length) target_start = target.length
  if (!target_start) target_start = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (target_start < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - target_start < end - start) {
    end = target.length - target_start + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/duplex.js":[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))

},{"./_stream_readable":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js","buffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js","isarray":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/isarray/index.js","stream":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js","string_decoder/":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/string_decoder/index.js","util":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))

},{"./_stream_duplex":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js","buffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js","core-util-is":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js","stream":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js":[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)

},{"buffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/passthrough.js":[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/readable.js":[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","stream":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/transform.js":[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/writable.js":[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/events/events.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js","readable-stream/duplex.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/duplex.js","readable-stream/passthrough.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/passthrough.js","readable-stream/readable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/readable.js","readable-stream/transform.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/transform.js","readable-stream/writable.js":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/readable-stream/writable.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/string_decoder/index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/buffer/index.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/support/isBufferBrowser.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js","inherits":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/check-types/src/check-types.js":[function(require,module,exports){
/**
 * This module exports functions for checking types
 * and throwing exceptions.
 */

/*globals define, module */

(function (globals) {
    'use strict';

    var messages, predicates, functions, assert, not, maybe, either;

    messages = {
        like: 'Invalid type',
        instance: 'Invalid type',
        emptyObject: 'Invalid object',
        object: 'Invalid object',
        assigned: 'Invalid value',
        undefined: 'Invalid value',
        null: 'Invalid value',
        hasLength: 'Invalid length',
        emptyArray: 'Invalid array',
        array: 'Invalid array',
        date: 'Invalid date',
        error: 'Invalid error',
        fn: 'Invalid function',
        match: 'Invalid string',
        contains: 'Invalid string',
        unemptyString: 'Invalid string',
        string: 'Invalid string',
        odd: 'Invalid number',
        even: 'Invalid number',
        between: 'Invalid number',
        greater: 'Invalid number',
        less: 'Invalid number',
        positive: 'Invalid number',
        negative: 'Invalid number',
        integer: 'Invalid number',
        zero: 'Invalid number',
        number: 'Invalid number',
        boolean: 'Invalid boolean'
    };

    predicates = {
        like: like,
        instance: instance,
        emptyObject: emptyObject,
        object: object,
        assigned: assigned,
        undefined: isUndefined,
        null: isNull,
        hasLength: hasLength,
        emptyArray: emptyArray,
        array: array,
        date: date,
        error: error,
        function: isFunction,
        match: match,
        contains: contains,
        unemptyString: unemptyString,
        string: string,
        odd: odd,
        even: even,
        between: between,
        greater: greater,
        less: less,
        positive: positive,
        negative: negative,
        integer : integer,
        zero: zero,
        number: number,
        boolean: boolean
    };

    functions = {
        apply: apply,
        map: map,
        all: all,
        any: any
    };

    functions = mixin(functions, predicates);
    assert = createModifiedPredicates(assertModifier, assertImpl);
    not = createModifiedPredicates(notModifier, notImpl);
    maybe = createModifiedPredicates(maybeModifier, maybeImpl);
    either = createModifiedPredicates(eitherModifier);
    assert.not = createModifiedFunctions(assertModifier, not);
    assert.maybe = createModifiedFunctions(assertModifier, maybe);
    assert.either = createModifiedFunctions(assertEitherModifier, predicates);

    exportFunctions(mixin(functions, {
        assert: assert,
        not: not,
        maybe: maybe,
        either: either
    }));

    /**
     * Public function `like`.
     *
     * Tests whether an object 'quacks like a duck'.
     * Returns `true` if the first argument has all of
     * the properties of the second, archetypal argument
     * (the 'duck'). Returns `false` otherwise.
     *
     */
    function like (data, duck) {
        var name;

        for (name in duck) {
            if (duck.hasOwnProperty(name)) {
                if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof duck[name]) {
                    return false;
                }

                if (object(data[name]) && like(data[name], duck[name]) === false) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Public function `instance`.
     *
     * Returns `true` if an object is an instance of a prototype,
     * `false` otherwise.
     *
     */
    function instance (data, prototype) {
        if (data && isFunction(prototype) && data instanceof prototype) {
            return true;
        }

        return false;
    }

    /**
     * Public function `emptyObject`.
     *
     * Returns `true` if something is an empty object,
     * `false` otherwise.
     *
     */
    function emptyObject (data) {
        return object(data) && Object.keys(data).length === 0;
    }

    /**
     * Public function `object`.
     *
     * Returns `true` if something is a plain-old JS object,
     * `false` otherwise.
     *
     */
    function object (data) {
        return Object.prototype.toString.call(data) === '[object Object]';
    }

    /**
     * Public function `assigned`.
     *
     * Returns `true` if something is not null or undefined,
     * `false` otherwise.
     *
     */
    function assigned (data) {
        return !isUndefined(data) && !isNull(data);
    }

    /**
     * Public function `undefined`.
     *
     * Returns `true` if something is undefined,
     * `false` otherwise.
     *
     */
    function isUndefined (data) {
        return data === undefined;
    }

    /**
     * Public function `null`.
     *
     * Returns `true` if something is null,
     * `false` otherwise.
     *
     */
    function isNull (data) {
        return data === null;
    }

    /**
     * Public function `hasLength`.
     *
     * Returns `true` if something is has a length property
     * that equals `value`, `false` otherwise.
     *
     */
    function hasLength (data, value) {
        return assigned(data) && data.length === value;
    }

    /**
     * Public function `emptyArray`.
     *
     * Returns `true` if something is an empty array,
     * `false` otherwise.
     *
     */
    function emptyArray (data) {
        return array(data) && data.length === 0;
    }

    /**
     * Public function `array`.
     *
     * Returns `true` something is an array,
     * `false` otherwise.
     *
     */
    function array (data) {
        return Array.isArray(data);
    }

    /**
     * Public function `date`.
     *
     * Returns `true` something is a valid date,
     * `false` otherwise.
     *
     */
    function date (data) {
        return Object.prototype.toString.call(data) === '[object Date]' &&
            !isNaN(data.getTime());
    }

    /**
     * Public function `error`.
     *
     * Returns `true` if something is a plain-old JS object,
     * `false` otherwise.
     *
     */
    function error (data) {
        return Object.prototype.toString.call(data) === '[object Error]';
    }

    /**
     * Public function `function`.
     *
     * Returns `true` if something is function,
     * `false` otherwise.
     *
     */
    function isFunction (data) {
        return typeof data === 'function';
    }

    /**
     * Public function `match`.
     *
     * Returns `true` if something is a string
     * that matches `regex`, `false` otherwise.
     *
     */
    function match (data, regex) {
        return string(data) && !!data.match(regex);
    }

    /**
     * Public function `contains`.
     *
     * Returns `true` if something is a string
     * that contains `substring`, `false` otherwise.
     *
     */
    function contains (data, substring) {
        return string(data) && data.indexOf(substring) !== -1;
    }

    /**
     * Public function `unemptyString`.
     *
     * Returns `true` if something is a non-empty string,
     * `false` otherwise.
     *
     */
    function unemptyString (data) {
        return string(data) && data !== '';
    }

    /**
     * Public function `string`.
     *
     * Returns `true` if something is a string, `false` otherwise.
     *
     */
    function string (data) {
        return typeof data === 'string';
    }

    /**
     * Public function `odd`.
     *
     * Returns `true` if something is an odd number,
     * `false` otherwise.
     *
     */
    function odd (data) {
        return integer(data) && !even(data);
    }

    /**
     * Public function `even`.
     *
     * Returns `true` if something is an even number,
     * `false` otherwise.
     *
     */
    function even (data) {
        return number(data) && data % 2 === 0;
    }

    /**
     * Public function `integer`.
     *
     * Returns `true` if something is an integer,
     * `false` otherwise.
     *
     */
    function integer (data) {
        return number(data) && data % 1 === 0;
    }

    /**
     * Public function `between`.
     *
     * Returns `true` if something is a number
     * between `a` and `b`, `false` otherwise.
     *
     */
    function between (data, a, b) {
        if (a < b) {
            return greater(data, a) && less(data, b);
        }

        return less(data, a) && greater(data, b);
    }

    /**
     * Public function `greater`.
     *
     * Returns `true` if something is a number
     * greater than `value`, `false` otherwise.
     *
     */
    function greater (data, value) {
        return number(data) && data > value;
    }

    /**
     * Public function `less`.
     *
     * Returns `true` if something is a number
     * less than `value`, `false` otherwise.
     *
     */
    function less (data, value) {
        return number(data) && data < value;
    }

    /**
     * Public function `positive`.
     *
     * Returns `true` if something is a positive number,
     * `false` otherwise.
     *
     */
    function positive (data) {
        return greater(data, 0);
    }

    /**
     * Public function `negative`.
     *
     * Returns `true` if something is a negative number,
     * `false` otherwise.
     *
     * @param data          The thing to test.
     */
    function negative (data) {
        return less(data, 0);
    }

    /**
     * Public function `number`.
     *
     * Returns `true` if data is a number,
     * `false` otherwise.
     *
     */
    function number (data) {
        return typeof data === 'number' && isNaN(data) === false &&
               data !== Number.POSITIVE_INFINITY &&
               data !== Number.NEGATIVE_INFINITY;
    }

    /**
     * Public function `zero`.
     *
     * Returns `true` if something is zero,
     * `false` otherwise.
     *
     * @param data          The thing to test.
     */
    function zero (data) {
        return data === 0;
    }

    /**
     * Public function `boolean`.
     *
     * Returns `true` if data is a boolean value,
     * `false` otherwise.
     *
     */
    function boolean (data) {
        return data === false || data === true;
    }

    /**
     * Public function `apply`.
     *
     * Maps each value from the data to the corresponding predicate and returns
     * the result array. If the same function is to be applied across all of the
     * data, a single predicate function may be passed in.
     *
     */
    function apply (data, predicates) {
        assert.array(data);

        if (isFunction(predicates)) {
            return data.map(function (value) {
                return predicates(value);
            });
        }

        assert.array(predicates);
        assert.hasLength(data, predicates.length);

        return data.map(function (value, index) {
            return predicates[index](value);
        });
    }

    /**
     * Public function `map`.
     *
     * Maps each value from the data to the corresponding predicate and returns
     * the result object. Supports nested objects. If the data is not nested and
     * the same function is to be applied across all of it, a single predicate
     * function may be passed in.
     *
     */
    function map (data, predicates) {
        assert.object(data);

        if (isFunction(predicates)) {
            return mapSimple(data, predicates);
        }

        assert.object(predicates);

        return mapComplex(data, predicates);
    }

    function mapSimple (data, predicate) {
        var result = {};

        Object.keys(data).forEach(function (key) {
            result[key] = predicate(data[key]);
        });

        return result;
    }

    function mapComplex (data, predicates) {
        var result = {};

        Object.keys(predicates).forEach(function (key) {
            var predicate = predicates[key];

            if (isFunction(predicate)) {
                result[key] = predicate(data[key]);
            } else if (object(predicate)) {
                result[key] = mapComplex(data[key], predicate);
            }
        });

        return result;
    }

    /**
     * Public function `all`
     *
     * Check that all boolean values are true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */
    function all (data) {
        if (array(data)) {
            return testArray(data, false);
        }

        assert.object(data);

        return testObject(data, false);
    }

    function testArray (data, result) {
        var i;

        for (i = 0; i < data.length; i += 1) {
            if (data[i] === result) {
                return result;
            }
        }

        return !result;
    }

    function testObject (data, result) {
        var key, value;

        for (key in data) {
            if (data.hasOwnProperty(key)) {
                value = data[key];

                if (object(value) && testObject(value, result) === result) {
                    return result;
                }

                if (value === result) {
                    return result;
                }
            }
        }

        return !result;
    }

    /**
     * Public function `any`
     *
     * Check that at least one boolean value is true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */
    function any (data) {
        if (array(data)) {
            return testArray(data, true);
        }

        assert.object(data);

        return testObject(data, true);
    }

    function mixin (target, source) {
        Object.keys(source).forEach(function (key) {
            target[key] = source[key];
        });

        return target;
    }

    /**
     * Public modifier `assert`.
     *
     * Throws if `predicate` returns `false`.
     */
    function assertModifier (predicate, defaultMessage) {
        return function () {
            assertPredicate(predicate, arguments, defaultMessage);
        };
    }

    function assertPredicate (predicate, args, defaultMessage) {
        var message = args[args.length - 1];
        assertImpl(predicate.apply(null, args), unemptyString(message) ? message : defaultMessage);
    }

    function assertImpl (value, message) {
        if (value === false) {
            throw new Error(message || 'Assertion failed');
        }
    }

    function assertEitherModifier (predicate, defaultMessage) {
        return function () {
            var error;

            try {
                assertPredicate(predicate, arguments, defaultMessage);
            } catch (e) {
                error = e;
            }

            return {
                or: Object.keys(predicates).reduce(delayedAssert, {})
            };

            function delayedAssert (result, key) {
                result[key] = function () {
                    if (error && !predicates[key].apply(null, arguments)) {
                        throw error;
                    }
                };

                return result;
            }
        };
    }

    /**
     * Public modifier `not`.
     *
     * Negates `predicate`.
     */
    function notModifier (predicate) {
        return function () {
            return notImpl(predicate.apply(null, arguments));
        };
    }

    function notImpl (value) {
        return !value;
    }

    /**
     * Public modifier `maybe`.
     *
     * Returns `true` if predicate argument is  `null` or `undefined`,
     * otherwise propagates the return value from `predicate`.
     */
    function maybeModifier (predicate) {
        return function () {
            if (!assigned(arguments[0])) {
                return true;
            }

            return predicate.apply(null, arguments);
        };
    }

    function maybeImpl (value) {
        if (assigned(value) === false) {
            return true;
        }

        return value;
    }

    /**
     * Public modifier `either`.
     *
     * Returns `true` if either predicate is true.
     */
    function eitherModifier (predicate) {
        return function () {
            var shortcut = predicate.apply(null, arguments);

            return {
                or: Object.keys(predicates).reduce(nopOrPredicate, {})
            };

            function nopOrPredicate (result, key) {
                result[key] = shortcut ? nop : predicates[key];
                return result;
            }
        };

        function nop () {
            return true;
        }
    }

    function createModifiedPredicates (modifier, object) {
        return createModifiedFunctions(modifier, predicates, object);
    }

    function createModifiedFunctions (modifier, functions, object) {
        var result = object || {};

        Object.keys(functions).forEach(function (key) {
            Object.defineProperty(result, key, {
                configurable: false,
                enumerable: true,
                writable: false,
                value: modifier(functions[key], messages[key])
            });
        });

        return result;
    }

    function exportFunctions (functions) {
        if (typeof define === 'function' && define.amd) {
            define(function () {
                return functions;
            });
        } else if (typeof module !== 'undefined' && module !== null && module.exports) {
            module.exports = functions;
        } else {
            globals.check = functions;
        }
    }
}(this));

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/index.js":[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher')

},{"./lib/Dispatcher":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/lib/Dispatcher.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/lib/Dispatcher.js":[function(require,module,exports){
/*
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * @typechecks
 */

"use strict";

var invariant = require('./invariant');

var _lastID = 1;
var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *    CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *
 *         case 'city-update':
 *           FlightPriceStore.price =
 *             FlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

  function Dispatcher() {
    this.$Dispatcher_callbacks = {};
    this.$Dispatcher_isPending = {};
    this.$Dispatcher_isHandled = {};
    this.$Dispatcher_isDispatching = false;
    this.$Dispatcher_pendingPayload = null;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   *
   * @param {function} callback
   * @return {string}
   */
  Dispatcher.prototype.register=function(callback) {
    var id = _prefix + _lastID++;
    this.$Dispatcher_callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   *
   * @param {string} id
   */
  Dispatcher.prototype.unregister=function(id) {
    invariant(
      this.$Dispatcher_callbacks[id],
      'Dispatcher.unregister(...): `%s` does not map to a registered callback.',
      id
    );
    delete this.$Dispatcher_callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   *
   * @param {array<string>} ids
   */
  Dispatcher.prototype.waitFor=function(ids) {
    invariant(
      this.$Dispatcher_isDispatching,
      'Dispatcher.waitFor(...): Must be invoked while dispatching.'
    );
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this.$Dispatcher_isPending[id]) {
        invariant(
          this.$Dispatcher_isHandled[id],
          'Dispatcher.waitFor(...): Circular dependency detected while ' +
          'waiting for `%s`.',
          id
        );
        continue;
      }
      invariant(
        this.$Dispatcher_callbacks[id],
        'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',
        id
      );
      this.$Dispatcher_invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   *
   * @param {object} payload
   */
  Dispatcher.prototype.dispatch=function(payload) {
    invariant(
      !this.$Dispatcher_isDispatching,
      'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'
    );
    this.$Dispatcher_startDispatching(payload);
    try {
      for (var id in this.$Dispatcher_callbacks) {
        if (this.$Dispatcher_isPending[id]) {
          continue;
        }
        this.$Dispatcher_invokeCallback(id);
      }
    } finally {
      this.$Dispatcher_stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   *
   * @return {boolean}
   */
  Dispatcher.prototype.isDispatching=function() {
    return this.$Dispatcher_isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @param {string} id
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_invokeCallback=function(id) {
    this.$Dispatcher_isPending[id] = true;
    this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);
    this.$Dispatcher_isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @param {object} payload
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_startDispatching=function(payload) {
    for (var id in this.$Dispatcher_callbacks) {
      this.$Dispatcher_isPending[id] = false;
      this.$Dispatcher_isHandled[id] = false;
    }
    this.$Dispatcher_pendingPayload = payload;
    this.$Dispatcher_isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_stopDispatching=function() {
    this.$Dispatcher_pendingPayload = null;
    this.$Dispatcher_isDispatching = false;
  };


module.exports = Dispatcher;

},{"./invariant":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/lib/invariant.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/flux/lib/invariant.js":[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/global/document.js":[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/global/window.js":[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/printf/lib/printf.js":[function(require,module,exports){

var util = require('util');

var tokenize = function(/*String*/ str, /*RegExp*/ re, /*Function?*/ parseDelim, /*Object?*/ instance){
  // summary:
  //    Split a string by a regular expression with the ability to capture the delimeters
  // parseDelim:
  //    Each group (excluding the 0 group) is passed as a parameter. If the function returns
  //    a value, it's added to the list of tokens.
  // instance:
  //    Used as the "this' instance when calling parseDelim
  var tokens = [];
  var match, content, lastIndex = 0;
  while(match = re.exec(str)){
    content = str.slice(lastIndex, re.lastIndex - match[0].length);
    if(content.length){
      tokens.push(content);
    }
    if(parseDelim){
      var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
      if(typeof parsed != 'undefined'){
        if(parsed.specifier === '%'){
          tokens.push('%');
        }else{
          tokens.push(parsed);
        }
      }
    }
    lastIndex = re.lastIndex;
  }
  content = str.slice(lastIndex);
  if(content.length){
    tokens.push(content);
  }
  return tokens;
}

var Formatter = function(/*String*/ format){
  var tokens = [];
  this._mapped = false;
  this._format = format;
  this._tokens = tokenize(format, this._re, this._parseDelim, this);
}

Formatter.prototype._re = /\%(?:\(([\w_]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier){
  if(mapping){
    this._mapped = true;
  }
  return {
    mapping: mapping,
    intmapping: intmapping,
    flags: flags,
    _minWidth: minWidth, // May be dependent on parameters
    period: period,
    _precision: precision, // May be dependent on parameters
    specifier: specifier
  };
};
Formatter.prototype._specifiers = {
  b: {
    base: 2,
    isInt: true
  },
  o: {
    base: 8,
    isInt: true
  },
  x: {
    base: 16,
    isInt: true
  },
  X: {
    extend: ['x'],
    toUpper: true
  },
  d: {
    base: 10,
    isInt: true
  },
  i: {
    extend: ['d']
  },
  u: {
    extend: ['d'],
    isUnsigned: true
  },
  c: {
    setArg: function(token){
      if(!isNaN(token.arg)){
        var num = parseInt(token.arg);
        if(num < 0 || num > 127){
          throw new Error('invalid character code passed to %c in printf');
        }
        token.arg = isNaN(num) ? '' + num : String.fromCharCode(num);
      }
    }
  },
  s: {
    setMaxWidth: function(token){
      token.maxWidth = (token.period == '.') ? token.precision : -1;
    }
  },
  e: {
    isDouble: true,
    doubleNotation: 'e'
  },
  E: {
    extend: ['e'],
    toUpper: true
  },
  f: {
    isDouble: true,
    doubleNotation: 'f'
  },
  F: {
    extend: ['f']
  },
  g: {
    isDouble: true,
    doubleNotation: 'g'
  },
  G: {
    extend: ['g'],
    toUpper: true
  },
  O: {
    isObject: true
  },
};
Formatter.prototype.format = function(/*mixed...*/ filler){
  if(this._mapped && typeof filler != 'object'){
    throw new Error('format requires a mapping');
  }

  var str = '';
  var position = 0;
  for(var i = 0, token; i < this._tokens.length; i++){
    token = this._tokens[i];
    
    if(typeof token == 'string'){
      str += token;
    }else{
      if(this._mapped){
        if(typeof filler[token.mapping] == 'undefined'){
          throw new Error('missing key ' + token.mapping);
        }
        token.arg = filler[token.mapping];
      }else{
        if(token.intmapping){
          position = parseInt(token.intmapping) - 1;
        }
        if(position >= arguments.length){
          throw new Error('got ' + arguments.length + ' printf arguments, insufficient for \'' + this._format + '\'');
        }
        token.arg = arguments[position++];
      }

      if(!token.compiled){
        token.compiled = true;
        token.sign = '';
        token.zeroPad = false;
        token.rightJustify = false;
        token.alternative = false;

        var flags = {};
        for(var fi = token.flags.length; fi--;){
          var flag = token.flags.charAt(fi);
          flags[flag] = true;
          switch(flag){
            case ' ':
              token.sign = ' ';
              break;
            case '+':
              token.sign = '+';
              break;
            case '0':
              token.zeroPad = (flags['-']) ? false : true;
              break;
            case '-':
              token.rightJustify = true;
              token.zeroPad = false;
              break;
            case '#':
              token.alternative = true;
              break;
            default:
              throw Error('bad formatting flag \'' + token.flags.charAt(fi) + '\'');
          }
        }

        token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;
        token.maxWidth = -1;
        token.toUpper = false;
        token.isUnsigned = false;
        token.isInt = false;
        token.isDouble = false;
        token.isObject = false;
        token.precision = 1;
        if(token.period == '.'){
          if(token._precision){
            token.precision = parseInt(token._precision);
          }else{
            token.precision = 0;
          }
        }

        var mixins = this._specifiers[token.specifier];
        if(typeof mixins == 'undefined'){
          throw new Error('unexpected specifier \'' + token.specifier + '\'');
        }
        if(mixins.extend){
          var s = this._specifiers[mixins.extend];
          for(var k in s){
            mixins[k] = s[k]
          }
          delete mixins.extend;
        }
        for(var l in mixins){
          token[l] = mixins[l];
        }
      }

      if(typeof token.setArg == 'function'){
        token.setArg(token);
      }

      if(typeof token.setMaxWidth == 'function'){
        token.setMaxWidth(token);
      }

      if(token._minWidth == '*'){
        if(this._mapped){
          throw new Error('* width not supported in mapped formats');
        }
        token.minWidth = parseInt(arguments[position++]);
        if(isNaN(token.minWidth)){
          throw new Error('the argument for * width at position ' + position + ' is not a number in ' + this._format);
        }
        // negative width means rightJustify
        if (token.minWidth < 0) {
          token.rightJustify = true;
          token.minWidth = -token.minWidth;
        }
      }

      if(token._precision == '*' && token.period == '.'){
        if(this._mapped){
          throw new Error('* precision not supported in mapped formats');
        }
        token.precision = parseInt(arguments[position++]);
        if(isNaN(token.precision)){
          throw Error('the argument for * precision at position ' + position + ' is not a number in ' + this._format);
        }
        // negative precision means unspecified
        if (token.precision < 0) {
          token.precision = 1;
          token.period = '';
        }
      }
      if(token.isInt){
        // a specified precision means no zero padding
        if(token.period == '.'){
          token.zeroPad = false;
        }
        this.formatInt(token);
      }else if(token.isDouble){
        if(token.period != '.'){
          token.precision = 6;
        }
        this.formatDouble(token); 
      }else if(token.isObject){
        this.formatObject(token);
      }
      this.fitField(token);

      str += '' + token.arg;
    }
  }

  return str;
};
Formatter.prototype._zeros10 = '0000000000';
Formatter.prototype._spaces10 = '          ';
Formatter.prototype.formatInt = function(token) {
  var i = parseInt(token.arg);
  if(!isFinite(i)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not an integer; parseInt returned ' + i);
    }
    //return '' + i;
    i = 0;
  }

  // if not base 10, make negatives be positive
  // otherwise, (-10).toString(16) is '-a' instead of 'fffffff6'
  if(i < 0 && (token.isUnsigned || token.base != 10)){
    i = 0xffffffff + i + 1;
  } 

  if(i < 0){
    token.arg = (- i).toString(token.base);
    this.zeroPad(token);
    token.arg = '-' + token.arg;
  }else{
    token.arg = i.toString(token.base);
    // need to make sure that argument 0 with precision==0 is formatted as ''
    if(!i && !token.precision){
      token.arg = '';
    }else{
      this.zeroPad(token);
    }
    if(token.sign){
      token.arg = token.sign + token.arg;
    }
  }
  if(token.base == 16){
    if(token.alternative){
      token.arg = '0x' + token.arg;
    }
    token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
  }
  if(token.base == 8){
    if(token.alternative && token.arg.charAt(0) != '0'){
      token.arg = '0' + token.arg;
    }
  }
};
Formatter.prototype.formatDouble = function(token) {
  var f = parseFloat(token.arg);
  if(!isFinite(f)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not a float; parseFloat returned ' + f);
    }
    // C99 says that for 'f':
    //   infinity -> '[-]inf' or '[-]infinity' ('[-]INF' or '[-]INFINITY' for 'F')
    //   NaN -> a string  starting with 'nan' ('NAN' for 'F')
    // this is not commonly implemented though.
    //return '' + f;
    f = 0;
  }

  switch(token.doubleNotation) {
    case 'e': {
      token.arg = f.toExponential(token.precision); 
      break;
    }
    case 'f': {
      token.arg = f.toFixed(token.precision); 
      break;
    }
    case 'g': {
      // C says use 'e' notation if exponent is < -4 or is >= prec
      // ECMAScript for toPrecision says use exponential notation if exponent is >= prec,
      // though step 17 of toPrecision indicates a test for < -6 to force exponential.
      if(Math.abs(f) < 0.0001){
        //print('forcing exponential notation for f=' + f);
        token.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);
      }else{
        token.arg = f.toPrecision(token.precision); 
      }

      // In C, unlike 'f', 'gG' removes trailing 0s from fractional part, unless alternative format flag ('#').
      // But ECMAScript formats toPrecision as 0.00100000. So remove trailing 0s.
      if(!token.alternative){ 
        //print('replacing trailing 0 in \'' + s + '\'');
        token.arg = token.arg.replace(/(\..*[^0])0*e/, '$1e');
        // if fractional part is entirely 0, remove it and decimal point
        token.arg = token.arg.replace(/\.0*e/, 'e').replace(/\.0$/,'');
      }
      break;
    }
    default: throw new Error('unexpected double notation \'' + token.doubleNotation + '\'');
  }

  // C says that exponent must have at least two digits.
  // But ECMAScript does not; toExponential results in things like '1.000000e-8' and '1.000000e+8'.
  // Note that s.replace(/e([\+\-])(\d)/, 'e$10$2') won't work because of the '$10' instead of '$1'.
  // And replace(re, func) isn't supported on IE50 or Safari1.
  token.arg = token.arg.replace(/e\+(\d)$/, 'e+0$1').replace(/e\-(\d)$/, 'e-0$1');

  // if alt, ensure a decimal point
  if(token.alternative){
    token.arg = token.arg.replace(/^(\d+)$/,'$1.');
    token.arg = token.arg.replace(/^(\d+)e/,'$1.e');
  }

  if(f >= 0 && token.sign){
    token.arg = token.sign + token.arg;
  }

  token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
};
Formatter.prototype.formatObject = function(token) {
  // If no precision is specified, then reset it to null (infinite depth).
  var precision = (token.period === '.') ? token.precision : null;
  token.arg = util.inspect(token.arg, !token.alternative, precision);
};
Formatter.prototype.zeroPad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.precision;
  var negative = false;
  if(typeof token.arg != "string"){
    token.arg = "" + token.arg;
  }
  if (token.arg.substr(0,1) === '-') {
    negative = true;
    token.arg = token.arg.substr(1);
  }

  var tenless = length - 10;
  while(token.arg.length < tenless){
    token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
  if (negative) token.arg = '-' + token.arg;
};
Formatter.prototype.fitField = function(token) {
  if(token.maxWidth >= 0 && token.arg.length > token.maxWidth){
    return token.arg.substring(0, token.maxWidth);
  }
  if(token.zeroPad){
    this.zeroPad(token, token.minWidth);
    return;
  }
  this.spacePad(token);
};
Formatter.prototype.spacePad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.minWidth;
  if(typeof token.arg != 'string'){
    token.arg = '' + token.arg;
  }
  var tenless = length - 10;
  while(token.arg.length < tenless){
    token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;
};


module.exports = function(){
  var args = Array.prototype.slice.call(arguments),
    stream, format;
  if(args[0] instanceof require('stream').Stream){
    stream = args.shift();
  }
  format = args.shift();
  var formatter = new Formatter(format);
  var string = formatter.format.apply(formatter, args);
  if(stream){
    stream.write(string);
  }else{
    return string;
  }
};

module.exports.Formatter = Formatter;


},{"stream":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/stream-browserify/index.js","util":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/util/util.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/invariant.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))

},{"_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/keyMirror.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

'use strict';

var invariant = require("./invariant");

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  ("production" !== process.env.NODE_ENV ? invariant(
    obj instanceof Object && !Array.isArray(obj),
    'keyMirror(...): Argument must be an object.'
  ) : invariant(obj instanceof Object && !Array.isArray(obj)));
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

}).call(this,require('_process'))

},{"./invariant":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/invariant.js","_process":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/browserify/node_modules/process/browser.js"}],"/Users/carl-erik.kopseng/dev_priv/Emissions/server/EventConstants.js":[function(require,module,exports){
'use strict';

var keyMirror = require('react/lib/keyMirror');

module.exports = keyMirror({
    MISSION_STARTED: null,
    MISSION_STOPPED: null,
    MISSION_RESET: null,
    MISSION_COMPLETED: null,
    APP_STATE: null,

    ADD_MESSAGE: null,

    //ACTIONS
    GET_EVENTS: null,
    SET_EVENTS: null,
    TRIGGER_EVENT: null,
    ADVANCE_CHAPTER: null,
    COMPLETE_MISSION: null,

    // SCIENCE TEAM EVENTS
    SCIENCE_CHECK_RADIATION: null,

    // ASTRONAUT TEAM EVENTS
    AST_CHECK_VITALS: null,

    // COMMUNICATION TEAM EVENTS
    COMM_INFORM_ASTRONAUT: null,
    COMM_CHECK_SAT_LINK: null,

    // SECURITY TEAM EVENTS
    SET_HIGH_C02: null,
    SECURITY_CHECK_DATA_TRANSFER: null,

    SET_HEART_RATE_HIGH: null,
    SET_HEART_RATE_MEDIUM: null,
    SET_HEART_RATE_LOW: null
});

},{"react/lib/keyMirror":"/Users/carl-erik.kopseng/dev_priv/Emissions/node_modules/react/lib/keyMirror.js"}]},{},["./app/main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9tYWluLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvYWN0aW9ucy9Bc3Ryb1RlYW1BY3Rpb25DcmVhdG9ycy5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2FjdGlvbnMvTWVzc2FnZUFjdGlvbkNyZWF0b3JzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9hY3Rpb25zL1NjaWVuY2VBY3Rpb25DcmVhdG9ycy5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2FjdGlvbnMvU2VjdXJpdHlUZWFtQWN0aW9uQ3JlYXRvcnMuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9hY3Rpb25zL1RpbWVyQWN0aW9uQ3JlYXRvcnMuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9hcHBkaXNwYXRjaGVyLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY2xpZW50LWFwaS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NsaWVudC1ib290c3RyYXAuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2FwcC5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvYXN0cm9uYXV0LXRhc2sucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2JyZWF0aC1yYXRlLWNoYXJ0LnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9jb21tdW5pY2F0aW9uLXRhc2sucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2RpYWxvZ3MucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2R1bW15LXJlbmRlci5taXhpbi5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvZnVsbC1zY3JlZW4tdmlkZW8uanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL2hlYWRlci5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvaGVhcnQtcmF0ZS1jaGFydC5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvaW5kZXgtYXBwLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9pbnRyb2R1Y3Rpb24tc2NyZWVuLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9tZXNzYWdlLWxpc3QucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL21pc3Npb24tY29tbWFuZGVyLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9taXNzaW9uLXRpbWVyLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9ub3QtZm91bmQucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL292ZXJsYXkucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL3JhZGlhdGlvbi1jaGFydC5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvcmFkaWF0aW9uLXNhbXBsZXIucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL3JhZGlhdGlvbi10YWJsZS5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvc2NpZW5jZS10YXNrLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy9zZWN1cml0eS10YXNrLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy90YXNrLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29tcG9uZW50cy90ZWFtLWRpc3BsYXllci5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbXBvbmVudHMvdGltZXItcGFuZWwucmVhY3QuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb21wb25lbnRzL3RpbWVyLnJlYWN0LmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29uc3RhbnRzL0FzdHJvVGVhbUNvbnN0YW50cy5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL2NvbnN0YW50cy9NZXNzYWdlQ29uc3RhbnRzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29uc3RhbnRzL01pc3Npb25Db25zdGFudHMuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9jb25zdGFudHMvUm91dGVyQ29uc3RhbnRzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29uc3RhbnRzL1NjaWVuY2VUZWFtQ29uc3RhbnRzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvY29uc3RhbnRzL1RpbWVyQ29uc3RhbnRzLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvcm91dGVyLWNvbnRhaW5lci5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3JvdXRlcy5yZWFjdC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9iYXNlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL2JyZWF0aC1yYXRlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL2NhcmJvbi1kaW94aWRlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL2NvbW11bmljYXRpb24tcXVhbGl0eS1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9ldmVudC1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9oZWFydC1yYXRlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL2ludHJvZHVjdGlvbi1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9tZXNzYWdlLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL21pc3Npb24tc3RhdGUtc3RvcmUuanMiLCIvVXNlcnMvY2FybC1lcmlrLmtvcHNlbmcvZGV2X3ByaXYvRW1pc3Npb25zL2FwcC9zdG9yZXMvb3h5Z2VuLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL3JhZGlhdGlvbi1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy9yb3V0ZS1zdG9yZS5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3N0b3Jlcy90YXNrLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvc3RvcmVzL3RpbWVyLXN0b3JlLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9hcHAvdGVhbS1uYW1lLW1hcC5qcyIsIi9Vc2Vycy9jYXJsLWVyaWsua29wc2VuZy9kZXZfcHJpdi9FbWlzc2lvbnMvYXBwL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3MtY2FsbC1jaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlLWNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2ZyZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZWYuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mdy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc3RhdGljcy1hY2NlcHQtcHJpbWl0aXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY2hlY2stdHlwZXMvc3JjL2NoZWNrLXR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmx1eC9saWIvRGlzcGF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9pbnZhcmlhbnQuanMiLCJub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvcHJpbnRmL2xpYi9wcmludGYuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIva2V5TWlycm9yLmpzIiwiL1VzZXJzL2NhcmwtZXJpay5rb3BzZW5nL2Rldl9wcml2L0VtaXNzaW9ucy9zZXJ2ZXIvRXZlbnRDb25zdGFudHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUNBQSxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDL0IsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDNUMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3hDLElBQU0sbUJBQW1CLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FB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UyxFQUFFLFdBQVcsRUFBWCxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUM7Q0FDakQsQ0FBQzs7O0FDOUNGOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ256Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2N0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUdBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ250QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25EQSxJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7QUFFakQsTUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7QUFDdkIsbUJBQWUsRUFBRyxJQUFJO0FBQ3RCLG1CQUFlLEVBQUcsSUFBSTtBQUN0QixpQkFBYSxFQUFHLElBQUk7QUFDcEIscUJBQWlCLEVBQUcsSUFBSTtBQUN4QixhQUFTLEVBQUcsSUFBSTs7QUFFaEIsZUFBVyxFQUFHLElBQUk7OztBQUdsQixjQUFVLEVBQUcsSUFBSTtBQUNqQixjQUFVLEVBQUcsSUFBSTtBQUNqQixpQkFBYSxFQUFHLElBQUk7QUFDcEIsbUJBQWUsRUFBRyxJQUFJO0FBQ3RCLG9CQUFnQixFQUFHLElBQUk7OztBQUd2QiwyQkFBdUIsRUFBRyxJQUFJOzs7QUFHOUIsb0JBQWdCLEVBQUcsSUFBSTs7O0FBR3ZCLHlCQUFxQixFQUFHLElBQUk7QUFDNUIsdUJBQW1CLEVBQUUsSUFBSTs7O0FBSXpCLGdCQUFZLEVBQUcsSUFBSTtBQUNuQixnQ0FBNEIsRUFBRyxJQUFJOztBQUduQyx1QkFBbUIsRUFBRyxJQUFJO0FBQzFCLHlCQUFxQixFQUFHLElBQUk7QUFDNUIsc0JBQWtCLEVBQUcsSUFBSTtDQUM1QixDQUFDLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgZG9jdW1lbnQgPSByZXF1aXJlKCdnbG9iYWwvZG9jdW1lbnQnKTtcbmNvbnN0IHdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcbmNvbnN0IHNlcnZlckNvbW11bmljYXRpb24gPSByZXF1aXJlKCcuL2NsaWVudC1hcGknKTtcblxuLy8gdGhlIGFjdHVhbCByaWdnaW5nIG9mIHRoZSBhcHBsaWNhdGlvbiBpcyBkb25lIGluIHRoZSByb3V0ZXIhXG5jb25zdCByb3V0ZXIgPSByZXF1aXJlKCcuL3JvdXRlci1jb250YWluZXInKTtcblxuY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMvUm91dGVyQ29uc3RhbnRzJyk7XG5cbnNlcnZlckNvbW11bmljYXRpb24uc2V0dXAoKTtcblxuLy8gdGhlIG1pc3Npb24gdGltZXIgZ2V0cyBvdXQgc3luYyBpZiBsb3NpbmcgZm9jdXMsIHNvIHJlc3luYyB3aXRoIHNlcnZlciBldmVyeSB0aW1lIHRoZSB3aW5kb3cgcmVnYWlucyBmb2N1c1xud2luZG93Lm9uZm9jdXM9c2VydmVyQ29tbXVuaWNhdGlvbi5hc2tGb3JNaXNzaW9uVGltZTtcblxuLy8gcnVuIHN0YXJ0dXAgYWN0aW9ucyAtIHVzdWFsbHkgb25seSByZWxldmFudCB3aGVuIGRldmVsb3BpbmdcbnJlcXVpcmUoJy4vY2xpZW50LWJvb3RzdHJhcCcpLnJ1bigpO1xuXG5yb3V0ZXIucnVuKChIYW5kbGVyLCBzdGF0ZSkgPT4ge1xuICAgIC8vIHBhc3MgdGhlIHN0YXRlIGRvd24gaW50byB0aGUgUm91dGVIYW5kbGVycywgYXMgdGhhdCB3aWxsIG1ha2VcbiAgICAvLyB0aGUgcm91dGVyIHJlbGF0ZWQgcHJvcGVydGllcyBhdmFpbGFibGUgb24gZWFjaCBSSC4gVGFrZW4gZnJvbSBVcGdyYWRlIHRpcHMgZm9yIFJlYWN0IFJvdXRlclxuICAgIFJlYWN0LnJlbmRlcig8SGFuZGxlciB7Li4uc3RhdGV9Lz4sIGRvY3VtZW50LmJvZHkpO1xufSk7XG5cbiIsImNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBNQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL01pc3Npb25Db25zdGFudHMnKTtcbmNvbnN0IEFzdENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9Bc3Ryb1RlYW1Db25zdGFudHMnKTtcbmNvbnN0IE1lc3NhZ2VBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vTWVzc2FnZUFjdGlvbkNyZWF0b3JzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8vIGxhenkgbG9hZCBkdWUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5mdW5jdGlvbiBsYXp5UmVxdWlyZShwYXRoKSB7XG4gICAgbGV0IHRtcCA9IG51bGw7XG4gICAgcmV0dXJuICgpPT4ge1xuICAgICAgICBpZiAoIXRtcCkgdG1wID0gcmVxdWlyZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICB9XG59XG5jb25zdCBnZXRTZXJ2ZXJBUEkgPSBsYXp5UmVxdWlyZSgnLi4vY2xpZW50LWFwaScpO1xuY29uc3QgZ2V0TWlzc2lvbkFDID0gbGF6eVJlcXVpcmUoJy4vTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG4vLyBmb3IgYnJvd3NlcmlmeSB0byB3b3JrIGl0IG5lZWRzIHRvIGZpbmQgdGhlc2UgbWFnaWMgc3RyaW5nc1xucmVxdWlyZSgnLi9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcbnJlcXVpcmUoJy4uL2NsaWVudC1hcGknKTtcbmNvbnN0IFRpbWVyQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL1RpbWVyQWN0aW9uQ3JlYXRvcnMnKTtcblxud2luZG93Ll9fYXN0QWN0aW9ucyA9IG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgLyogaW4gdW5pdHMgcGVyIG1pbnV0ZSAqL1xuICAgIHNldE94eWdlbkNvbnN1bXB0aW9uKHVuaXRzKSB7XG4gICAgICAgIGdldFNlcnZlckFQSSgpLnNldE94eWdlbkNvbnN1bXB0aW9uKHVuaXRzKTtcbiAgICB9LFxuXG4gICAgaGVhcnRSYXRlUmVhZChyYXRlKXtcbiAgICAgICAgdmFyIHRleHQsIGxldmVsO1xuICAgICAgICBpZiAocmF0ZSA8IDkwKSB7XG4gICAgICAgICAgICBsZXZlbCA9ICdpbmZvJztcbiAgICAgICAgICAgIHRleHQgPSAnRmluZSB2ZXJkaWVyJztcbiAgICAgICAgfSBlbHNlIGlmIChyYXRlID4gMTIwKSB7XG4gICAgICAgICAgICB0ZXh0ID0gJ1ZlbGRpZyBow7h5ZSB2ZXJkaWVyISc7XG4gICAgICAgICAgICBsZXZlbCA9ICdkYW5nZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9ICdHYW5za2UgaMO4eSBoamVydGVyeXRtZS4gR3J1bm4gdGlsIGJla3ltcmluZz8nO1xuICAgICAgICAgICAgbGV2ZWwgPSAnd2FybmluZyc7XG4gICAgICAgIH1cblxuICAgICAgICBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMuYWRkTWVzc2FnZSh7dGV4dCwgbGV2ZWwsIGR1cmF0aW9uOiAyMH0pO1xuICAgIH0sXG5cbiAgICBzdGFydE1vbml0b3JUYXNrKCl7XG5cbiAgICAgICAgVGltZXJBY3Rpb25DcmVhdG9ycy5yZXNldFRpbWVyKEFzdENvbnN0YW50cy5IRUFSVF9SQVRFX1RJTUVSKTtcbiAgICAgICAgVGltZXJBY3Rpb25DcmVhdG9ycy5yZXNldFRpbWVyKEFzdENvbnN0YW50cy5SRVNQSVJBVElPTl9USU1FUik7XG4gICAgICAgIGdldE1pc3Npb25BQygpLnN0YXJ0VGFzaygnYXN0cm9uYXV0JywgJ2JyZWF0aGluZ190aW1lcicpXG4gICAgfVxuXG59O1xuIiwiY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKSxcbiAgICB1dWlkID0gcmVxdWlyZSgnLi8uLi91dGlscycpLnV1aWQsXG4gICAgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL01lc3NhZ2VDb25zdGFudHMnKTtcblxuY29uc3QgYWN0aW9ucyA9IHtcblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1zZy50ZXh0IHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtIFttc2cuaWRdIHRoZSBtZXNzYWdlIGlkLiBpZiBub3QgZ2l2ZW4sIG9uZSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gW21zZy5sZXZlbF0gc2FtZSBhcyBib290c3RyYXAncyBhbGVydCBjbGFzc2VzOiBbc3VjY2VzcywgaW5mbywgd2FybmluZywgZGFuZ2VyXVxuICAgICAqIEBwYXJhbSBbbXNnLmR1cmF0aW9uXSB7TnVtYmVyfSBvcHRpb25hbCBkdXJhdGlvbiBmb3IgdHJhbnNpZW50IG1lc3NhZ2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbWVzc2FnZSBpZFxuICAgICAqL1xuICAgIGFkZE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHZhciBpZCA9IG1zZy5pZDtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9IHV1aWQoKTtcbiAgICAgICAgICAgIG1zZy5pZCA9IGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtc2cubGV2ZWwpIHtcbiAgICAgICAgICAgIG1zZy5sZXZlbCA9ICdzdWNjZXNzJztcbiAgICAgICAgfVxuXG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogY29uc3RhbnRzLk1FU1NBR0VfQURERUQsXG4gICAgICAgICAgICAgICAgZGF0YTogbXNnXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG1zZy5kdXJhdGlvbikge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBhY3Rpb25zLnJlbW92ZU1lc3NhZ2UobXNnLmlkKSwgbXNnLmR1cmF0aW9uICogMTAwMClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbXNnIHdpdGggZGVmYXVsdCBkdXJhdGlvbiBvZiA1IHNlY29uZHNcbiAgICAgKiBAcGFyYW0gbXNnXG4gICAgICogQHBhcmFtIFtkdXJhdGlvbl0gZGVmYXVsdCBvZiA1IHNlY29uZHNcbiAgICAgKlxuICAgICAqIEBzZWUgI2FkZE1lc3NhZ2UoKSBmb3IgbW9yZSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbWVzc2FnZSBpZFxuICAgICAqL1xuICAgIGFkZFRyYW5zaWVudE1lc3NhZ2UobXNnLCBkdXJhdGlvbiA9IDUpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnMuYWRkTWVzc2FnZShPYmplY3QuYXNzaWduKHtkdXJhdGlvbn0sIG1zZykpXG4gICAgfSxcblxuICAgIHJlbW92ZU1lc3NhZ2UoaWQpIHtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBjb25zdGFudHMuUkVNT1ZFX01FU1NBR0UsXG4gICAgICAgICAgICAgICAgZGF0YTogaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbn07XG5cbi8vIHByZXZlbnQgbmV3IHByb3BlcnRpZXMgZnJvbSBiZWluZyBhZGRlZCBvciByZW1vdmVkXG5PYmplY3QuZnJlZXplKGFjdGlvbnMpO1xud2luZG93Ll9fTWVzc2FnZUFjdGlvbnMgPSBhY3Rpb25zO1xubW9kdWxlLmV4cG9ydHMgPSBhY3Rpb25zOyIsImNvbnN0IEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyksXG4gICAgTWlzc2lvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyksXG4gICAgcm91dGVyID0gcmVxdWlyZSgnLi8uLi9yb3V0ZXItY29udGFpbmVyJyk7XG5cbi8vIGxhenkgbG9hZCBkdWUgdG8gY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5jb25zdCBzZXJ2ZXJBUEkgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcGk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFwaSkge1xuICAgICAgICAgICAgYXBpID0gcmVxdWlyZSgnLi4vY2xpZW50LWFwaScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfVxufSkoKTtcblxudmFyIHRtcCA9IHtcblxuICAgIHN0YXJ0TWlzc2lvbigpe1xuICAgICAgICBzZXJ2ZXJBUEkoKS5zdGFydE1pc3Npb24oKTtcbiAgICB9LFxuXG4gICAgc3RvcE1pc3Npb24oKXtcbiAgICAgICAgc2VydmVyQVBJKCkuc3RvcE1pc3Npb24oKTtcbiAgICB9LFxuXG4gICAgcmVzZXRNaXNzaW9uKCl7XG4gICAgICAgIHNlcnZlckFQSSgpLnJlc2V0TWlzc2lvbigpO1xuICAgIH0sXG5cbiAgICBtaXNzaW9uU3RhcnRlZCgpIHtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7YWN0aW9uOiBNaXNzaW9uQ29uc3RhbnRzLk1JU1NJT05fU1RBUlRFRF9FVkVOVH0pO1xuICAgIH0sXG5cbiAgICBtaXNzaW9uU3RvcHBlZCgpIHtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7YWN0aW9uOiBNaXNzaW9uQ29uc3RhbnRzLk1JU1NJT05fU1RPUFBFRF9FVkVOVH0pO1xuICAgIH0sXG5cbiAgICBtaXNzaW9uV2FzUmVzZXQoKXtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7YWN0aW9uOiBNaXNzaW9uQ29uc3RhbnRzLk1JU1NJT05fV0FTX1JFU0VUfSk7XG4gICAgICAgIHNlcnZlckFQSSgpLmFza0ZvckFwcFN0YXRlKCk7XG4gICAgfSxcblxuICAgIG1pc3Npb25Db21wbGV0ZWQoKSB7XG4gICAgICAgIC8vQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7YWN0aW9uOiBNaXNzaW9uQ29uc3RhbnRzLk1JU1NJT05fQ09NUExFVEVEX0VWRU5UfSk7XG4gICAgICAgIHJvdXRlci50cmFuc2l0aW9uVG8oJy9jb21wbGV0ZWQnKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGVNaXNzaW9uKCl7XG4gICAgICAgIHNlcnZlckFQSSgpLmNvbXBsZXRlTWlzc2lvbigpO1xuICAgIH0sXG5cbiAgICByZWNlaXZlZEV2ZW50cyhldmVudHNDb2xsZWN0aW9uKXtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaChPYmplY3QuYXNzaWduKHt9LCBldmVudHNDb2xsZWN0aW9uLCB7YWN0aW9uOiBNaXNzaW9uQ29uc3RhbnRzLlJFQ0VJVkVEX0VWRU5UU30pKTtcbiAgICB9LFxuXG4gICAgYXNrRm9yRXZlbnRzKCl7XG4gICAgICAgIHNlcnZlckFQSSgpLmFza0ZvckV2ZW50cygpO1xuICAgIH0sXG5cbiAgICBpbnRyb1dhc1JlYWQodGVhbUlkKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5JTlRST0RVQ1RJT05fUkVBRCwgdGVhbU5hbWU6IHRlYW1JZH0pO1xuICAgICAgICBzZXJ2ZXJBUEkoKS5zZW5kVGVhbVN0YXRlQ2hhbmdlKCk7XG4gICAgfSxcblxuICAgIGNoYW5nZVNjcnViYmVyKCl7XG4gICAgICAgIHNlcnZlckFQSSgpLmFza1RvQ2hhbmdlU2NydWJGaWx0ZXIoKTtcbiAgICB9LFxuXG4gICAgc3RhcnRUYXNrKHRlYW1JZCwgdGFza0lkKXtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7YWN0aW9uOiBNaXNzaW9uQ29uc3RhbnRzLlNUQVJUX1RBU0ssIHRlYW1JZCwgdGFza0lkfSk7XG4gICAgICAgIHNlcnZlckFQSSgpLnNlbmRUZWFtU3RhdGVDaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgdGFza0NvbXBsZXRlZCh0ZWFtSWQsIHRhc2tJZCkgICB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5DT01QTEVURURfVEFTSywgdGFza0lkLCB0ZWFtSWR9KTtcbiAgICAgICAgc2VydmVyQVBJKCkuc2VuZFRlYW1TdGF0ZUNoYW5nZSgpO1xuXG4gICAgICAgIC8vIGFsc28gcHVibGlzaCB0aGlzIHRvIHNlcnZlciBhcyBzZXBhcmF0ZSBldmVudD8gLSBtYXliZSB0byB0cmlnZ2VyIHNvbWV0aGluZyBhdCBjZXJ0YWluIHBvaW50P1xuICAgIH0sXG5cbiAgICBhc2tUb1N0YXJ0TmV4dENoYXB0ZXIoKXtcbiAgICAgICAgc2VydmVyQVBJKCkuYXNrVG9TdGFydE5leHRDaGFwdGVyKCk7XG4gICAgfSxcblxuICAgIGFza1RvVHJpZ2dlckV2ZW50KHV1aWQpe1xuICAgICAgICBzZXJ2ZXJBUEkoKS50cmlnZ2VyRXZlbnQodXVpZCk7XG4gICAgfSxcblxuICAgIHNldE1pc3Npb25UaW1lKGVsYXBzZWRTZWNvbmRzKXtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gICAgICAgICAgICBhY3Rpb246IE1pc3Npb25Db25zdGFudHMuTUlTU0lPTl9USU1FX1NZTkMsXG4gICAgICAgICAgICBkYXRhOiB7ZWxhcHNlZE1pc3Npb25UaW1lOiBlbGFwc2VkU2Vjb25kc31cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn07XG5cbndpbmRvdy5fX01pc3Npb25BQyA9IHRtcDtcbm1vZHVsZS5leHBvcnRzID0gdG1wO1xuIiwiY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IFJhZGlhdGlvblN0b3JlID0gcmVxdWlyZSgnLi8uLi9zdG9yZXMvcmFkaWF0aW9uLXN0b3JlJyk7XG5jb25zdCBTY2llbmNlVGVhbUNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9TY2llbmNlVGVhbUNvbnN0YW50cycpO1xuY29uc3QgTWlzc2lvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5jb25zdCBNZXNzYWdlQWN0aW9uc0NyZWF0b3JzID0gcmVxdWlyZSgnLi9NZXNzYWdlQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IFRpbWVyQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL1RpbWVyQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IGFwaSA9IHJlcXVpcmUoJy4uL2NsaWVudC1hcGknKTtcblxudmFyIG1pc3Npb25BY3Rpb25DcmVhdG9ycyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0bXApIHRtcCA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgfVxufSkoKTtcblxuXG5jb25zdCBhY3Rpb25zID0ge1xuXG4gICAgc3RhcnRTYW1wbGVUYXNrKCl7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9DTEVBUl9SQURJQVRJT05fU0FNUExFU30pO1xuICAgICAgICBtaXNzaW9uQWN0aW9uQ3JlYXRvcnMoKS5zdGFydFRhc2soJ3NjaWVuY2UnLCAnc2FtcGxlJyk7XG4gICAgICAgIHRoaXMucmVzZXRTYW1wbGluZ1RpbWVyKCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlVGFzayh0YXNrSWQpe1xuICAgICAgICBtaXNzaW9uQWN0aW9uQ3JlYXRvcnMoKS50YXNrQ29tcGxldGVkKCdzY2llbmNlJywgdGFza0lkKTtcbiAgICB9LFxuXG4gICAgcmVzZXRTYW1wbGluZ1RpbWVyKCkge1xuICAgICAgICBUaW1lckFjdGlvbkNyZWF0b3JzLnJlc2V0VGltZXIoU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9USU1FUl8xKTtcbiAgICB9LFxuXG4gICAgdGFrZVJhZGlhdGlvblNhbXBsZSgpIHtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gICAgICAgICAgICBhY3Rpb246IFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfVEFLRV9SQURJQVRJT05fU0FNUExFXG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIGF2ZXJhZ2VSYWRpYXRpb25DYWxjdWxhdGVkKGF2ZXJhZ2Upe1xuICAgICAgICBsZXQgc2FtcGxlcyA9IFJhZGlhdGlvblN0b3JlLmdldFNhbXBsZXMoKTtcblxuICAgICAgICBpZiAoc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBzdW0gPSBzYW1wbGVzLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4gcHJldiArIGN1cnJlbnQsIDApLFxuICAgICAgICAgICAgICAgIHRydWVDYWxjdWxhdGVkQXZlcmFnZSA9IHN1bSAvIHNhbXBsZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGRpZmZJblBlcmNlbnQgPSAxMDAgKiBNYXRoLmFicygodHJ1ZUNhbGN1bGF0ZWRBdmVyYWdlIC0gYXZlcmFnZSkgLyB0cnVlQ2FsY3VsYXRlZEF2ZXJhZ2UpO1xuXG4gICAgICAgICAgICBpZiAoZGlmZkluUGVyY2VudCA+IDE1KSB7XG4gICAgICAgICAgICAgICAgTWVzc2FnZUFjdGlvbnNDcmVhdG9ycy5hZGRUcmFuc2llbnRNZXNzYWdlKHt0ZXh0OiAnTXVsaWcgZGV0IGdqZW5ub21zbml0dGV0IGJsZSBsaXR0IGZlaWwuJ30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGFjdGlvbjogU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9BVkdfUkFESUFUSU9OX0NBTENVTEFURUQsXG4gICAgICAgICAgICBkYXRhOiB7YXZlcmFnZX1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGF2ZXJhZ2UgPiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX0FWR19SQURfUkVEX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgTWVzc2FnZUFjdGlvbnNDcmVhdG9ycy5hZGRUcmFuc2llbnRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnVmVsZGlnIGjDuHl0IHJhZGlvYWt0aXZ0IG5pdsOlIGRldGVrdGVydC4gVmFyc2xlIHNpa2tlcmhldHN0ZWFtZXQgdW1pZGRlbGJhcnQhJyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ2RhbmdlcicsXG4gICAgICAgICAgICAgICAgaWQ6IFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfUkFESUFUSU9OX1dBUk5JTkdfTVNHXG4gICAgICAgICAgICB9LCAzMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXZlcmFnZSA+IFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfQVZHX1JBRF9PUkFOR0VfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICBNZXNzYWdlQWN0aW9uc0NyZWF0b3JzLmFkZFRyYW5zaWVudE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHRleHQ6ICdIw7h5ZSB2ZXJkaWVyIGF2IHJhZGlvYWt0aXZpdGV0LiBGw7hsZyBtZWQgcMOlIG9tIGRldCBnw6VyIG5lZG92ZXIgaWdqZW4nLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgaWQ6IFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfUkFESUFUSU9OX1dBUk5JTkdfTVNHXG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBsZXRlVGFzaygnYXZlcmFnZScpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmFkaWF0aW9uIGxldmVsIHRoYXQgd2lsbCBiZSByZXBvcnRlZCB0byB0aGUgdmlldyBsYXllclxuICAgICAqIFRoZSByZXBvcnRlZCByYWRpYXRpb24gd2lsbCBnZW5lcmF0ZWQgdmFsdWVzIGluIHRoZSByYW5nZSBnaXZlbiBieSB0aGUgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogV2UgYXJlIG5vdCBhY3R1YWxseSByZWNlaXZpbmcgYSBzdHJlYW0gb2YgdmFsdWVzIGZyb20gdGhlIHNlcnZlciwgYXMgdGhhdCBjb3VsZFxuICAgICAqIGJlIHZlcnkgcmVzb3VyY2UgaGVhdnkuIEluc3RlYWQgd2UgZ2VuZXJhdGUgcmFuZG9tIHZhbHVlcyBiZXR3ZWVuIHRoZSBnaXZlbiB2YWx1ZXMsXG4gICAgICogd2hpY2ggdG8gdGhlIHVzZXIgd2lsbCBsb29rIHRoZSBzYW1lLlxuICAgICAqIEBwYXJhbSBtaW5cbiAgICAgKiBAcGFyYW0gbWF4XG4gICAgICovXG4gICAgICAgIHNldFJhZGlhdGlvbkxldmVsKG1pbiwgbWF4KSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgYWN0aW9uOiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1JBRElBVElPTl9MRVZFTF9DSEFOR0VELFxuICAgICAgICAgICAgZGF0YToge21pbiwgbWF4fVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYWRkVG9Ub3RhbFJhZGlhdGlvbkxldmVsKGFtb3VudCl7XG5cbiAgICAgICAgdmFyIHRvdGFsID0gYW1vdW50ICsgUmFkaWF0aW9uU3RvcmUuZ2V0VG90YWxMZXZlbCgpO1xuXG4gICAgICAgIGlmICh0b3RhbCA+IFNjaWVuY2VUZWFtQ29uc3RhbnRzLlNDSUVOQ0VfVE9UQUxfUkFESUFUSU9OX1ZFUllfU0VSSU9VU19USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25zQ3JlYXRvcnMuYWRkVHJhbnNpZW50TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6ICdzY2llbmNlX2hpZ2hfcmFkaWF0aW9uX2xldmVsJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnRmFyZXRydWVuZGUgaMO4eXQgc3Ryw6VsaW5nc25pdsOlIScsXG4gICAgICAgICAgICAgICAgbGV2ZWw6ICdkYW5nZXInXG4gICAgICAgICAgICB9LCAzMCk7XG4gICAgICAgIH0gZWxzZSBpZiAodG90YWwgPiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1RPVEFMX1JBRElBVElPTl9TRVJJT1VTX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgTWVzc2FnZUFjdGlvbnNDcmVhdG9ycy5hZGRUcmFuc2llbnRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogJ3NjaWVuY2VfaGlnaF9yYWRpYXRpb25fbGV2ZWwnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdIw7h5dCBzdHLDpWxpbmdzbml2w6UhJyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnXG4gICAgICAgICAgICB9LCAzMCk7XG4gICAgICAgIH1cblxuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGFjdGlvbjogU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9UT1RBTF9SQURJQVRJT05fTEVWRUxfQ0hBTkdFRCxcbiAgICAgICAgICAgIGRhdGE6IHt0b3RhbCwgYWRkZWQ6IGFtb3VudH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb21wbGV0ZVRhc2soJ2FkZHRvdGFsJyk7XG4gICAgfVxuXG59O1xuXG53aW5kb3cuX19TY2llbmNlQWN0aW9ucyA9IGFjdGlvbnM7XG5tb2R1bGUuZXhwb3J0cyA9IGFjdGlvbnM7IiwiY29uc3QgTWVzc2FnZUFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9NZXNzYWdlQWN0aW9uQ3JlYXRvcnMnKTtcblxuLy8gbGF6eSBsb2FkIGR1ZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbmZ1bmN0aW9uIGxhenlSZXF1aXJlKHBhdGgpIHtcbiAgICBsZXQgdG1wID0gbnVsbDtcbiAgICByZXR1cm4gKCk9PiB7XG4gICAgICAgIGlmICghdG1wKSB0bXAgPSByZXF1aXJlKHBhdGgpO1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgIH1cbn1cbmNvbnN0IGdldE1pc3Npb25BQyA9IGxhenlSZXF1aXJlKCcuL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuY29uc3QgZ2V0U2VydmVyQVBJID0gbGF6eVJlcXVpcmUoJy4uL2NsaWVudC1hcGknKTtcbi8vIGZvciBicm93c2VyaWZ5IHRvIHdvcmsgaXQgbmVlZHMgdG8gZmluZCB0aGVzZSBtYWdpYyBzdHJpbmdzXG5yZXF1aXJlKCcuL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xucmVxdWlyZSgnLi4vY2xpZW50LWFwaScpO1xuXG52YXIgYWN0aW9ucyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHN0YXJ0RGF0YVRyYW5zZmVyQ2hlY2soKXtcbiAgICAgICAgZ2V0TWlzc2lvbkFDKCkuc3RhcnRUYXNrKCdzZWN1cml0eScsICdzaWduYWxfdGVzdCcpXG4gICAgfSxcblxuICAgIGVuZERhdGFRdWFsaXR5VGVzdChnb29kT3V0Y29tZSl7XG4gICAgICAgIGlmICghZ29vZE91dGNvbWUpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25DcmVhdG9ycy5hZGRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnS3ZhbGl0ZXRlbiBww6Uga29tbXVuaWthc2pvbnNzaWduYWxldCBlciBmb3IgZMOlcmxpZy4gRXIgcmVwYXJhc2pvbmVuIGZ1bGxmw7hydD8nLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25DcmVhdG9ycy5hZGRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnVEVTVCBPSycsIGR1cmF0aW9uOiAyLCBsZXZlbDogJ2luZm8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFjdGlvbnMuc2VuZFJlYWR5Rm9yU2FmZU1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRNaXNzaW9uQUMoKS50YXNrQ29tcGxldGVkKCdzZWN1cml0eScsICdzaWduYWxfdGVzdCcpXG4gICAgfSxcblxuICAgIGVuZERhdGFUcmFuc2ZlclRlc3QoZ29vZE91dGNvbWUpe1xuICAgICAgICBpZiAoIWdvb2RPdXRjb21lKSB7XG4gICAgICAgICAgICBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdGV4dDogJ092ZXJmw7hyaW5nZW4gYXYgZGF0YSB2YXIgZm9yIHVzdGFiaWwuIFRlc3RlbiBmZWlsZXQuJyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnZXRNaXNzaW9uQUMoKS50YXNrQ29tcGxldGVkKCdzZWN1cml0eScsICdzaWduYWxfdGVzdCcpXG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIE1lc3NhZ2VBY3Rpb25DcmVhdG9ycy5hZGRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnVEVTVCBPSycsIGR1cmF0aW9uOiAyLCBsZXZlbDogJ2luZm8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZW5kUmVhZHlGb3JTYWZlTW9kZSgpe1xuICAgICAgICBnZXRTZXJ2ZXJBUEkoKS5zZXRSZWFkeUZvclNhZmVNb2RlKCk7XG4gICAgfSxcblxuICAgIHNldEluU2FmZU1vZGUoKXtcbiAgICAgICAgZ2V0U2VydmVyQVBJKCkuc2V0SW5TYWZlTW9kZSgpO1xuICAgIH1cbn07XG5cbndpbmRvdy5fX1NlY1RlYW1BY3Rpb25zID0gYWN0aW9uczsiLCJjb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL1RpbWVyQ29uc3RhbnRzJyk7XG5cbmNvbnN0IGFjdGlvbnMgPSB7XG5cbiAgICBzdGFydFRpbWVyKGlkKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogY29uc3RhbnRzLlNUQVJUX1RJTUVSLCBkYXRhOiB7dGltZXJJZDogaWR9fSk7XG4gICAgfSxcblxuICAgIHJlc2V0VGltZXIoaWQpIHtcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7YWN0aW9uOiBjb25zdGFudHMuUkVTRVRfVElNRVIsIGRhdGE6IHt0aW1lcklkOiBpZH19KTtcbiAgICB9LFxuXG4gICAgc3RvcFRpbWVyKGlkKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogY29uc3RhbnRzLlNUT1BfVElNRVIsIGRhdGE6IHt0aW1lcklkOiBpZH19KTtcbiAgICB9LFxuXG4gICAgc2V0VGltZXIodGltZXJJZCwgdGltZSkge1xuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGFjdGlvbjogY29uc3RhbnRzLlNFVF9USU1FUixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdUaW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgIHRpbWVySWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFjdGlvbnM7IiwiLypcbiAqIERpc3BhdGNoZXIgLSBhIHNpbmdsZXRvblxuICpcbiAqIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIG1haW4gZHJpdmVyIGluIHRoZSBGbHV4IGFyY2hpdGVjdHVyZVxuICogQHNlZSBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL2ZsdXgvZG9jcy9vdmVydmlldy5odG1sXG4qL1xuXG5jb25zdCB7IERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJ2ZsdXgnKTtcblxuY29uc3QgQXBwRGlzcGF0Y2hlciA9IE9iamVjdC5hc3NpZ24obmV3IERpc3BhdGNoZXIoKSwge1xuXG4gICAgLy8gb3B0aW9uYWwgbWV0aG9kc1xuXG59KTtcblxud2luZG93Ll9fQXBwRGlzcGF0Y2hlcj0gQXBwRGlzcGF0Y2hlcjtcbm1vZHVsZS5leHBvcnRzID0gQXBwRGlzcGF0Y2hlcjsiLCJjb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBpbyA9IHJlcXVpcmUoJ3NvY2tldC5pbycpO1xuY29uc3Qgc29ja2V0ID0gaW8oKTtcbmNvbnN0IE1pc3Npb25Db25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5jb25zdCBNaXNzaW9uQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG5jb25zdCBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2FjdGlvbnMvTWVzc2FnZUFjdGlvbkNyZWF0b3JzJyk7XG5jb25zdCBTY2llbmNlVGVhbUFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9hY3Rpb25zL1NjaWVuY2VBY3Rpb25DcmVhdG9ycycpO1xuY29uc3QgU2VjdXJpdHlUZWFtQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2FjdGlvbnMvU2VjdXJpdHlUZWFtQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IEFzdHJvVGVhbVRlYW1BY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYWN0aW9ucy9Bc3Ryb1RlYW1BY3Rpb25DcmVhdG9ycycpO1xuY29uc3QgUmFkaWF0aW9uU3RvcmUgPSByZXF1aXJlKCcuL3N0b3Jlcy9yYWRpYXRpb24tc3RvcmUnKTtcbmNvbnN0IFRpbWVyU3RvcmUgPSByZXF1aXJlKCcuL3N0b3Jlcy90aW1lci1zdG9yZScpO1xuY29uc3QgVGFza1N0b3JlID0gcmVxdWlyZSgnLi9zdG9yZXMvdGFzay1zdG9yZScpO1xuY29uc3QgSW50cm9kdWN0aW9uU3RvcmUgPSByZXF1aXJlKCcuL3N0b3Jlcy9pbnRyb2R1Y3Rpb24tc3RvcmUnKTtcbmNvbnN0IFJvdXRlciA9IHJlcXVpcmUoJy4vcm91dGVyLWNvbnRhaW5lcicpO1xuY29uc3QgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuLi9zZXJ2ZXIvRXZlbnRDb25zdGFudHMnKTtcblxudmFyIGFwaSA9IHtcblxuICAgIHNldHVwKCkge1xuXG4gICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHRvIHNlcnZlciBXZWJTb2NrZXRcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFza2luZyBzZXJ2ZXIgZm9yIGFwcCBzdGF0ZVwiKTtcbiAgICAgICAgICAgIGFwaS5hc2tGb3JBcHBTdGF0ZSgpO1xuICAgICAgICAgICAgTWVzc2FnZUFjdGlvbkNyZWF0b3JzLnJlbW92ZU1lc3NhZ2UoJ2Rpc2Nvbm5lY3QgbWVzc2FnZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2Rpc2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMuYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6ICdkaXNjb25uZWN0IG1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdNaXN0ZXQga29udGFrdCBtZWQgc2VydmVyZW4uIExhc3Qgc2lkZW4gcMOlIG55dHQnLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnZGFuZ2VyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbihFdmVudENvbnN0YW50cy5NSVNTSU9OX1NUQVJURUQsIChhcHBTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgTWlzc2lvbkFjdGlvbkNyZWF0b3JzLm1pc3Npb25TdGFydGVkKCk7XG4gICAgICAgICAgICB0aGlzLl9hcHBTdGF0ZVJlY2VpdmVkKGFwcFN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbihFdmVudENvbnN0YW50cy5NSVNTSU9OX1NUT1BQRUQsICgpID0+IE1pc3Npb25BY3Rpb25DcmVhdG9ycy5taXNzaW9uU3RvcHBlZCgpKTtcbiAgICAgICAgc29ja2V0Lm9uKEV2ZW50Q29uc3RhbnRzLk1JU1NJT05fQ09NUExFVEVELCAoKT0+IE1pc3Npb25BY3Rpb25DcmVhdG9ycy5taXNzaW9uQ29tcGxldGVkKCkpO1xuICAgICAgICBzb2NrZXQub24oRXZlbnRDb25zdGFudHMuTUlTU0lPTl9SRVNFVCwgKCk9PiBNaXNzaW9uQWN0aW9uQ3JlYXRvcnMubWlzc2lvbldhc1Jlc2V0KCkpO1xuXG4gICAgICAgIHNvY2tldC5vbihFdmVudENvbnN0YW50cy5TRVRfRVZFTlRTLCBNaXNzaW9uQWN0aW9uQ3JlYXRvcnMucmVjZWl2ZWRFdmVudHMpO1xuICAgICAgICBzb2NrZXQub24oRXZlbnRDb25zdGFudHMuQUREX01FU1NBR0UsIChzZXJ2ZXJNc2cpID0+IHtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJNc2cuYXVkaWVuY2UgJiYgc2VydmVyTXNnLmF1ZGllbmNlICE9PSBSb3V0ZXIuZ2V0VGVhbUlkKCkpIHJldHVybjtcblxuICAgICAgICAgICAgTWVzc2FnZUFjdGlvbkNyZWF0b3JzLmFkZE1lc3NhZ2Uoc2VydmVyTXNnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdtaXNzaW9uIHRpbWUnLCBNaXNzaW9uQWN0aW9uQ3JlYXRvcnMuc2V0TWlzc2lvblRpbWUpO1xuXG4gICAgICAgIHNvY2tldC5vbihFdmVudENvbnN0YW50cy5BUFBfU1RBVEUsIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXBwU3RhdGVSZWNlaXZlZChzdGF0ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHRoZSBjbGllbnQgbWlzc2VzIHRoZSBtZXNzYWdlL2V2ZW50IGl0IGlzIGxvc3QgLi4uIGFuZCB0aGUgY3VycmVudF9ldmVudCB3aWxsIGJlIHVuY2hhbmdlZCA6LShcbiAgICAgICAgLy8gVE9ETzogc3RvcmUgaXQgc2VydmVyX3NpZGUgaW4gdGhlIHRlYW1TdGF0ZSBiZWZvcmUgc2VuZGluZ1xuICAgICAgICBzb2NrZXQub24oRXZlbnRDb25zdGFudHMuQVNUX0NIRUNLX1ZJVEFMUywgKCk9PiB7XG4gICAgICAgICAgICBBc3Ryb1RlYW1UZWFtQWN0aW9uQ3JlYXRvcnMuc3RhcnRNb25pdG9yVGFzaygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oRXZlbnRDb25zdGFudHMuU0NJRU5DRV9DSEVDS19SQURJQVRJT04sICgpPT4ge1xuICAgICAgICAgICAgU2NpZW5jZVRlYW1BY3Rpb25DcmVhdG9ycy5zdGFydFNhbXBsZVRhc2soKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKEV2ZW50Q29uc3RhbnRzLlNFQ1VSSVRZX0NIRUNLX0RBVEFfVFJBTlNGRVIsICgpPT4ge1xuICAgICAgICAgICAgU2VjdXJpdHlUZWFtQWN0aW9uQ3JlYXRvcnMuc3RhcnREYXRhVHJhbnNmZXJDaGVjaygpO1xuICAgICAgICB9KTtcblxuXG4gICAgfSxcblxuICAgIHN0YXJ0TWlzc2lvbigpe1xuICAgICAgICBzb2NrZXQuZW1pdCgnc3RhcnQgbWlzc2lvbicpO1xuICAgIH0sXG5cbiAgICBzdG9wTWlzc2lvbigpe1xuICAgICAgICBzb2NrZXQuZW1pdCgnc3RvcCBtaXNzaW9uJyk7XG4gICAgfSxcblxuICAgIHJlc2V0TWlzc2lvbigpe1xuICAgICAgICBzb2NrZXQuZW1pdCgncmVzZXQgbWlzc2lvbicpO1xuICAgIH0sXG5cbiAgICBhc2tUb1N0YXJ0TmV4dENoYXB0ZXIoKXtcbiAgICAgICAgc29ja2V0LmVtaXQoRXZlbnRDb25zdGFudHMuQURWQU5DRV9DSEFQVEVSKTtcbiAgICB9LFxuXG4gICAgdHJpZ2dlckV2ZW50KHV1aWQpe1xuICAgICAgICBzb2NrZXQuZW1pdChFdmVudENvbnN0YW50cy5UUklHR0VSX0VWRU5ULCB1dWlkKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBTZW5kIHRoZSBjbGllbnQgaGVsZCBzdGF0ZSAoZm9yIHRoZSBjdXJyZW50IHRlYW0pIHRvIHNlcnZlciBvbiBjaGFuZ2VcbiAgICAgKiBUaGUgbW9zdCBpbXBvcnRhbnQgYml0cyBhcmUgaGVsZCBvbiBzZXJ2ZXIsIGFuZCBpcyBub3QgdHJhbnNmZXJyZWQgYmFjayxcbiAgICAgKiBzdWNoIGFzIGlmIHRoZSBtaXNzaW9uIGlzIHJ1bm5pbmcsIHRoZSBjdXJyZW50IGNoYXB0ZXIsIGV0Yy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IHRvIHN0b3JlIG9uIHRoZSBzZXJ2ZXIgaW4gY2FzZSB3ZSBkcm9wIHRoZSBjb25uZWN0aW9uIGFuZCByZWNvbm5lY3QgaW4gb3RoZXIgc2Vzc2lvblxuICAgICAqL1xuICAgIHNlbmRUZWFtU3RhdGVDaGFuZ2UodGVhbUlkID0gUm91dGVyLmdldFRlYW1JZCgpKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHt9O1xuXG4gICAgICAgIHN0YXRlLnRlYW0gPSB0ZWFtSWQ7XG4gICAgICAgIHN0YXRlLmludHJvZHVjdGlvbl9yZWFkID0gSW50cm9kdWN0aW9uU3RvcmUuaXNJbnRyb2R1Y3Rpb25SZWFkKHRlYW1JZCk7XG4gICAgICAgIHN0YXRlLmN1cnJlbnRfdGFzayA9IFRhc2tTdG9yZS5nZXRDdXJyZW50VGFza0lkKHRlYW1JZCk7XG5cbiAgICAgICAgaWYgKHRlYW1JZCA9PT0gJ3NjaWVuY2UnKSB7XG4gICAgICAgICAgICBzdGF0ZS5yYWRpYXRpb24gPSBSYWRpYXRpb25TdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc29ja2V0LmVtaXQoJ3NldCB0ZWFtIHN0YXRlJywgc3RhdGUpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZU1pc3Npb24oKXtcbiAgICAgICAgc29ja2V0LmVtaXQoRXZlbnRDb25zdGFudHMuQ09NUExFVEVfTUlTU0lPTik7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogVGhpcyBpcyBvbmx5IHN0dWJiZWQgb3V0IHVudGlsIHNlcnZlciBjb21tdW5pY2F0aW9uIGlzIHVwIGFuZCBydW5uaW5nXG4gICAgICovXG4gICAgYXNrRm9yQXBwU3RhdGUoKSB7XG4gICAgICAgIHNvY2tldC5lbWl0KCdnZXQgYXBwIHN0YXRlJyk7XG4gICAgfSxcblxuICAgIGFza0Zvck1pc3Npb25UaW1lKCl7XG4gICAgICAgIHNvY2tldC5lbWl0KCdnZXQgbWlzc2lvbiB0aW1lJyk7XG4gICAgfSxcblxuICAgIGFza1RvQ2hhbmdlU2NydWJGaWx0ZXIoKXtcbiAgICAgICAgc29ja2V0LmVtaXQoJ3NldCBzY3J1YiBmaWx0ZXIgY2hhbmdlZCcpXG4gICAgfSxcblxuICAgIF9hcHBTdGF0ZVJlY2VpdmVkKGFwcFN0YXRlKSB7XG4gICAgICAgIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2goe2FjdGlvbjogTWlzc2lvbkNvbnN0YW50cy5SRUNFSVZFRF9BUFBfU1RBVEUsIGFwcFN0YXRlfSk7XG4gICAgfSxcblxuICAgIGFza0ZvckV2ZW50cygpe1xuICAgICAgICBzb2NrZXQuZW1pdChFdmVudENvbnN0YW50cy5HRVRfRVZFTlRTKTtcbiAgICB9LFxuXG4gICAgc2V0T3h5Z2VuQ29uc3VtcHRpb24odW5pdHMpIHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ3NldCBveHlnZW4gY29uc3VtcHRpb24nLCB1bml0cyk7XG4gICAgfSxcblxuICAgIHNldFJlYWR5Rm9yU2FmZU1vZGUoKXtcbiAgICAgICAgc29ja2V0LmVtaXQoJ3JlYWR5IGZvciBzYWZlIG1vZGUnKTtcbiAgICB9LFxuXG4gICAgc2V0SW5TYWZlTW9kZSgpe1xuICAgICAgICBzb2NrZXQuZW1pdCgnc2V0IGluIHNhZmUgbW9kZScpO1xuICAgIH0sXG5cbiAgICAvLyBtZWFudCBmb3IgdGVzdGluZyAtIG5vdCBhY3R1YWwgY2xpZW50IHVzZVxuICAgIHNldE94eWdlbkxldmVsKHVuaXRzKSB7XG4gICAgICAgIHNvY2tldC5lbWl0KCdzZXQgb3h5Z2VuIHJlbWFpbmluZycsIHVuaXRzKTtcbiAgICB9XG5cbn07XG5cbndpbmRvdy5fX2FwaSA9IGFwaTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuIiwiLyogU2NyaXB0IHRvIGJvb3RzdHJhcCB0aGUgYXBwbGljYXRpb24gKi9cblxudmFyIE1pc3Npb25BY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKSxcbiAgICBNZXNzYWdlQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2FjdGlvbnMvTWVzc2FnZUFjdGlvbkNyZWF0b3JzJyksXG4gICAgU2NpZW5jZUFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9hY3Rpb25zL1NjaWVuY2VBY3Rpb25DcmVhdG9ycycpLFxuICAgIFNjaWVuY2VDb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9TY2llbmNlVGVhbUNvbnN0YW50cycpLFxuICAgIFRpbWVyQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2FjdGlvbnMvVGltZXJBY3Rpb25DcmVhdG9ycycpLFxuICAgIEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2FwcGRpc3BhdGNoZXInKTtcblxuQXBwRGlzcGF0Y2hlci5yZWdpc3RlcigocGF5bG9hZCk9PiB7XG4gICAgY29uc29sZS5sb2coJ0RFQlVHIEFwcERpc3BhdGNoZXIuZGlzcGF0Y2gnLCBwYXlsb2FkKTtcbn0pO1xuXG5mdW5jdGlvbiBydW4oKSB7XG5cbiAgICAvLyBTRVRUSU5HU1xuICAgIE1pc3Npb25BY3Rpb25DcmVhdG9ycy5zdGFydE1pc3Npb24oKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7cnVufTsiLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcblxuY29uc3QgUm91dGVIYW5kbGVyID0gUm91dGVyLlJvdXRlSGFuZGxlcjtcblxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXIucmVhY3QnKTtcblxuY29uc3QgTWVzc2FnZUxpc3QgPSByZXF1aXJlKCcuL21lc3NhZ2UtbGlzdC5yZWFjdCcpO1xuY29uc3QgTWlzc2lvblN0YXRlU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvbWlzc2lvbi1zdGF0ZS1zdG9yZScpO1xuXG5jb25zdCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBtaXhpbnM6IFtdLFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge2lzTWlzc2lvblJ1bm5pbmc6IE1pc3Npb25TdGF0ZVN0b3JlLmlzTWlzc2lvblJ1bm5pbmcoKX07XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgTWlzc2lvblN0YXRlU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlTWlzc2lvblN0YXRlQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKXtcbiAgICAgICAgY29uc29sZS5sb2coJ0FwcC5jb21wb25lbnREaWRNb3VudCcpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgTWlzc2lvblN0YXRlU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlTWlzc2lvblN0YXRlQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZU1pc3Npb25TdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNNaXNzaW9uUnVubmluZzogTWlzc2lvblN0YXRlU3RvcmUuaXNNaXNzaW9uUnVubmluZygpfSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29udGFpbmVyJz5cblxuICAgICAgICAgICAgICAgIDxIZWFkZXIvPlxuXG4gICAgICAgICAgICAgICAgey8qIHRoaXMgaXMgdGhlIGltcG9ydGFudCBwYXJ0ICovfVxuICAgICAgICAgICAgICAgIDxSb3V0ZUhhbmRsZXIgey4uLnRoaXMucHJvcHN9IHsuLi50aGlzLnN0YXRlfSAvPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvb3RlciBpZD0nbWFpbi1mb290ZXInPjwvZm9vdGVyPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwOyIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IEhlYXJ0UmF0ZUNoYXJ0ID0gcmVxdWlyZSgnLi9oZWFydC1yYXRlLWNoYXJ0LnJlYWN0Jyk7XG5jb25zdCBCcmVhdGhSYXRlQ2hhcnQgPSByZXF1aXJlKCcuL2JyZWF0aC1yYXRlLWNoYXJ0LnJlYWN0Jyk7XG5jb25zdCBUaW1lclBhbmVsID0gcmVxdWlyZSgnLi90aW1lci1wYW5lbC5yZWFjdCcpO1xuY29uc3QgVGltZXJBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvVGltZXJBY3Rpb25DcmVhdG9ycycpO1xuY29uc3QgT3h5Z2VuU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvb3h5Z2VuLXN0b3JlJyk7XG5jb25zdCBBc3Ryb25hdXRDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvQXN0cm9UZWFtQ29uc3RhbnRzJyk7XG5jb25zdCBBc3Ryb25hdXRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvQXN0cm9UZWFtQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IHsgcGFyc2VOdW1iZXIgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cblRpbWVyQWN0aW9uQ3JlYXRvcnMuc2V0VGltZXIoQXN0cm9uYXV0Q29uc3RhbnRzLlJFU1BJUkFUSU9OX1RJTUVSLCAxNSk7XG5UaW1lckFjdGlvbkNyZWF0b3JzLnNldFRpbWVyKEFzdHJvbmF1dENvbnN0YW50cy5IRUFSVF9SQVRFX1RJTUVSLCAxMCk7XG5cbi8vIGxhenkgbG9hZCBkdWUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5mdW5jdGlvbiBsYXp5UmVxdWlyZShwYXRoKSB7XG4gICAgbGV0IHRtcCA9IG51bGw7XG4gICAgcmV0dXJuICgpPT4ge1xuICAgICAgICBpZiAoIXRtcCkgdG1wID0gcmVxdWlyZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICB9XG59XG5jb25zdCBnZXRNaXNzaW9uQUMgPSBsYXp5UmVxdWlyZSgnLi4vYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcbi8vIGZvciBicm93c2VyaWZ5IHRvIHdvcmsgaXQgbmVlZHMgdG8gZmluZCB0aGVzZSBtYWdpYyBzdHJpbmdzXG5yZXF1aXJlKCcuLi9hY3Rpb25zL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHN0YXRpY3M6IHt9LFxuXG4gICAgcHJvcFR5cGVzOiB7fSxcblxuICAgIG1peGluczogW10sXG5cbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpO1xuICAgIH0sXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBPeHlnZW5TdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcigoKSA9PiB0aGlzLl91cGRhdGVTdGF0ZSgpKTtcbiAgICB9LFxuXG4gICAgX2luZGljYXRvckNvbG9yKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLm94eWdlblN0b3JlLmNvbG9ySW5kaWNhdG9yO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fZ2V0U3RhdGUoKSlcbiAgICB9LFxuXG4gICAgX2dldFN0YXRlKCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBveHlnZW5TdG9yZTogT3h5Z2VuU3RvcmUuZ2V0U3RhdGUoKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfaGFuZGxlQnJlYXRoUmF0ZShlKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgZWwgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzLnJlZnNbJ2JyZWF0aC1yYXRlJ10pO1xuICAgICAgICBBc3Ryb25hdXRBY3Rpb25DcmVhdG9ycy5zZXRPeHlnZW5Db25zdW1wdGlvbihwYXJzZU51bWJlcihlbC52YWx1ZSkpXG4gICAgICAgIGdldE1pc3Npb25BQygpLnRhc2tDb21wbGV0ZWQoJ2FzdHJvbmF1dCcsICdicmVhdGhpbmdfY2FsY3VsYXRlJylcbiAgICB9LFxuXG4gICAgX2hhbmRsZUhlYXJ0UmF0ZShlKXtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgZWwgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzLnJlZnNbJ2hlYXJ0LXJhdGUtaW5wdXQnXSk7XG4gICAgICAgIEFzdHJvbmF1dEFjdGlvbkNyZWF0b3JzLmhlYXJ0UmF0ZVJlYWQocGFyc2VOdW1iZXIoZWwudmFsdWUpKTtcbiAgICAgICAgZ2V0TWlzc2lvbkFDKCkudGFza0NvbXBsZXRlZCgnYXN0cm9uYXV0JywgJ2hlYXJ0cmF0ZV9jYWxjdWxhdGUnKVxuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgcmV0dXJuICggPGRpdiA+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG5cbiAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgICAgIEx1ZnRzdGF0dXM6XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2lyY2xlIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9eyB7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLCBiYWNrZ3JvdW5kQ29sb3IgOiB0aGlzLl9pbmRpY2F0b3JDb2xvcigpIH0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+Rm9yYnJ1ayA6IHsgdGhpcy5zdGF0ZS5veHlnZW5TdG9yZS5jb25zdW1wdGlvblBlck1pbnV0ZSB9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPGxpPkdqZW5zdMOlZW5kZSBva3N5Z2VuOiB7IHRoaXMuc3RhdGUub3h5Z2VuU3RvcmUucmVtYWluaW5nfSBlbmhldGVyPC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb2wtbWQtNic+XG4gICAgICAgICAgICAgICAgICAgIDxoMj5QdXN0PC9oMj5cbiAgICAgICAgICAgICAgICAgICAgPEJyZWF0aFJhdGVDaGFydCBoZWlnaHQ9ezI0MH0vPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbC1tZC02Jz5cbiAgICAgICAgICAgICAgICAgICAgPGgyPkhqZXJ0ZXNsYWc8L2gyPlxuICAgICAgICAgICAgICAgICAgICA8SGVhcnRSYXRlQ2hhcnQgaGVpZ2h0PXsyNDB9Lz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxUaW1lclBhbmVsIHRpbWVySWQ9e0FzdHJvbmF1dENvbnN0YW50cy5SRVNQSVJBVElPTl9USU1FUn0gY2xhc3NOYW1lPSdjb2wtbWQtNicvPlxuICAgICAgICAgICAgICAgIDxUaW1lclBhbmVsIHRpbWVySWQ9e0FzdHJvbmF1dENvbnN0YW50cy5IRUFSVF9SQVRFX1RJTUVSfSBjbGFzc05hbWU9J2NvbC1tZC02Jy8+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wteHMtNlwiPlxuICAgICAgICAgICAgICAgICAgICA8ZmllbGRzZXQgZGlzYWJsZWQ9eyBmYWxzZSB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGgzPkJlcmVnbmV0IGx1ZnRmb3JicnVrPC9oMz5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0gb25TdWJtaXQ9e3RoaXMuX2hhbmRsZUJyZWF0aFJhdGV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgcmVmPSdicmVhdGgtcmF0ZSc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9ezF9PjEgZW5oZXQgcGVyIG1pbnV0dDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXsyfT4yIGVuaGV0ZXIgcGVyIG1pbnV0dDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPSdidG4gYnRuLXByaW1hcnknPkV2YWx1ZXI8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICAgICAgICAgPC9maWVsZHNldD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTZcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0IGRpc2FibGVkPXsgZmFsc2UgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMz5CZXJlZ25ldCBoamVydGVyeXRtZTwvaDM+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXt0aGlzLl9oYW5kbGVIZWFydFJhdGV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCByZWY9J2hlYXJ0LXJhdGUtaW5wdXQnIHR5cGU9XCJudW1iZXJcIiBtaW49XCI1MFwiIG1heD1cIjIwMFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5Jz5FdmFsdWVyPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvZGl2PiApO1xuICAgIH1cblxufSk7XG5cbiIsIi8qKlxuICogVEhJUyBERVNJR04gT05MWSBTVVBQT1JUUyBPTkUgQ0hBUlQgQVMgVEhFWSAqU0hBUkUqIFNUQVRFXG4gKiBGb3IgYSBub24tc3R1cGlkIGRlc2lnbiwgZG8gc29tZXRoaW5nIGxpa2UgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgYXJ0aWNsZSBieSBOaWNvbGFzIEhlcnk6XG4gKiBodHRwOi8vbmljb2xhc2hlcnkuY29tL2ludGVncmF0aW5nLWQzanMtdmlzdWFsaXphdGlvbnMtaW4tYS1yZWFjdC1hcHBcbiAqXG4gKiBDaGFydCBjb2RlIG1vcmUgb3IgbGVzcyBjb3BpZWQgZnJvbSB0aGUgcHJvdG90eXBlIGJ5IExlbyBNYXJ0aW4gV2VzdGJ5XG4gKi9cbmNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IEFtQ2hhcnRzID0gcmVxdWlyZSgnYW1jaGFydHMnKTtcbnZhciBCcmVhdGhSYXRlU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvYnJlYXRoLXJhdGUtc3RvcmUnKTtcbmNvbnN0IHsgcmFuZG9tSW50IH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vL0x1bmcgdm9sdW1lIGluIG1sIGJlZm9yZSBhbmQgYWZ0ZXIgaW5oYWxhdGlvblxudmFyIGxvd1ZvbHVtZSA9IDIwMDA7XG52YXIgaGlnaFZvbHVtZSA9IDMwMDA7XG5cbi8vTWlsbGl2b2x0cyBkaXNwbGF5ZWQgb24gdGhlIFkgYXhpcyBvZiB0aGUgRUNHIGdyYXBoXG52YXIgaGlnaE1WID0gMTtcbnZhciBsb3dNViA9IDA7XG5cbnZhciBicmVhdGhSYXRlU2FtcGxlcyA9IFtdO1xudmFyIGNoYXJ0O1xuXG4vL0NvbmZpZ3VyZSB0aGUgY2hhcnRzXG5mdW5jdGlvbiBpbml0Q2hhcnQoZG9tRWxlbWVudCkge1xuICAgIGNoYXJ0ID0gbmV3IEFtQ2hhcnRzLkFtU2VyaWFsQ2hhcnQoKTtcblxuICAgIGNoYXJ0Lm1hcmdpblRvcCA9IDIwO1xuICAgIGNoYXJ0Lm1hcmdpblJpZ2h0ID0gMTA7XG4gICAgY2hhcnQuYXV0b01hcmdpbk9mZnNldCA9IDU7XG4gICAgY2hhcnQuZGF0YVByb3ZpZGVyID0gYnJlYXRoUmF0ZVNhbXBsZXM7XG4gICAgY2hhcnQuY2F0ZWdvcnlGaWVsZCA9IFwidGltZXN0YW1wXCI7XG5cbiAgICAvL1ggQXhpc1xuICAgIHZhciBjYXRlZ29yeUF4aXMgPSBjaGFydC5jYXRlZ29yeUF4aXM7XG4gICAgY2F0ZWdvcnlBeGlzLmRhc2hMZW5ndGggPSAxO1xuICAgIGNhdGVnb3J5QXhpcy5ncmlkQWxwaGEgPSAwLjEwXG4gICAgY2F0ZWdvcnlBeGlzLmF4aXNDb2xvciA9IFwiI0RBREFEQVwiO1xuICAgIGNhdGVnb3J5QXhpcy5hdXRvR3JpZENvdW50ID0gZmFsc2U7XG4gICAgY2F0ZWdvcnlBeGlzLmdyaWRDb3VudCA9IDE1O1xuICAgIGNhdGVnb3J5QXhpcy5mb3JjZVNob3dGaWVsZCA9IFwiZm9yY2VTaG93XCI7XG4gICAgLy9jYXRlZ29yeUF4aXMudGl0bGUgPSBcIlNlY29uZHNcIjtcblxuICAgIC8vSGlkZSBldmVyeSBsYWJlbCB0aGF0IGlzIG5vdCBleHBsaWNpdGx5IHNob3duXG4gICAgY2F0ZWdvcnlBeGlzLmxhYmVsRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZVRleHQsIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LmZvcmNlU2hvdykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVGV4dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1kgQXhpc1xuICAgIHZhciB2YWx1ZUF4aXMgPSBuZXcgQW1DaGFydHMuVmFsdWVBeGlzKCk7XG4gICAgdmFsdWVBeGlzLmF4aXNBbHBoYSA9IDAuMjtcbiAgICB2YWx1ZUF4aXMuZGFzaExlbmd0aCA9IDE7XG4gICAgdmFsdWVBeGlzLm1pbmltdW0gPSBsb3dWb2x1bWU7XG4gICAgdmFsdWVBeGlzLm1heGltdW0gPSBoaWdoVm9sdW1lICogMS4xO1xuICAgIHZhbHVlQXhpcy50aXRsZSA9IFwiTHVuZ2V2b2x1bSAobWwpXCI7XG4gICAgY2hhcnQuYWRkVmFsdWVBeGlzKHZhbHVlQXhpcyk7XG5cbiAgICAvL0xpbmVcbiAgICB2YXIgZ3JhcGggPSBuZXcgQW1DaGFydHMuQW1HcmFwaCgpO1xuICAgIGdyYXBoLnR5cGUgPSBcInNtb290aGVkTGluZVwiO1xuICAgIGdyYXBoLnZhbHVlRmllbGQgPSBcInZvbHVtZVwiO1xuICAgIGdyYXBoLmxpbmVUaGlja25lc3MgPSAxLjU7XG4gICAgZ3JhcGgubGluZUNvbG9yID0gXCIjYjUwMzBkXCI7XG4gICAgY2hhcnQuYWRkR3JhcGgoZ3JhcGgpO1xuXG4gICAgY2hhcnQud3JpdGUoZG9tRWxlbWVudCk7XG59XG5cbnZhciBicmVhdGhSYXRlQnVmZmVyO1xudmFyIGJyZWF0aFJhdGVCdWZmZXJJbmRleDtcbnZhciBtc1VudGlsTmV4dEJyZWF0aFJhdGVCdWZmZXJGcmFtZTtcblxuLy9GaWxscyB0aGUgYnJlYXRoIHJhdGUgYnVmZmVyIHdpdGggc2FtcGxlcyBmcm9tIHRoZSBzcGVjaWZpZWQgcmFuZ2Vcbi8vVGhlIGJyZWF0aCByYXRlIGJ1ZmZlciBjb250YWlucyB0d2ljZSBhcyBtYW55IHNhbXBsZXMgYXMgdGhlIGJyZWF0aCByYXRlIGNoYXJ0IGFuZCBpcyB1c2VkIHRvIGFuaW1hdGUgdGhlIGNoYXJ0XG5mdW5jdGlvbiBjcmVhdGVCcmVhdGhSYXRlU2FtcGxlcyhtaW4sIG1heCkge1xuICAgIGJyZWF0aFJhdGVCdWZmZXIgPSBbXTtcbiAgICBicmVhdGhSYXRlQnVmZmVySW5kZXggPSAwO1xuICAgIG1zVW50aWxOZXh0QnJlYXRoUmF0ZUJ1ZmZlckZyYW1lID0gMDtcblxuICAgIHZhciBicmVhdGhzUGVyTWludXRlID0gcmFuZG9tSW50KG1pbiwgbWF4KTtcbiAgICB2YXIgbXNCZXR3ZWVuQnJlYXRocyA9IDYwICogMTAwMCAvIGJyZWF0aHNQZXJNaW51dGU7XG4gICAgdmFyIG1zVW50aWxOZXh0QnJlYXRoID0gbXNCZXR3ZWVuQnJlYXRocztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDEyMDsgaSsrKSB7XG4gICAgICAgIHZhciBsdW5nVm9sdW1lO1xuXG4gICAgICAgIGlmIChtc1VudGlsTmV4dEJyZWF0aCA8PSAwKSB7XG4gICAgICAgICAgICBsdW5nVm9sdW1lID0gaGlnaFZvbHVtZTtcbiAgICAgICAgICAgIG1zVW50aWxOZXh0QnJlYXRoID0gbXNCZXR3ZWVuQnJlYXRocztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGx1bmdWb2x1bWUgPSBsb3dWb2x1bWUgKiAxLjA1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UaGUgcmVzb2x1dGlvbiBvZiB0aGUgY2hhcnQgaXMgdHdvIHNhbXBsZXMgcGVyIHNlY29uZFxuICAgICAgICBicmVhdGhSYXRlQnVmZmVyLnB1c2goe3RpbWVzdGFtcDogaSAvIDIsIHZvbHVtZTogbHVuZ1ZvbHVtZX0pO1xuICAgICAgICBtc1VudGlsTmV4dEJyZWF0aCAtPSA1MDA7XG4gICAgfVxufVxuXG52YXIgY2hhcnRVcGRhdGVyO1xuXG4vL0FuaW1hdGVzIHRoZSBicmVhdGggcmF0ZSBhbmQgaGVhcnQgcmF0ZSBjaGFydHNcbmZ1bmN0aW9uIHN0YXJ0RXZlbnRMb29wKCkge1xuICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZhciBtc1NpbmNlTGFzdFVwZGF0ZSA9IDA7XG4gICAgdmFyIG1zU2luY2VTdGFydCA9IDA7XG4gICAgdmFyIHVwZGF0ZUZyZXF1ZW5jeSA9IDQwMDtcbiAgICBzdG9wRXZlbnRMb29wKCk7XG5cbiAgICBjaGFydFVwZGF0ZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgbXNTaW5jZUxhc3RVcGRhdGUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lIC0gbXNTaW5jZVN0YXJ0O1xuICAgICAgICBtc1VudGlsTmV4dEJyZWF0aFJhdGVCdWZmZXJGcmFtZSAtPSBtc1NpbmNlTGFzdFVwZGF0ZTtcbiAgICAgICAgbXNTaW5jZVN0YXJ0ID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICBpZiAobXNVbnRpbE5leHRCcmVhdGhSYXRlQnVmZmVyRnJhbWUgPD0gMCkge1xuICAgICAgICAgICAgdmFyIGZyYW1lc01pc3NlZCA9IE1hdGguZmxvb3IoKG1zVW50aWxOZXh0QnJlYXRoUmF0ZUJ1ZmZlckZyYW1lICogLTEpIC8gNTAwICsgMSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzTWlzc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBicmVhdGhSYXRlQnVmZmVySW5kZXgrKztcblxuICAgICAgICAgICAgICAgIGlmIChicmVhdGhSYXRlQnVmZmVySW5kZXggPj0gYnJlYXRoUmF0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYXRoUmF0ZUJ1ZmZlckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhdGhSYXRlU2FtcGxlcy5wdXNoKGJyZWF0aFJhdGVCdWZmZXJbYnJlYXRoUmF0ZUJ1ZmZlckluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICAvL1doZW4gdGhlIGNoYXJ0IGdyb3dzIHRvIDMwIHNlY29uZHMsIHN0YXJ0IGN1dHRpbmcgb2ZmIHRoZSBvbGRlc3Qgc2FtcGxlIHRvIGdpdmUgdGhlIGNoYXJ0IGEgc2xpZGluZyBlZmZlY3RcbiAgICAgICAgICAgICAgICBpZiAoYnJlYXRoUmF0ZVNhbXBsZXMubGVuZ3RoID4gNjApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYXRoUmF0ZVNhbXBsZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1zVW50aWxOZXh0QnJlYXRoUmF0ZUJ1ZmZlckZyYW1lID0gMjUwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9BbHdheXMgc2hvdyBmcm9tIDAgdG8gMzAgc2Vjb25kcyBvbiB0aGUgWCBheGlzXG4gICAgICAgIGlmIChicmVhdGhSYXRlU2FtcGxlcy5sZW5ndGggPj0gNjApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJlYXRoUmF0ZVNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBicmVhdGhSYXRlU2FtcGxlc1tpXS50aW1lc3RhbXAgPSBNYXRoLmZsb29yKGkgLyAoYnJlYXRoUmF0ZVNhbXBsZXMubGVuZ3RoIC0gMSkgKiAzMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL09ubHkgc2hvdyBldmVyeSA1dGggdGltZXN0YW1wXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJlYXRoUmF0ZVNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJyZWF0aFJhdGVTYW1wbGVzW2ldLmZvcmNlU2hvdyA9IGJyZWF0aFJhdGVTYW1wbGVzW2ldLnRpbWVzdGFtcCAlIDUgPT0gMCAmJiAoaSA9PSAwIHx8IGJyZWF0aFJhdGVTYW1wbGVzW2kgLSAxXS50aW1lc3RhbXAgJSA1ICE9IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnQudmFsaWRhdGVEYXRhKCk7XG4gICAgfSwgdXBkYXRlRnJlcXVlbmN5KTtcbn1cblxuZnVuY3Rpb24gc3RvcEV2ZW50TG9vcCgpIHtcbiAgICBjbGVhckludGVydmFsKGNoYXJ0VXBkYXRlcik7XG4gICAgYnJlYXRoUmF0ZVNhbXBsZXMubGVuZ3RoID0gMDtcbiAgICBjaGFydC52YWxpZGF0ZURhdGEoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBzdGF0aWNzOiB7fSxcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBoZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgd2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXSxcblxuICAgIGdldEluaXRpYWxTdGF0ZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2hhcnRTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoYXJ0KCk7XG4gICAgICAgIEJyZWF0aFJhdGVTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcigoKSA9PiB0aGlzLl91cGRhdGVDaGFydCgpKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBlbCA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBpbml0Q2hhcnQoZWwpO1xuICAgICAgICBzdGFydEV2ZW50TG9vcCgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgY2hhcnQgJiYgY2hhcnQuY2xlYXIoKTtcbiAgICAgICAgc3RvcEV2ZW50TG9vcCgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVbm1vdW50KCkge1xuICAgICAgICBjaGFydCA9IG51bGw7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB9LFxuXG4gICAgLy8gdGhpcyBjaGFydCBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBpdHNlbGZcbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgX3VwZGF0ZUNoYXJ0KCl7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fZ2V0Q2hhcnRTdGF0ZSgpKTtcbiAgICAgICAgY3JlYXRlQnJlYXRoUmF0ZVNhbXBsZXModGhpcy5zdGF0ZS5taW4sIHRoaXMuc3RhdGUubWF4KTtcbiAgICB9LFxuXG4gICAgX2dldENoYXJ0U3RhdGUoKXtcbiAgICAgICAgcmV0dXJuIEJyZWF0aFJhdGVTdG9yZS5nZXRTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfb25DaGFuZ2UoKXtcblxuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgLy8gaWYgeW91IGRvbid0IHNwZWNpZnkgd2lkdGggaXQgd2lsbCBtYXggb3V0IHRvIDEwMCUgKHdoaWNoIGlzIG9rKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7d2lkdGg6IHRoaXMucHJvcHMud2lkdGggKyAncHgnLCBoZWlnaHQgOiB0aGlzLnByb3BzLmhlaWdodCsgJ3B4J319XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICApO1xuICAgIH1cblxufSk7XG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBPeHlnZW5TdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9veHlnZW4tc3RvcmUnKTtcbmNvbnN0IHsgcGFyc2VOdW1iZXIgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCB7IHJhbmRvbUludCB9ID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IE1pc3Npb25TdGF0ZVN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL21pc3Npb24tc3RhdGUtc3RvcmUnKTtcblxuLy8gbGF6eSBsb2FkIGR1ZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbmZ1bmN0aW9uIGxhenlSZXF1aXJlKHBhdGgpIHtcbiAgICBsZXQgdG1wID0gbnVsbDtcbiAgICByZXR1cm4gKCk9PiB7XG4gICAgICAgIGlmICghdG1wKSB0bXAgPSByZXF1aXJlKHBhdGgpO1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgIH1cbn1cbmNvbnN0IGdldE1pc3Npb25BQyA9IGxhenlSZXF1aXJlKCcuLi9hY3Rpb25zL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuLy8gZm9yIGJyb3dzZXJpZnkgdG8gd29yayBpdCBuZWVkcyB0byBmaW5kIHRoZXNlIG1hZ2ljIHN0cmluZ3NcbnJlcXVpcmUoJy4uL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBsb3dUaHJlc2hvbGQgPSAzMCwgbWVkaXVtVGhyZXNob2xkID0gNzA7XG5cbnZhciBzYXRlbGxpdGVzID0gW1xuICAgIHtuYW1lOiAnU2F0ZWxpdHQgMScsIGZyZXE6IHttaW46IDIuOCwgbWF4OiAzLjR9LCByZWNlcHRpb246IDkwLCBjb2xvcjogJ2dyZWVuJ30sXG4gICAge25hbWU6ICdTYXRlbGl0dCAyJywgZnJlcToge21pbjogMi4xLCBtYXg6IDIuNX0sIHJlY2VwdGlvbjogMzAsIGNvbG9yOiAncmVkJ30sXG4gICAge25hbWU6ICdTYXRlbGl0dCAzJywgZnJlcToge21pbjogMy42LCBtYXg6IDQuMH0sIHJlY2VwdGlvbjogNjAsIGNvbG9yOiAnb3JhbmdlJ31cbl07XG5cbmZ1bmN0aW9uIGNvbG9yKHJlY2VwdGlvbikge1xuICAgIGlmIChyZWNlcHRpb24gPiBtZWRpdW1UaHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuICdncmVlbic7XG4gICAgfVxuICAgIGlmIChyZWNlcHRpb24gPiBsb3dUaHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuICdvcmFuZ2UnO1xuICAgIH1cbiAgICByZXR1cm4gJ3JlZCc7XG59XG5cbnZhciBpPTA7XG5mdW5jdGlvbiBuZXdWYWx1ZXMoKXtcbiAgICBzYXRlbGxpdGVzWyhpKzApJTNdLnJlY2VwdGlvbiA9IHJhbmRvbUludCgyNSw2NSk7XG4gICAgc2F0ZWxsaXRlc1soaSsxKSUzXS5yZWNlcHRpb24gPSByYW5kb21JbnQoNDUsODUpO1xuICAgIHNhdGVsbGl0ZXNbKGkrMiklM10ucmVjZXB0aW9uID0gcmFuZG9tSW50KDI1LDY1KTtcbiAgICBpKys7XG5cbiAgICBjaGFydCAmJiBjaGFydC52YWxpZGF0ZURhdGEoKTtcbn1cblxudmFyIGN1cnJlbnRDaGFwdGVyO1xuXG5NaXNzaW9uU3RhdGVTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcigoKSA9PntcbiAgICB2YXIgaXNOZXdDaGFwdGVyID0gKGN1cnJlbnRDaGFwdGVyICE9PSBNaXNzaW9uU3RhdGVTdG9yZS5jdXJyZW50Q2hhcHRlcigpKTtcbiAgICBjdXJyZW50Q2hhcHRlciA9IE1pc3Npb25TdGF0ZVN0b3JlLmN1cnJlbnRDaGFwdGVyKCk7XG5cbiAgICBpZihpc05ld0NoYXB0ZXIgJiYgY3VycmVudENoYXB0ZXIgIT09IDMpIHtcbiAgICAgICAgbmV3VmFsdWVzKCk7XG4gICAgfVxufSk7XG5cbnZhciBjaGFydDtcbmZ1bmN0aW9uIGluaXRHcmFwaChkb21FbGVtZW50KSB7XG4gICAgY2hhcnQgPSBuZXcgQW1DaGFydHMuQW1TZXJpYWxDaGFydCgpO1xuXG4gICAgY2hhcnQuZGF0YVByb3ZpZGVyID0gc2F0ZWxsaXRlcztcbiAgICBjaGFydC5jYXRlZ29yeUZpZWxkID0gXCJuYW1lXCI7XG5cbiAgICAvL1ggYXhpc1xuICAgIHZhciBjYXRlZ29yeUF4aXMgPSBjaGFydC5jYXRlZ29yeUF4aXM7XG4gICAgY2F0ZWdvcnlBeGlzLmdyaWRQb3NpdGlvbiA9IFwic3RhcnRcIjtcblxuICAgIC8vWSBheGlzXG4gICAgdmFyIHZhbHVlQXhpcyA9IG5ldyBBbUNoYXJ0cy5WYWx1ZUF4aXMoKTtcbiAgICB2YWx1ZUF4aXMuYXhpc0FscGhhID0gMDtcbiAgICB2YWx1ZUF4aXMubWluaW11bSA9IDA7XG4gICAgdmFsdWVBeGlzLm1heGltdW0gPSAxMDA7XG4gICAgdmFsdWVBeGlzLnRpdGxlID0gXCJNb3R0YWtcIjtcbiAgICB2YWx1ZUF4aXMucG9zaXRpb24gPSBcImxlZnRcIjtcbiAgICBjaGFydC5hZGRWYWx1ZUF4aXModmFsdWVBeGlzKTtcblxuICAgIC8vTGluZVxuICAgIHZhciBncmFwaCA9IG5ldyBBbUNoYXJ0cy5BbUdyYXBoKCk7XG4gICAgZ3JhcGgudmFsdWVGaWVsZCA9IFwicmVjZXB0aW9uXCI7XG4gICAgZ3JhcGguY29sb3JGaWVsZCA9IFwiY29sb3JcIjtcbiAgICBncmFwaC5saW5lQWxwaGEgPSAwLjI7XG4gICAgZ3JhcGguZmlsbEFscGhhcyA9IDAuODtcbiAgICBncmFwaC50eXBlID0gXCJjb2x1bW5cIjtcbiAgICBncmFwaC5zaG93QmFsbG9vbiA9IGZhbHNlO1xuICAgIGNoYXJ0LmFkZEdyYXBoKGdyYXBoKTtcblxuICAgIGNoYXJ0LndyaXRlKGRvbUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufVxuXG5jb25zdCBTYXRlbGxpdGVSZWNlcHRpb25DaGFydCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge30sXG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpe1xuICAgICAgICB2YXIgZWwgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaW5pdEdyYXBoKGVsKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCl7XG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9IHN0eWxlPXt0aGlzLnByb3BzLnN0eWxlfS8+XG4gICAgfVxuXG59KTtcblxuY29uc3QgU2F0ZWxsaXRlVGFibGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgc2F0ZWxsaXRlczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbiAgICB9LFxuXG5cbiAgICByZW5kZXIoKXtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiB7Li4udGhpcy5wcm9wc30gPlxuXG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT17XCJ0YWJsZSB0YWJsZS1ib3JkZXJlZCB0YWJsZS1zdHJpcGVkIFwifT5cbiAgICAgICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+U2F0ZWxpdHQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkZyZWt2ZW5zb21yw6VkZTwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG5cbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnNhdGVsbGl0ZXMubWFwKChzYXQsIGkpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGtleT17aX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57c2F0Lm5hbWV9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntzYXQuZnJlcS5taW59IC0ge3NhdC5mcmVxLm1heH08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBzdGF0aWNzOiB7fSxcblxuICAgIHByb3BUeXBlczoge30sXG5cbiAgICBtaXhpbnM6IFtdLFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hvc2VuU2F0ZWxsaXRlOiBzYXRlbGxpdGVzWzBdXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIH0sXG5cbiAgICBfZ2V0U3RhdGUoKXtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncm93Jz5cbiAgICAgICAgICAgICAgICAgICAgPFNhdGVsbGl0ZVRhYmxlIHNhdGVsbGl0ZXM9e3NhdGVsbGl0ZXN9IGNsYXNzTmFtZT0nY29sLXNtLTYnLz5cblxuICAgICAgICAgICAgICAgICAgICA8U2F0ZWxsaXRlUmVjZXB0aW9uQ2hhcnQgc3R5bGU9e3sgaGVpZ2h0IDogJzI1MHB4J319IGNsYXNzTmFtZT0nY29sLXNtLTYnLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgIDxoMz5WZWxnIHNhdGVsaXR0IG9nIHRpbGjDuHJlbmRlIGZyZWt2ZW5zb21yw6VkZTwvaDM+XG4gICAgICAgICAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICB7IHNhdGVsbGl0ZXMubWFwKChzYXQpID0+ICA8b3B0aW9uIGtleT17c2F0Lm5hbWV9IHZhbHVlPXtzYXQubmFtZX0+e3NhdC5uYW1lfTwvb3B0aW9uPikgfVxuICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cblxuICAgICAgICAgICAgICAgICAgICA8aDQ+VmVsZyBmcmVrdmVuczo8L2g0PlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0nbnVtYmVyJyAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8L2Rpdj4gKTtcblxuICAgIH1cblxufSk7XG5cbiIsIi8vIG5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBlcnJvclxuY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzY2llbmNlX2ludHJvOiA8ZGl2PlxuICAgICAgICA8cD5cbiAgICAgICAgICAgIERlcmUgc2thbCBvdmVydsOla2Ugc3Ryw6VsaW5nc25pdsOlZXQgYXN0cm9uYXR1ZW4gdXRzZXR0ZXMgZm9yLlxuICAgICAgICAgICAgRGVyZSBtw6UgZGEgcGFzc2UgcMOlIGF0IGFzdHJvbmF1dGVuIGlra2UgYmxpciB1dHNhdHRcbiAgICAgICAgICAgIGZvciBzdHLDpWxpbmdzbml2w6VlciBzb20gZXIgc2thZGVsaWcuXG4gICAgICAgIDwvcD5cblxuICAgICAgICA8cD5WZWQgaGplbHAgYXYgaW5zdHJ1bWVudGVuZSBzb20gZXIgdGlsZ2plbmdlbGlnIG3DpSBkZXJlIGpldm5saWdcbiAgICAgICAgICAgIHRhIHByw7h2ZXIgb2cgcmVnbmUgdXQgdmVyZGllbmUgZm9yIGdqZW5ub21zbml0dGxpZyBvZyB0b3RhbHRcbiAgICAgICAgICAgIHN0csOlbGluZ3NuaXbDpS4gRmlubmVyIGRlcmUgdXQgYXQgbml2w6VlbmUgZXIgYmxpdHQgZmFybGlnXG4gICAgICAgICAgICBow7h5ZSA8ZW0+bcOlPC9lbT4gZGVyZSBzaSBmcmEgdGlsIG9wcGRyYWdzbGVkZXJlbiBzw6Ugdmkga2FuXG4gICAgICAgICAgICBmw6UgdXQgYXN0cm9uYXV0ZW4hXG4gICAgICAgIDwvcD5cblxuXG4gICAgICAgIDxwPlxuICAgICAgICAgICAgRXIgb3BwZHJhZ2V0IGZvcnN0w6V0dD9cbiAgICAgICAgPC9wPlxuICAgIDwvZGl2PixcblxuICAgIGFzdHJvbmF1dF9pbnRybzogPGRpdj5cbiAgICAgICAgPHA+XG4gICAgICAgICAgICBEZXJlcyBqb2JiIGVyIMOlIHNpa3JlIGF0IGRldCBlciBub2sgb2tzeWdlbiBmb3Igw6UgZ2plbm5vbWbDuHJlIG9wcGRyYWdldC4gSGVyIGVyIGRldCB2aWt0aWcgw6UgamV2bmxpZ1xuICAgICAgICAgICAgc2pla2tlIGh2b3IgZm9ydCBhc3Ryb25hdXQgU3RlaWdlbiBwdXN0ZXIgb2cgaHZvciBmb3J0IGhqZXJ0ZXQgaGVubmVzIHNsw6VyLlxuICAgICAgICA8L3A+XG5cbiAgICAgICAgPHA+RmlubmVyIGRlcmUgdXQgYXQgYXN0cm9uYXV0IFN0ZWlnZW4gaWtrZSB2aWwgaGEgbm9rIGx1ZnQgdGlsXG4gICAgICAgICAgICDDpSBnamVubm9tZsO4cmUgb3BwZHJhZ2V0IDxlbT5tw6U8L2VtPiBkZXJlIHNpIGZyYSB0aWxcbiAgICAgICAgICAgIG9wcGRyYWdzbGVkZXJlbiBzw6Ugdmkga2FuIGF2YnJ5dGUgaSB0aWRlLlxuICAgICAgICA8L3A+XG4gICAgPC9kaXY+LFxuXG4gICAgY29tbXVuaWNhdGlvbl9pbnRybzogPGRpdj5cbiAgICAgICAgPHA+RGVyZXMgbcOlbCBlciDDpSBob2xkZSBrb21tdW5pa2Fzam9uZW4gb3BwZSwgb2cga29tbXVuaXNlcmUgbWVkIG9wcGRyYWdza29vcmRpbmF0b3Igb2cgYXN0cm9uYXV0ZW4uIE9tXG4gICAgICAgICAgICBuw7hkdmVuZGlnIG3DpSBkZXJlIGthbnNramUgYnl0dGUgdGlsIGVuIGFubmVuIGtvbW11bmlrYXNqb25zc2F0ZWxpdHQuXG4gICAgICAgIDwvcD5cblxuICAgICAgICA8cD5EZXJlIHNrYWwgb2dzw6UgaW5mb3JtZXJlIGFzdHJvbmF1dGVuIG9tIGV2ZW50dWVsbGUgYmVza2plZGVyIGZyYSBBbmRhw7h5YSBTcGFjZSBDZW50ZXIgKEFTQyksIG9nXG4gICAgICAgICAgICBsaWtlbGVkZXMgaW5mb3JtZXJlIEFTQyBvbSBoZW5kZWxzZXIgZWxsZXIgYmVza2plZGVyIGZyYSBhc3Ryb25hdXRlbi48L3A+XG5cbiAgICA8L2Rpdj4sXG5cbiAgICBzZWN1cml0eV9pbnRybzogPGRpdj5cbiAgICAgICAgPHA+XG4gICAgICAgICAgICBEZXJlcyBob3ZlZG9wcGdhdmUgZXIgw6UgaW5uaGVudGUgaW5mb3JtYXNqb24gZnJhIGRlIGZvcnNramVsbGlnZSBncnVwcGVuZSBvZyBiZXN0ZW1tZSBkZXJlIGZvciBodmFcbiAgICAgICAgICAgIHNvbSBza2FsIGdqw7hyZXMuIEhlciBtw6UgZGVyZSBzYW1hcmJlaWRlIGdvZHQgbWVkIG9wcGRyYWdza29vcmRpbmF0b3JlbiAoPGVtPm1pc3Npb24gY29tbWFuZGVyPC9lbT4pIVxuICAgICAgICA8L3A+XG5cbiAgICAgICAgPHA+XG4gICAgICAgICAgICBEZXJlIG3DpSBvZ3PDpSBob2xkZSBldCDDuHllIHDDpSBpbmRpa2F0b3JlbiBzb20gc2llciBvbSBkZXQgZXIgbm9rIGx1ZnQgdGlsIMOlIGdqZW5ub21mw7hyZSBvcHBkcmFnZXQsIHNhbXRcbiAgICAgICAgICAgIHNqZWtrZSBvbSBrYXJib25kaW9rc2lkc2tydWJiZXJlbiBtw6Ugc2tpZnRlcyBzbGlrIGF0IGFzdHJvbmF1dGVuIGlra2Uga3ZlbGVzLlxuICAgICAgICA8L3A+XG5cbiAgICAgICAgPHA+XG4gICAgICAgICAgICBEZXJlcyBtw6Ugb2dzw6Ugc2pla2tlIGF0IGtvbW11bmlrYXNqb25zc3RhdHVzZW4gb2cgZGF0YWt2YWxpdGV0ZW4gZXIgZ29kIG7DpXIgcmVwYXJhc2pvbmVuIGVyIHV0ZsO4cnQuXG4gICAgICAgIDwvcD5cbiAgICA8L2Rpdj5cblxuXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlbmRlcigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RVTU1ZX1JFTkRFUi4gVGhpcyByZWFjdCBjb21wb25lbnQgaXMgbm90IGZvciBwcmVzZW50YXRpb25hbCBwdXJwb3NlcycpO1xuICAgIH1cbn07XG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBwbGF5ZXI7XG5mdW5jdGlvbiBvbllvdVR1YmVJZnJhbWVBUElSZWFkeSgpIHtcbiAgICBjb25zb2xlLmxvZygnb25Zb3VUdWJlSWZyYW1lQVBJUmVhZHknKTtcbiAgICBwbGF5ZXIgPSBuZXcgWVQuUGxheWVyKCdwbGF5ZXInLCB7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgJ29uUmVhZHknOiBvblBsYXllclJlYWR5XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGxheVZpZGVvKCl7XG4gICAgcGxheWVyLnNlZWtUbyg5Nik7XG4gICAgcGxheWVyLnBsYXlWaWRlbygpO1xuXG4gICAgLy8gc3RvcCB2aWRlbyBhZnRlciB0ZW4gc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwbGF5ZXIuc3RvcFZpZGVvKHBsYXllcilcbiAgICAgICAgcGxheVZpZGVvKCk7XG4gICAgfSwxMEUzKTtcbn1cblxuZnVuY3Rpb24gb25QbGF5ZXJSZWFkeShldmVudCkge1xuICAgIC8vZXZlbnQudGFyZ2V0Lm11dGUoKTtcbiAgICBwbGF5ZXIubXV0ZSgpO1xuICAgIHBsYXlWaWRlbygpO1xufVxuXG5cbndpbmRvdy5vbllvdVR1YmVJZnJhbWVBUElSZWFkeSA9IG9uWW91VHViZUlmcmFtZUFQSVJlYWR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIC8qIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvaWZyYW1lX2FwaV9yZWZlcmVuY2UjR2V0dGluZ19TdGFydGVkICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgICAgICAgdGFnLnNyYyA9IFwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vaWZyYW1lX2FwaVwiO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHJpY2tSb2xsZWQgPSAnaHR0cDovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9vSGc1U0pZUkhBMD9hdXRvcGxheT0xJztcbiAgICAgICAgdmFyIG9yaWdpbiA9IGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3RcbiAgICAgICAgdmFyIHNvbGFyU3Rvcm0gPSAnaHR0cDovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9EVTRocHNpc3REaz8mc3RhcnQ9OTYmZW5hYmxlanNhcGk9MSZvcmlnaW49JyArIG9yaWdpbjtcbiAgICAgICAgdmFyIHZpZGVvID0gc29sYXJTdG9ybTtcblxuICAgICAgICAvL3JldHVybiA8ZGl2IC8+XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIDxpZnJhbWUgaWQ9J3BsYXllcidcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgcG9zaXRpb246J2Fic29sdXRlJywgdG9wOiAwLCByaWdodDogMCwgd2lkdGg6XCIxMDAlXCIsIGhlaWdodDpcIjEwMCVcIn19XG4gICAgICAgICAgICAgICAgICAgIHNyYz17dmlkZW99XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lQm9yZGVyPVwiMFwiIGFsbG93RnVsbFNjcmVlbiAvPlxuICAgICAgICApO1xuICAgIH1cblxufSk7IiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgUm91dGVyID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyk7XG5jb25zdCBMaW5rID0gUm91dGVyLkxpbms7XG5cbnZhciBIZWFkZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdyb3cnPlxuXG4gICAgICAgICAgICAgICAgICAgIDxoZWFkZXIgaWQ9J25hcm9tLWhlYWRlcicgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzTmFtZSA9ICduYXJvbS1sb2dvLWltZycgIHNyYz0nL2ltYWdlcy9sb2dvLnBuZycgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOQVJPTSBlLU1pc3Npb24gcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9oZWFkZXI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPSdtYWluLWhlYWRlcicgY2xhc3NOYW1lPSdyb3cnID5cbiAgICAgICAgICAgICAgICAgICAgPExpbmsgdG89Jy8nID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoZWFkZXIgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMSBjbGFzc05hbWUgPSAnJz5VbmRlciBlbiBzb2xzdG9ybTwvaDE+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXI7IiwiLyoqXG4gKiBUSElTIERFU0lHTiBPTkxZIFNVUFBPUlRTIE9ORSBDSEFSVCBBUyBUSEVZICpTSEFSRSogU1RBVEVcbiAqIEZvciBhIG5vbi1zdHVwaWQgZGVzaWduLCBkbyBzb21ldGhpbmcgbGlrZSB0aGVcbiAqIGltcGxlbWVudGF0aW9uIGluIHRoZSBhcnRpY2xlIGJ5IE5pY29sYXMgSGVyeTpcbiAqIGh0dHA6Ly9uaWNvbGFzaGVyeS5jb20vaW50ZWdyYXRpbmctZDNqcy12aXN1YWxpemF0aW9ucy1pbi1hLXJlYWN0LWFwcFxuICpcbiAqIENoYXJ0IGNvZGUgbW9yZSBvciBsZXNzIGNvcGllZCBmcm9tIHRoZSBwcm90b3R5cGUgYnkgTGVvIE1hcnRpbiBXZXN0YnlcbiAqL1xuY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgQW1DaGFydHMgPSByZXF1aXJlKCdhbWNoYXJ0cycpO1xuY29uc3QgeyByYW5kb21JbnQgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBIZWFydFN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL2hlYXJ0LXJhdGUtc3RvcmUnKTtcblxudmFyIGNoYXJ0O1xudmFyIGhlYXJ0UmF0ZVNhbXBsZXMgPSBbXTtcblxudmFyIGhlYXJ0UmF0ZUJ1ZmZlcjtcbnZhciBoZWFydFJhdGVCdWZmZXJJbmRleDtcbnZhciBtc1VudGlsTmV4dEhlYXJ0UmF0ZUJ1ZmZlckZyYW1lO1xuXG4vL01pbGxpdm9sdHMgZGlzcGxheWVkIG9uIHRoZSBZIGF4aXMgb2YgdGhlIEVDRyBncmFwaFxudmFyIGhpZ2hNViA9IDE7XG52YXIgbG93TVYgPSAwO1xuXG52YXIgY2hhcnRVcGRhdGVyO1xuXG5mdW5jdGlvbiBpbml0Q2hhcnQoZG9tRWxlbWVudCkge1xuXG4gICAgY2hhcnQgPSBuZXcgQW1DaGFydHMuQW1TZXJpYWxDaGFydCgpO1xuXG4gICAgY2hhcnQubWFyZ2luVG9wID0gMjA7XG4gICAgY2hhcnQubWFyZ2luUmlnaHQgPSAxMDtcbiAgICBjaGFydC5hdXRvTWFyZ2luT2Zmc2V0ID0gNTtcbiAgICBjaGFydC5kYXRhUHJvdmlkZXIgPSBoZWFydFJhdGVTYW1wbGVzO1xuICAgIGNoYXJ0LmNhdGVnb3J5RmllbGQgPSBcInRpbWVzdGFtcFwiO1xuXG4gICAgLy9YIEF4aXNcbiAgICB2YXIgY2F0ZWdvcnlBeGlzID0gY2hhcnQuY2F0ZWdvcnlBeGlzO1xuICAgIGNhdGVnb3J5QXhpcy5kYXNoTGVuZ3RoID0gMTtcbiAgICBjYXRlZ29yeUF4aXMuZ3JpZEFscGhhID0gMC4xMDtcbiAgICBjYXRlZ29yeUF4aXMuYXhpc0NvbG9yID0gXCIjREFEQURBXCI7XG4gICAgY2F0ZWdvcnlBeGlzLmZvcmNlU2hvd0ZpZWxkID0gXCJmb3JjZVNob3dcIjtcbiAgICAvL2NhdGVnb3J5QXhpcy50aXRsZSA9IFwiU2Vjb25kc1wiO1xuXG4gICAgLy9IaWRlIGV2ZXJ5IGxhYmVsIHRoYXQgaXMgbm90IGV4cGxpY2l0bHkgc2hvd25cbiAgICBjYXRlZ29yeUF4aXMubGFiZWxGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZVRleHQsIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LmZvcmNlU2hvdykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVGV4dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1kgQXhpc1xuICAgIHZhciB2YWx1ZUF4aXMgPSBuZXcgQW1DaGFydHMuVmFsdWVBeGlzKCk7XG4gICAgdmFsdWVBeGlzLmF4aXNBbHBoYSA9IDAuMjtcbiAgICB2YWx1ZUF4aXMuZGFzaExlbmd0aCA9IDE7XG4gICAgdmFsdWVBeGlzLm1pbmltdW0gPSBsb3dNVjtcbiAgICB2YWx1ZUF4aXMubWF4aW11bSA9IGhpZ2hNViAqIDEuMTtcbiAgICB2YWx1ZUF4aXMudGl0bGUgPSBcIm1WXCI7XG4gICAgY2hhcnQuYWRkVmFsdWVBeGlzKHZhbHVlQXhpcyk7XG5cbiAgICAvL0xpbmVcbiAgICB2YXIgZ3JhcGggPSBuZXcgQW1DaGFydHMuQW1HcmFwaCgpO1xuXG4gICAgZ3JhcGgudmFsdWVGaWVsZCA9IFwibVZcIjtcbiAgICBncmFwaC50eXBlID0gXCJzbW9vdGhlZExpbmVcIjtcbiAgICBncmFwaC5saW5lVGhpY2tuZXNzID0gMTtcbiAgICBncmFwaC5saW5lQ29sb3IgPSBcIiNiNTAzMGRcIjtcbiAgICBjaGFydC5hZGRHcmFwaChncmFwaCk7XG5cbiAgICBjaGFydC53cml0ZShkb21FbGVtZW50KTtcbn1cblxuLy9GaWxscyB0aGUgaGVhcnQgcmF0ZSBidWZmZXIgd2l0aCBzYW1wbGVzIGZyb20gdGhlIHNwZWNpZmllZCByYW5nZVxuLy9UaGUgaGVhcnQgcmF0ZSBidWZmZXIgY29udGFpbnMgdHdpY2UgYXMgbWFueSBzYW1wbGVzIGFzIHRoZSBoZWFydCByYXRlIGNoYXJ0IGFuZCBpcyB1c2VkIHRvIGFuaW1hdGUgdGhlIGNoYXJ0XG5mdW5jdGlvbiBjcmVhdGVIZWFydFJhdGVTYW1wbGVzKG1pbiwgbWF4KSB7XG4gICAgaGVhcnRSYXRlQnVmZmVyID0gW107XG4gICAgaGVhcnRSYXRlQnVmZmVySW5kZXggPSAwO1xuICAgIG1zVW50aWxOZXh0SGVhcnRSYXRlQnVmZmVyRnJhbWUgPSAwO1xuXG4gICAgdmFyIGJlYXRzUGVyTWludXRlID0gcmFuZG9tSW50KG1pbiwgbWF4KTtcbiAgICB2YXIgbXNCZXR3ZWVuQmVhdHMgPSA2MCAqIDEwMDAgLyBiZWF0c1Blck1pbnV0ZTtcbiAgICB2YXIgbXNVbnRpbE5leHRCZWF0ID0gbXNCZXR3ZWVuQmVhdHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAyMDA7IGkrKykge1xuICAgICAgICB2YXIgbVY7XG5cbiAgICAgICAgaWYgKG1zVW50aWxOZXh0QmVhdCA8PSAwKSB7XG4gICAgICAgICAgICBtViA9IGhpZ2hNVjtcbiAgICAgICAgICAgIG1zVW50aWxOZXh0QmVhdCA9IG1zQmV0d2VlbkJlYXRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbVYgPSBNYXRoLnJhbmRvbSgpICogMC4yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UaGUgcmVzb2x1dGlvbiBvZiB0aGUgY2hhcnQgaXMgdGVuIHNhbXBsZXMgcGVyIHNlY29uZFxuICAgICAgICBoZWFydFJhdGVCdWZmZXIucHVzaCh7dGltZXN0YW1wOiBpIC8gMTAsIG1WOiBtVn0pO1xuICAgICAgICBtc1VudGlsTmV4dEJlYXQgLT0gNTA7XG4gICAgfVxufVxuXG4vL0FuaW1hdGVzIHRoZSAgaGVhcnQgcmF0ZSBjaGFydHNcbmZ1bmN0aW9uIHN0YXJ0RXZlbnRMb29wKCkge1xuICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZhciBtc1NpbmNlTGFzdFVwZGF0ZSA9IDA7XG4gICAgdmFyIG1zU2luY2VTdGFydCA9IDA7XG4gICAgdmFyIHVwZGF0ZUZyZXF1ZW5jeSA9IDQwMDtcbiAgICBzdG9wRXZlbnRMb29wKCk7XG5cbiAgICBjaGFydFVwZGF0ZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1zU2luY2VMYXN0VXBkYXRlID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSAtIG1zU2luY2VTdGFydDtcbiAgICAgICAgbXNVbnRpbE5leHRIZWFydFJhdGVCdWZmZXJGcmFtZSAtPSBtc1NpbmNlTGFzdFVwZGF0ZTtcbiAgICAgICAgbXNTaW5jZVN0YXJ0ID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICBpZiAobXNVbnRpbE5leHRIZWFydFJhdGVCdWZmZXJGcmFtZSA8PSAwKSB7XG4gICAgICAgICAgICB2YXIgZnJhbWVzTWlzc2VkID0gTWF0aC5mbG9vcigobXNVbnRpbE5leHRIZWFydFJhdGVCdWZmZXJGcmFtZSAqIC0xKSAvIDEwMCArIDEpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lc01pc3NlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGVhcnRSYXRlQnVmZmVySW5kZXgrKztcblxuICAgICAgICAgICAgICAgIGlmIChoZWFydFJhdGVCdWZmZXJJbmRleCA+PSBoZWFydFJhdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYXJ0UmF0ZUJ1ZmZlckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBoZWFydFJhdGVTYW1wbGVzLnB1c2goaGVhcnRSYXRlQnVmZmVyW2hlYXJ0UmF0ZUJ1ZmZlckluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICAvL1doZW4gdGhlIGNoYXJ0IGdyb3dzIHRvIDEwIHNlY29uZHMsIHN0YXJ0IGN1dHRpbmcgb2ZmIHRoZSBvbGRlc3Qgc2FtcGxlIHRvIGdpdmUgdGhlIGNoYXJ0IGEgc2xpZGluZyBlZmZlY3RcbiAgICAgICAgICAgICAgICBpZiAoaGVhcnRSYXRlU2FtcGxlcy5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhcnRSYXRlU2FtcGxlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXNVbnRpbE5leHRIZWFydFJhdGVCdWZmZXJGcmFtZSA9IDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQWx3YXlzIHNob3cgZnJvbSAwIHRvIDEwIHNlY29uZHMgb24gdGhlIFggYXhpc1xuICAgICAgICBpZiAoaGVhcnRSYXRlU2FtcGxlcy5sZW5ndGggPj0gMTAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYXJ0UmF0ZVNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBoZWFydFJhdGVTYW1wbGVzW2ldLnRpbWVzdGFtcCA9IE1hdGguZmxvb3IoaSAvIChoZWFydFJhdGVTYW1wbGVzLmxlbmd0aCAtIDEpICogMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9Pbmx5IHNob3cgZXZlcnkgNXRoIHRpbWVzdGFtcFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYXJ0UmF0ZVNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGhlYXJ0UmF0ZVNhbXBsZXNbaV0uZm9yY2VTaG93ID0gaGVhcnRSYXRlU2FtcGxlc1tpXS50aW1lc3RhbXAgJSA1ID09IDAgJiYgKGkgPT0gMCB8fCBoZWFydFJhdGVTYW1wbGVzW2kgLSAxXS50aW1lc3RhbXAgJSA1ICE9IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnQudmFsaWRhdGVEYXRhKCk7XG4gICAgfSwgdXBkYXRlRnJlcXVlbmN5KTtcbn1cblxuZnVuY3Rpb24gc3RvcEV2ZW50TG9vcCgpIHtcbiAgICBjbGVhckludGVydmFsKGNoYXJ0VXBkYXRlcik7XG4gICAgaGVhcnRSYXRlU2FtcGxlcy5sZW5ndGggPSAwO1xuICAgIGNoYXJ0LnZhbGlkYXRlRGF0YSgpO1xufVxuXG5jb25zdCBIZWFydFJhdGVDaGFydCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHN0YXRpY3M6IHt9LFxuXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICB3aWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtdLFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDaGFydFN0YXRlKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2hhcnQoKTtcbiAgICAgICAgSGVhcnRTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcigoKT0+IHRoaXMuX3VwZGF0ZUNoYXJ0KCkpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIGVsID0gUmVhY3QuZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgIGluaXRDaGFydChlbCk7XG4gICAgICAgIHN0YXJ0RXZlbnRMb29wKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjaGFydCAmJiBjaGFydC5jbGVhcigpO1xuICAgICAgICBzdG9wRXZlbnRMb29wKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVubW91bnQoKSB7XG4gICAgICAgIGNoYXJ0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIH0sXG5cbiAgICAvLyB0aGlzIGNoYXJ0IGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIGl0c2VsZlxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgICBfdXBkYXRlQ2hhcnQoKXtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRDaGFydFN0YXRlKCkpO1xuICAgICAgICBjcmVhdGVIZWFydFJhdGVTYW1wbGVzKHRoaXMuc3RhdGUubWluLCB0aGlzLnN0YXRlLm1heCk7XG4gICAgfSxcblxuICAgIF9nZXRDaGFydFN0YXRlKCl7XG4gICAgICAgIHJldHVybiBIZWFydFN0b3JlLmdldFN0YXRlKCk7XG4gICAgfSxcblxuICAgIF9vbkNoYW5nZSgpe1xuXG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICAvLyBpZiB5b3UgZG9uJ3Qgc3BlY2lmeSB3aWR0aCBpdCB3aWxsIG1heCBvdXQgdG8gMTAwJSAod2hpY2ggaXMgb2spXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgc3R5bGU9e3t3aWR0aDogdGhpcy5wcm9wcy53aWR0aCArICdweCcsIGhlaWdodCA6IHRoaXMucHJvcHMuaGVpZ2h0KyAncHgnfX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFydFJhdGVDaGFydDtcbiIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xuY29uc3QgTGluayA9IFJvdXRlci5MaW5rO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICByZW5kZXIgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8aDM+VmVsZyBsYWc8L2gzPlxuICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgPGxpPjxMaW5rIHRvPVwidGVhbS1yb290XCIgcGFyYW1zPXt7IHRlYW1JZCA6ICdzY2llbmNlJ319PkZvcnNrbmluZ3NncnVwcGE8L0xpbms+PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPGxpPjxMaW5rIHRvPVwidGVhbS1yb290XCIgcGFyYW1zPXt7IHRlYW1JZCA6ICdhc3Ryb25hdXQnfX0+QXN0cm9uYXV0Z3J1cHBhPC9MaW5rPjwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDxsaT48TGluayB0bz1cInRlYW0tcm9vdFwiIHBhcmFtcz17eyB0ZWFtSWQgOiAnc2VjdXJpdHknfX0+U2lra2VyaGV0c2dydXBwYTwvTGluaz48L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+PExpbmsgdG89XCJ0ZWFtLXJvb3RcIiBwYXJhbXM9e3sgdGVhbUlkIDogJ2NvbW11bmljYXRpb24nfX0+S29tbXVuaWthc2pvbnNncnVwcGE8L0xpbms+PC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuXG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBkaWFsb2dzID0gcmVxdWlyZSgnLi9kaWFsb2dzLnJlYWN0Jyk7XG5jb25zdCB7IGNsZWFuUm9vdFBhdGggfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IFJvdXRlU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvcm91dGUtc3RvcmUnKTtcbnZhciBJbnRyb1N0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL2ludHJvZHVjdGlvbi1zdG9yZScpO1xuXG4gY29uc3QgSW50cm9kdWN0aW9uU2NyZWVuID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgbWl4aW5zOiBbXSxcblxuICAgICBjb250ZXh0VHlwZXM6IHtcbiAgICAgICAgIHJvdXRlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgd2lsbFRyYW5zaXRpb25Ubyh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdGVhbUlkID0gY2xlYW5Sb290UGF0aCh0cmFuc2l0aW9uLnBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoSW50cm9TdG9yZS5pc0ludHJvZHVjdGlvblJlYWQodGVhbUlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnRyb2R1Y3Rpb24gcmVhZCBlYXJsaWVyJyk7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5yZWRpcmVjdCgndGVhbS10YXNrJywge3Rhc2tJZDogJ3NhbXBsZScsIHRlYW1JZCA6IHRlYW1JZH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oYW5kbGVDbGljaygpIHtcbiAgICAgICAgY29uc3QgTWlzc2lvbkFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcblxuICAgICAgICB2YXIgdGVhbUlkID0gUm91dGVTdG9yZS5nZXRUZWFtSWQoKTtcbiAgICAgICAgTWlzc2lvbkFjdGlvbkNyZWF0b3JzLmludHJvV2FzUmVhZCh0ZWFtSWQpO1xuICAgICAgICB0aGlzLmNvbnRleHQucm91dGVyLnRyYW5zaXRpb25UbygndGVhbS10YXNrJywge3Rhc2tJZCA6ICdzYW1wbGUnLCB0ZWFtSWQgOiB0ZWFtSWQgfSlcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgdGVhbUlkPSBSb3V0ZVN0b3JlLmdldFRlYW1JZCgpO1xuICAgICAgICB2YXIgaW50cm9UZXh0ID0gZGlhbG9nc1t0ZWFtSWQgKyAnX2ludHJvJ10gfHwgPHA+TWFuZ2xlciBvcHBkcmFnPC9wPjtcblxuICAgICAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lID0gJ3JvdyBqdW1ib3Ryb24gaW50cm9zY3JlZW4nPlxuICAgICAgICAgICAgPGgyPk3DpWwgZm9yIG9wcGRyYWdldDwvaDI+XG5cbiAgICAgICAgICAgIHsgaW50cm9UZXh0IH1cblxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdidG4gYnRuLXByaW1hcnkgYnRuLWxnJ1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX2hhbmRsZUNsaWNrfVxuICAgICAgICAgICAgPkplZyBmb3JzdMOlcjwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj4pXG5cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRyb2R1Y3Rpb25TY3JlZW47XG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBhY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9NZXNzYWdlQWN0aW9uQ3JlYXRvcnMnKTtcblxudmFyIExpc3RNZXNzYWdlV3JhcHBlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBsZXZlbDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgICB0ZXh0OiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICAgIGlkOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgYnV0dG9uO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRpc21pc3NhYmxlKSB7XG4gICAgICAgICAgICBidXR0b24gPSAoXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2xvc2VcIlxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zLnJlbW92ZU1lc3NhZ2UodGhpcy5wcm9wcy5pZCl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj7Dlzwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT17ICdhbGVydCBhbGVydC1kaXNtaXNzaWJsZSBhbGVydC0nICsgdGhpcy5wcm9wcy5sZXZlbH0gPlxuICAgICAgICAgICAgeyBidXR0b24gfVxuICAgICAgICAgICAge3RoaXMucHJvcHMudGV4dH1cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbnZhciBNZXNzYWdlTGlzdCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGhpZGRlbiA9IHRoaXMucHJvcHMubWVzc2FnZXMubGVuZ3RoID09PSAwID8gJ2hpZGUnIDogJyc7XG4gICAgICAgIHZhciBjbGFzc2VzID0gKHRoaXMucHJvcHMuY2xhc3NOYW1lIHx8ICcnKSArICcgbWVzc2FnZWJveCAnICsgaGlkZGVuO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dWwgY2xhc3NOYW1lID0geyBjbGFzc2VzIH0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5tZXNzYWdlcy5tYXAoKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDxMaXN0TWVzc2FnZVdyYXBwZXIga2V5PXttc2cuaWR9IHsuLi5tc2d9IC8+KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VMaXN0O1xuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgTGluayA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpLkxpbms7XG5jb25zdCBNaXNzaW9uU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvbWlzc2lvbi1zdGF0ZS1zdG9yZScpO1xuY29uc3QgTWlzc2lvblRpbWVyID0gcmVxdWlyZSgnLi9taXNzaW9uLXRpbWVyLnJlYWN0Jyk7XG5jb25zdCBFdmVudFN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL2V2ZW50LXN0b3JlJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBnZXRNaXNzaW9uQUMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGxldCB0bXAgPSBudWxsO1xuICAgIHJldHVybiAoKT0+IHtcbiAgICAgICAgaWYgKCF0bXApIHRtcCA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTWlzc2lvbkFjdGlvbkNyZWF0b3JzJyk7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgfVxufSkoKTtcblxuY29uc3QgRXZlbnRUYWJsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBldmVudHM6IFJlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICAgICAgICB0cmlnZ2VyRGlzYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sXG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9J3RhYmxlJz5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICA8dGg+VGltZTwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDx0aD5WYWx1ZTwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDx0aD5UcmlnZ2VyPC90aD5cbiAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgeyAgdGhpcy5wcm9wcy5ldmVudHMubWFwKChldikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gPHRyIGtleT17ZXYuaWR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntldi50cmlnZ2VyVGltZX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntldi5zaG9ydF9kZXNjcmlwdGlvbn08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntKU09OLnN0cmluZ2lmeShldi52YWx1ZSB8fCAnJyl9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17ICdidG4gYnRuLXByaW1hcnkgJyArICh0aGlzLnByb3BzLnRyaWdnZXJEaXNhYmxlZCAmJiAnZGlzYWJsZWQnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGdldE1pc3Npb25BQygpLmFza1RvVHJpZ2dlckV2ZW50KGV2LmlkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbnZhciBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKXtcbiAgICAgICAgdmFyIGFjID0gZ2V0TWlzc2lvbkFDKCk7XG4gICAgICAgIGFjLmFza0ZvckV2ZW50cygpO1xuXG4gICAgICAgIEV2ZW50U3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgICBNaXNzaW9uU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpXG5cbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKXtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtjaGFwdGVyVGltZTogdGhpcy5zdGF0ZS5jaGFwdGVyVGltZSArIDF9KVxuICAgICAgICB9LDEwMDApO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpe1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcbiAgICAgICAgRXZlbnRTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG4gICAgICAgIE1pc3Npb25TdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSlcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcGxldGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIG92ZXJkdWVFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmVtYWluaW5nRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IE1pc3Npb25TdG9yZS5pc01pc3Npb25SdW5uaW5nKCksXG4gICAgICAgICAgICBjaGFwdGVyOiBNaXNzaW9uU3RvcmUuY3VycmVudENoYXB0ZXIoKSxcbiAgICAgICAgICAgIGNoYXB0ZXJUaW1lOiBNaXNzaW9uU3RvcmUuY2hhcHRlclRpbWUoKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb21wbGV0ZWRFdmVudHM6IEV2ZW50U3RvcmUuY29tcGxldGVkKCksXG4gICAgICAgICAgICBvdmVyZHVlRXZlbnRzOiBFdmVudFN0b3JlLm92ZXJkdWUoKSxcbiAgICAgICAgICAgIHJlbWFpbmluZ0V2ZW50czogRXZlbnRTdG9yZS5yZW1haW5pbmcoKSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IE1pc3Npb25TdG9yZS5pc01pc3Npb25SdW5uaW5nKCksXG4gICAgICAgICAgICBjaGFwdGVyOiBNaXNzaW9uU3RvcmUuY3VycmVudENoYXB0ZXIoKSxcbiAgICAgICAgICAgIGNoYXB0ZXJUaW1lOiBNaXNzaW9uU3RvcmUuY2hhcHRlclRpbWUoKSxcbiAgICAgICAgICAgIHNhZmVNb2RlIDogTWlzc2lvblN0b3JlLmlzU2F0ZWxsaXRlSW5TYWZlTW9kZSgpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgdmFyIHN0YXR1cztcblxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUucnVubmluZykge1xuICAgICAgICAgICAgc3RhdHVzID0gPHAgaWQ9XCJtaXNzaW9uVGltZVwiPk9wcGRyYWdldCBoYXIgaWtrZSBzdGFydGV0PC9wPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPGgzPlN0YXR1czwvaDM+XG4gICAgICAgICAgICAgICAgICAgIHtzdGF0dXN9XG5cbiAgICAgICAgICAgICAgICAgICAgPGRsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGR0Pk7DpXbDpnJlbmRlIGthcGl0dGVsOjwvZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGQ+e3RoaXMuc3RhdGUuY2hhcHRlcn08L2RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGR0PlRpZCBicnVrdCBpIGthcGl0dGVsPC9kdD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkZD57dGhpcy5zdGF0ZS5jaGFwdGVyVGltZX08L2RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGR0PlRvdGFsIHRpZDwvZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGQ+PE1pc3Npb25UaW1lciAvPjwvZGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvZGw+XG4gICAgICAgICAgICAgICAgICAgIFNhdGVsbGl0ZSBpbiBzYWZlIG1vZGU/IHt0aGlzLnN0YXRlLnNhZmVNb2RlPyBcIlllc1wiIDogXCJOb1wiIH1cblxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9J2J0biBidG4tcHJpbWFyeScgb25DbGljaz17Z2V0TWlzc2lvbkFDKCkuc3RhcnRNaXNzaW9ufT5TdGFydCBvcHBkcmFnPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPSdidG4gYnRuLXByaW1hcnknIG9uQ2xpY2s9e2dldE1pc3Npb25BQygpLnN0b3BNaXNzaW9ufT5TdG9wPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPSdidG4gYnRuLXByaW1hcnknIG9uQ2xpY2s9e2dldE1pc3Npb25BQygpLmFza1RvU3RhcnROZXh0Q2hhcHRlcn0+TmVzdGUga2FwaXR0ZWxcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPSdidG4gYnRuLXByaW1hcnknIG9uQ2xpY2s9e2dldE1pc3Npb25BQygpLnJlc2V0TWlzc2lvbn0+QmVneW5uIHDDpSBueXR0PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5JyBvbkNsaWNrPXtnZXRNaXNzaW9uQUMoKS5jb21wbGV0ZU1pc3Npb259Pk9wcGRyYWcgdXRmw7hydDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPSdidG4gYnRuLXByaW1hcnknIG9uQ2xpY2s9e2dldE1pc3Npb25BQygpLmNoYW5nZVNjcnViYmVyfT5CeXR0IHNjcnViYmVyPC9idXR0b24+XG5cblxuICAgICAgICAgICAgICAgIDxoMj5DaGFwdGVyIGV2ZW50czwvaDI+XG5cbiAgICAgICAgICAgICAgICA8aDM+cmVtYWluaW5nPC9oMz5cbiAgICAgICAgICAgICAgICA8RXZlbnRUYWJsZSBrZXk9XCJmb29cIiBldmVudHM9e3RoaXMuc3RhdGUucmVtYWluaW5nRXZlbnRzfS8+XG5cbiAgICAgICAgICAgICAgICA8aDM+b3ZlcmR1ZTwvaDM+XG4gICAgICAgICAgICAgICAgPEV2ZW50VGFibGUgZXZlbnRzPXt0aGlzLnN0YXRlLm92ZXJkdWVFdmVudHN9Lz5cblxuICAgICAgICAgICAgICAgIDxoMz5jb21wbGV0ZWQ8L2gzPlxuICAgICAgICAgICAgICAgIDxFdmVudFRhYmxlIHRyaWdnZXJEaXNhYmxlZD17dHJ1ZX0gZXZlbnRzPXt0aGlzLnN0YXRlLmNvbXBsZXRlZEV2ZW50c30vPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcHA7XG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0JyksXG4gICAgVGltZXJTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy90aW1lci1zdG9yZScpLFxuICAgIFRpbWVyID0gcmVxdWlyZSgnLi90aW1lci5yZWFjdCcpO1xuXG5cbmNvbnN0IE1pc3Npb25UaW1lciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIGdldEluaXRpYWxTdGF0ZSgpe1xuICAgICAgICByZXR1cm4geyBlbGFwc2VkIDogVGltZXJTdG9yZS5nZXRFbGFwc2VkTWlzc2lvblRpbWUoKSB9O1xuICAgIH0sXG4gICAgXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVGltZXJTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzLl9oYW5kbGVUaW1lQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVGltZXJTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9oYW5kbGVUaW1lQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZVRpbWVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZWxhcHNlZCA6IFRpbWVyU3RvcmUuZ2V0RWxhcHNlZE1pc3Npb25UaW1lKClcbiAgICAgICAgfSlcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gIDxUaW1lciBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfSB0aW1lSW5TZWNvbmRzPXt0aGlzLnN0YXRlLmVsYXBzZWQgfSAvPlxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1pc3Npb25UaW1lcjtcblxuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5jb25zdCBOb3RGb3VuZCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nY29udGFpbmVyJz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93IGp1bWJvdHJvblwiPlxuICAgICAgICAgICAgICAgIDxkaXY+T2pzYW5uLiBUcm9yIGR1IGhhciBnw6V0dCBkZWcgdmlsbCwgamVnPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTm90Rm91bmQ7XG4iLCIvKlxuICogU2ltcGxlIGNvbXBvbmVudCB0aGF0IG92ZXJsYXlzIGEgc2VjdGlvbiwgc2lnbmFsbGluZyBhIGRpc2FibGVkIHN0YXRlXG4gKlxuICogRGVwZW5kYW50IG9uIHdvcmtpbmcgQ1NTLCBvZiBjb3Vyc2U6IHRoZSBwYXJlbnQgbXVzdCBiZSBwb3NpdGlvbmVkIChyZWxhdGl2ZSwgYWJzb2x1dGUsIC4uLilcbiAqIExvb3NlbHkgYmFzZWQgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNjI3MjgzL2hvdy10by1kaW0tb3RoZXItZGl2LW9uLWNsaWNraW5nLWlucHV0LWJveC11c2luZy1qcXVlcnlcbiAqL1xuY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBhY3RpdmUgOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb3BzLmFjdGl2ZT8gPGRpdiBjbGFzc05hbWU9XCJvdmVybGF5XCIvPiA6IG51bGwpO1xuICAgIH1cblxufSk7IiwiLyoqXG4gKiBUSElTIERFU0lHTiBPTkxZIFNVUFBPUlRTIE9ORSBDSEFSVCBBUyBUSEVZICpTSEFSRSogU1RBVEVcbiAqIEZvciBhIG5vbi1zdHVwaWQgZGVzaWduLCBkbyBzb21ldGhpbmcgbGlrZSB0aGVcbiAqIGltcGxlbWVudGF0aW9uIGluIHRoZSBhcnRpY2xlIGJ5IE5pY29sYXMgSGVyeTpcbiAqIGh0dHA6Ly9uaWNvbGFzaGVyeS5jb20vaW50ZWdyYXRpbmctZDNqcy12aXN1YWxpemF0aW9ucy1pbi1hLXJlYWN0LWFwcFxuICpcbiAqIENoYXJ0IGNvZGUgbW9yZSBvciBsZXNzIGNvcGllZCBmcm9tIHRoZSBwcm90b3R5cGUgYnkgTGVvIE1hcnRpbiBXZXN0YnlcbiAqL1xuY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgQW1DaGFydHMgPSByZXF1aXJlKCdhbWNoYXJ0cycpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL1NjaWVuY2VUZWFtQ29uc3RhbnRzJyk7XG5cbnZhciBjaGFydCwgY2hhcnRVcGRhdGVyLCBnZXROZXdWYWx1ZSwgdXBkYXRlRnJlcXVlbmN5LCBtYXhTZWNvbmRzO1xudmFyIHJhZGlhdGlvblNhbXBsZXMgPSBbXTtcblxuY29uc3QgeyByYW5kb21JbnQgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGluaXRDaGFydChkb21FbGVtZW50KSB7XG5cbiAgICBjaGFydCA9IG5ldyBBbUNoYXJ0cy5BbVNlcmlhbENoYXJ0KCk7XG5cbiAgICBjaGFydC5tYXJnaW5Ub3AgPSAyMDtcbiAgICBjaGFydC5tYXJnaW5SaWdodCA9IDA7XG4gICAgY2hhcnQubWFyZ2luTGVmdCA9IDA7XG4gICAgY2hhcnQuYXV0b01hcmdpbk9mZnNldCA9IDA7XG4gICAgY2hhcnQuZGF0YVByb3ZpZGVyID0gcmFkaWF0aW9uU2FtcGxlcztcbiAgICBjaGFydC5jYXRlZ29yeUZpZWxkID0gXCJ0aW1lc3RhbXBcIjtcblxuICAgIC8vWCBheGlzXG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IGNoYXJ0LmNhdGVnb3J5QXhpcztcbiAgICBjYXRlZ29yeUF4aXMuZGFzaExlbmd0aCA9IDE7XG4gICAgY2F0ZWdvcnlBeGlzLmdyaWRBbHBoYSA9IDAuMTU7XG4gICAgY2F0ZWdvcnlBeGlzLmF4aXNDb2xvciA9IFwiI0RBREFEQVwiO1xuICAgIGNhdGVnb3J5QXhpcy50aXRsZSA9IFwiU2Vjb25kc1wiO1xuXG4gICAgLy9ZIGF4aXNcbiAgICB2YXIgdmFsdWVBeGlzID0gbmV3IEFtQ2hhcnRzLlZhbHVlQXhpcygpO1xuICAgIHZhbHVlQXhpcy5heGlzQWxwaGEgPSAwLjI7XG4gICAgdmFsdWVBeGlzLmRhc2hMZW5ndGggPSAxO1xuICAgIHZhbHVlQXhpcy50aXRsZSA9IFwizrxTdi9oXCI7XG4gICAgdmFsdWVBeGlzLm1pbmltdW0gPSBjb25zdGFudHMuU0NJRU5DRV9SQURJQVRJT05fTUlOO1xuICAgIHZhbHVlQXhpcy5tYXhpbXVtID0gY29uc3RhbnRzLlNDSUVOQ0VfUkFESUFUSU9OX01BWDtcbiAgICBjaGFydC5hZGRWYWx1ZUF4aXModmFsdWVBeGlzKTtcblxuICAgIC8vTGluZVxuICAgIHZhciBncmFwaCA9IG5ldyBBbUNoYXJ0cy5BbUdyYXBoKCk7XG4gICAgZ3JhcGgudmFsdWVGaWVsZCA9IFwicmFkaWF0aW9uXCI7XG4gICAgZ3JhcGguYnVsbGV0ID0gXCJyb3VuZFwiO1xuICAgIGdyYXBoLmJ1bGxldEJvcmRlckNvbG9yID0gXCIjRkZGRkZGXCI7XG4gICAgZ3JhcGguYnVsbGV0Qm9yZGVyVGhpY2tuZXNzID0gMjtcbiAgICBncmFwaC5saW5lVGhpY2tuZXNzID0gMjtcbiAgICBncmFwaC5saW5lQ29sb3IgPSBcIiNiNTAzMGRcIjtcbiAgICBncmFwaC5uZWdhdGl2ZUxpbmVDb2xvciA9IFwiIzIyOEIyMlwiO1xuICAgIGdyYXBoLm5lZ2F0aXZlQmFzZSA9IDYwO1xuICAgIGdyYXBoLmhpZGVCdWxsZXRzQ291bnQgPSA1MDtcbiAgICBjaGFydC5hZGRHcmFwaChncmFwaCk7XG5cbiAgICAvL01vdXNlb3ZlclxuICAgIGNvbnN0IGNoYXJ0Q3Vyc29yID0gbmV3IEFtQ2hhcnRzLkNoYXJ0Q3Vyc29yKCk7XG4gICAgY2hhcnRDdXJzb3IuY3Vyc29yUG9zaXRpb24gPSBcIm1vdXNlXCI7XG4gICAgY2hhcnQuYWRkQ2hhcnRDdXJzb3IoY2hhcnRDdXJzb3IpO1xuICAgIGNoYXJ0LndyaXRlKGRvbUVsZW1lbnQpO1xufVxuXG4vL0FkZHMgYSBuZXcgcmFkaWF0aW9uIHNhbXBsZSB0byB0aGUgY2hhcnQgZXZlcnkgZmV3IHNlY29uZHNcbmZ1bmN0aW9uIHN0YXJ0RXZlbnRMb29wKCkge1xuICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHN0b3BFdmVudExvb3AoKTtcblxuICAgIGNoYXJ0VXBkYXRlciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlY29uZHNQYXNzZWQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwO1xuXG4gICAgICAgIHJhZGlhdGlvblNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGguZmxvb3Ioc2Vjb25kc1Bhc3NlZCArIDAuNSksXG4gICAgICAgICAgICByYWRpYXRpb246IGdldE5ld1ZhbHVlKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9XaGVuIHRoZSBjaGFydCBncm93cywgc3RhcnQgY3V0dGluZyBvZmYgdGhlIG9sZGVzdCBzYW1wbGUgdG8gZ2l2ZSB0aGUgY2hhcnQgYSBzbGlkaW5nIGVmZmVjdFxuICAgICAgICBpZiAocmFkaWF0aW9uU2FtcGxlcy5sZW5ndGggPiAobWF4U2Vjb25kcyAvIHVwZGF0ZUZyZXF1ZW5jeSkpIHtcbiAgICAgICAgICAgIHJhZGlhdGlvblNhbXBsZXMuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0LnZhbGlkYXRlRGF0YSgpO1xuICAgIH0sIHVwZGF0ZUZyZXF1ZW5jeSAqIDEwMDApO1xufVxuXG5mdW5jdGlvbiBzdG9wRXZlbnRMb29wKCkge1xuICAgIGNsZWFySW50ZXJ2YWwoY2hhcnRVcGRhdGVyKTtcbn1cblxuY29uc3QgUmFkaWF0aW9uQ2hhcnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBzdGF0aWNzOiB7fSxcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICB1cGRhdGVGcmVxdWVuY3lTZWNvbmRzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIG1heFNlY29uZHNTaG93bjogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICBnZXROZXdWYWx1ZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgICAgaGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIHdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgfSxcblxuICAgIG1peGluczogW10sXG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIHVwZGF0ZUZyZXF1ZW5jeSA9IHRoaXMucHJvcHMudXBkYXRlRnJlcXVlbmN5U2Vjb25kcztcbiAgICAgICAgbWF4U2Vjb25kcyA9IHRoaXMucHJvcHMubWF4U2Vjb25kc1Nob3duO1xuICAgICAgICBnZXROZXdWYWx1ZSA9IHRoaXMucHJvcHMuZ2V0TmV3VmFsdWU7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB2YXIgZWwgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgaW5pdENoYXJ0KGVsKTtcbiAgICAgICAgc3RhcnRFdmVudExvb3AoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNoYXJ0ICYmIGNoYXJ0LmNsZWFyKCk7XG4gICAgICAgIHN0b3BFdmVudExvb3AoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVW5tb3VudCgpIHtcbiAgICAgICAgY2hhcnQgPSBudWxsO1xuICAgICAgICAvL3JhZGlhdGlvblNhbXBsZXMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIH0sXG5cbiAgICAvLyB0aGlzIGNoYXJ0IGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIGl0c2VsZlxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBQcml2YXRlIG1ldGhvZHNcblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICAvLyBpZiB5b3UgZG9uJ3Qgc3BlY2lmeSB3aWR0aCBpdCB3aWxsIG1heCBvdXQgdG8gMTAwJSAod2hpY2ggaXMgb2spXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgc3R5bGU9e3t3aWR0aDogdGhpcy5wcm9wcy53aWR0aCArICdweCcsIGhlaWdodCA6IHRoaXMucHJvcHMuaGVpZ2h0KyAncHgnfX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYWRpYXRpb25DaGFydDtcbiIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKSxcbiAgICBUaW1lclN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL3RpbWVyLXN0b3JlJyksXG4gICAgTWlzc2lvbkFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKSxcbiAgICBUaW1lckFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9UaW1lckFjdGlvbkNyZWF0b3JzJyksXG4gICAgU2NpZW5jZUFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9TY2llbmNlQWN0aW9uQ3JlYXRvcnMnKSxcbiAgICBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvU2NpZW5jZVRlYW1Db25zdGFudHMnKTtcblxudmFyIFJhZGlhdGlvblNhbXBsZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgcmVxdWlyZWRTYW1wbGVzOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIHJhZGlhdGlvblN0b3JlU3RhdGU6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIFRpbWVyU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlVGltZXJDaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKXtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudGltZXJBY3RpdmUpIHtcbiAgICAgICAgICAgIGxldCBlbCA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMucmVmc1snc2FtcGxlLWJ1dHRvbiddKTtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpe1xuICAgICAgICBUaW1lclN0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuX2hhbmRsZVRpbWVyQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge3RpbWVyQWN0aXZlOiBmYWxzZX1cbiAgICB9LFxuXG4gICAgX2lzRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5zdGF0ZS50aW1lckFjdGl2ZVxuICAgIH0sXG5cblxuICAgIF9oYW5kbGVUaW1lckNoYW5nZSgpIHtcbiAgICAgICAgdmFyIGF1ZGlvID0gUmVhY3QuZmluZERPTU5vZGUodGhpcy5yZWZzWydnZWlnZXJTb3VuZCddKTtcbiAgICAgICAgdmFyIHRpbWVyQWN0aXZlID0gVGltZXJTdG9yZS5pc1J1bm5pbmcoY29uc3RhbnRzLlNDSUVOQ0VfVElNRVJfMSk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dGltZXJBY3RpdmU6IHRpbWVyQWN0aXZlfSk7XG5cbiAgICAgICAgaWYgKHRpbWVyQWN0aXZlICYmIGF1ZGlvLnBhdXNlZCkge1xuICAgICAgICAgICAgYXVkaW8ucGxheSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aW1lckFjdGl2ZSAmJiAhYXVkaW8ucGF1c2VkKSB7XG4gICAgICAgICAgICBhdWRpby5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oYW5kbGVDbGljaygpIHtcbiAgICAgICAgU2NpZW5jZUFjdGlvbkNyZWF0b3JzLnRha2VSYWRpYXRpb25TYW1wbGUoKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yYWRpYXRpb25TdG9yZVN0YXRlLnNhbXBsZXMubGVuZ3RoICsgMSA+PSB0aGlzLnByb3BzLnJlcXVpcmVkU2FtcGxlcykge1xuICAgICAgICAgICAgVGltZXJBY3Rpb25DcmVhdG9ycy5zdG9wVGltZXIoY29uc3RhbnRzLlNDSUVOQ0VfVElNRVJfMSk7XG4gICAgICAgICAgICBTY2llbmNlQWN0aW9uQ3JlYXRvcnMuY29tcGxldGVUYXNrKCdzYW1wbGUnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBkaXNhYmxlZCwgY2xhc3NlcztcblxuICAgICAgICBjbGFzc2VzID0gJ2J0biBidG4tcHJpbWFyeSc7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzYWJsZWQoKSkge1xuICAgICAgICAgICAgY2xhc3NlcyArPSAnIGRpc2FibGVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e1wicmFkaWF0aW9uLXNhbXBsZXIgXCIgKyB0aGlzLnByb3BzLmNsYXNzTmFtZX0+XG5cbiAgICAgICAgICAgICAgICB7IC8qIEF2b2lkIGZsb2F0aW5nIGludG8gcHJldmlvdXMgYmxvY2sgKi8gfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaWF0aW9uLXNhbXBsZXJfX3BhZGRlciBjbGVhcmZpeCB2aXNpYmxlLXhzLWJsb2NrXCIvPlxuXG4gICAgICAgICAgICAgICAgPGF1ZGlvIHJlZj1cImdlaWdlclNvdW5kXCIgbG9vcD5cbiAgICAgICAgICAgICAgICAgICAgPHNvdXJjZSBzcmM9XCIvc291bmRzL0FPUzA0NTk1X0VsZWN0cmljX0dlaWdlcl9Db3VudGVyX0Zhc3Qud2F2XCIgdHlwZT1cImF1ZGlvL3dhdlwiLz5cbiAgICAgICAgICAgICAgICA8L2F1ZGlvPlxuXG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPSdzYW1wbGUtYnV0dG9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICA+VGEgc3Ryw6VsaW5nc3Byw7h2ZVxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhZGlhdGlvblNhbXBsZXI7IiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHN0YXRpY3M6IHt9LFxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBzYW1wbGVzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgICAgICAgbWluaW1hbFJvd3NUb1Nob3c6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzXG5cbiAgICBnZXREZWZhdWx0UHJvcHMoKXtcbiAgICAgICAgcmV0dXJuIHttaW5pbWFsUm93c1RvU2hvdzogMH07XG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHNhbXBsZVJvd3MgPSB0aGlzLnByb3BzLnNhbXBsZXMubWFwKCh2YWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRyIGtleT17aX0+XG4gICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT1cInJvd1wiPntpICsgMX08L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3ZhbH08L3RkPlxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1pc3NpbmdSb3dzID0gdGhpcy5wcm9wcy5taW5pbWFsUm93c1RvU2hvdyAtIHNhbXBsZVJvd3MubGVuZ3RoLFxuICAgICAgICAgICAgZmlsbFJvd3M7XG5cbiAgICAgICAgaWYgKG1pc3NpbmdSb3dzID4gMCkge1xuICAgICAgICAgICAgZmlsbFJvd3MgPSBbXTtcblxuICAgICAgICAgICAgd2hpbGUgKG1pc3NpbmdSb3dzLS0pIHtcbiAgICAgICAgICAgICAgICBmaWxsUm93cy5wdXNoKDx0ciBrZXk9e2ZpbGxSb3dzLmxlbmd0aH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9XCJyb3dcIj48L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPiZuYnNwO3svKiBOZWVkcyBmaWxsZXIgdG8gbm90IGNvbGxhcHNlIGNlbGwgKi99PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfT5cblxuICAgICAgICAgICAgICAgIDxoMz5QcsO4dmVyZXN1bHRhdGVyPC9oMz5cbiAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPVwiIHRhYmxlIHRhYmxlLWJvcmRlcmVkXCI+XG4gICAgICAgICAgICAgICAgICAgIDxjYXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgU3Ryw6VsaW5nc3BhcnRpa2xlciBwZXIgc2VrdW5kIChwL3MpXG4gICAgICAgICAgICAgICAgICAgIDwvY2FwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5QcsO4dmVudW1tZXI8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+cC9zPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICB7IHNhbXBsZVJvd3MgfVxuICAgICAgICAgICAgICAgICAgICB7IGZpbGxSb3dzIH1cbiAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbn0pO1xuXG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBUaW1lclBhbmVsID0gcmVxdWlyZSgnLi90aW1lci1wYW5lbC5yZWFjdCcpO1xuY29uc3QgUmFkaWF0aW9uQ2hhcnQgPSByZXF1aXJlKCcuL3JhZGlhdGlvbi1jaGFydC5yZWFjdC5qcycpO1xuY29uc3QgUmFkaWF0aW9uU2FtcGxlQnV0dG9uID0gcmVxdWlyZSgnLi9yYWRpYXRpb24tc2FtcGxlci5yZWFjdCcpO1xuY29uc3QgT3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheS5yZWFjdCcpO1xuY29uc3QgUmFkaWF0aW9uVGFibGUgPSByZXF1aXJlKCcuL3JhZGlhdGlvbi10YWJsZS5yZWFjdCcpO1xuY29uc3QgUmFkaWF0aW9uU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvcmFkaWF0aW9uLXN0b3JlJyk7XG5jb25zdCBhY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9TY2llbmNlQWN0aW9uQ3JlYXRvcnMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IFNjaWVuY2VUZWFtQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL1NjaWVuY2VUZWFtQ29uc3RhbnRzJyk7XG5jb25zdCBUaW1lckFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9UaW1lckFjdGlvbkNyZWF0b3JzJyk7XG5cblxuLy8gU0VUVElOR1NcblRpbWVyQWN0aW9uQ3JlYXRvcnMuc2V0VGltZXIoU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9USU1FUl8xLCAzMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgc3RhdGljczoge30sXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGFwcHN0YXRlOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgICB9LFxuICAgIG1peGluczogW10sXG5cbiAgICAvLyBsaWZlIGN5Y2xlIG1ldGhvZHNcbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYWRpYXRpb246IFJhZGlhdGlvblN0b3JlLmdldFN0YXRlKClcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBSYWRpYXRpb25TdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzLl9oYW5kbGVSYWRpYXRpb25DaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgUmFkaWF0aW9uU3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlUmFkaWF0aW9uQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzXG5cbiAgICBfaGFuZGxlUmFkaWF0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHJhZGlhdGlvbjogUmFkaWF0aW9uU3RvcmUuZ2V0U3RhdGUoKVxuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICBfaGFuZGxlQXZlcmFnZVJhZGlhdGlvblN1Ym1pdChlKSB7XG4gICAgICAgIGxldCBlbCA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMucmVmc1snYXZlcmFnZS1pbnB1dCddKSxcbiAgICAgICAgICAgIHZhbCA9IGVsLnZhbHVlLnRyaW0oKTtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCF2YWwubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgbGV0IGF2ZXJhZ2UgPSB1dGlscy5wYXJzZU51bWJlcih2YWwpO1xuICAgICAgICBlbC52YWx1ZSA9ICcnO1xuXG4gICAgICAgIGlmIChhdmVyYWdlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLmF2ZXJhZ2VSYWRpYXRpb25DYWxjdWxhdGVkKGF2ZXJhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oYW5kbGVBZGRUb1RvdGFsU3VibWl0KGUpe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbGV0IGVsID0gUmVhY3QuZmluZERPTU5vZGUodGhpcy5yZWZzWydhZGQtdG8tdG90YWwnXSk7XG4gICAgICAgIGxldCB2YWwgPSBlbC52YWx1ZS50cmltKCk7XG4gICAgICAgIGlmICghdmFsLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcih2YWwpO1xuXG4gICAgICAgIGlmICghaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgYWN0aW9ucy5hZGRUb1RvdGFsUmFkaWF0aW9uTGV2ZWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qXG4gICAgICogSGVscGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhc2tOYW1lIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY3VycmVudCB0YXNrIGlkIGVxdWFscyB0aGUgbmFtZSBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBfaXNDdXJyZW50VGFzayh0YXNrTmFtZSl7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmFwcHN0YXRlLnRhc2tTdG9yZS5jdXJyZW50VGFza0lkID09PSB0YXNrTmFtZTtcbiAgICB9LFxuXG4gICAgX3JhZGlhdGlvblN0YXR1cygpe1xuICAgICAgICB2YXIgbnVtID0gdGhpcy5zdGF0ZS5yYWRpYXRpb24ubGFzdENhbGN1bGF0ZWRBdmVyYWdlLFxuICAgICAgICAgICAgY29sb3I7XG5cbiAgICAgICAgaWYgKG51bSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdJa2tlIGJlcmVnbmV0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW0gPiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX0FWR19SQURfUkVEX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgY29sb3IgPSAncmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPiBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX0FWR19SQURfT1JBTkdFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgY29sb3IgPSAnb3JhbmdlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9yID0gJ2dyZWVuJztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuICg8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJyYWRpYXRpb24taW5kaWNhdG9yIGNpcmNsZSBjb2wteHMtMlwiXG4gICAgICAgICAgICBzdHlsZT17IHsgJ2JhY2tncm91bmRDb2xvcicgOiBjb2xvciB9IH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIHtudW0gfVxuICAgICAgICA8L2Rpdj4pO1xuXG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHNob3dTYW1wbGVJbnB1dCA9IHRoaXMuX2lzQ3VycmVudFRhc2soJ3NhbXBsZScpLFxuICAgICAgICAgICAgc2hvd0F2ZXJhZ2VJbnB1dCA9IHRoaXMuX2lzQ3VycmVudFRhc2soJ2F2ZXJhZ2UnKSxcbiAgICAgICAgICAgIHNob3dBZGRUb1RvdGFsSW5wdXQgPSB0aGlzLl9pc0N1cnJlbnRUYXNrKCdhZGR0b3RhbCcpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2ID5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncm93Jz5cblxuICAgICAgICAgICAgICAgICAgICA8ZGwgY2xhc3NOYW1lPSdyYWRpYXRpb24tdmFsdWVzIGNvbC14cy02ICc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZHQ+VG90YWx0IHN0csOlbGluZ3NuaXbDpTwvZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGQ+e3RoaXMuc3RhdGUucmFkaWF0aW9uLnRvdGFsfTwvZGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZHQ+U2lzdCBpbm5sZXN0IHN0csOlbGluZ3NuaXbDpTwvZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGQ+eyB0aGlzLl9yYWRpYXRpb25TdGF0dXMoKX0gPC9kZD5cbiAgICAgICAgICAgICAgICAgICAgPC9kbD5cblxuICAgICAgICAgICAgICAgICAgICA8UmFkaWF0aW9uVGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltYWxSb3dzVG9TaG93PXs0fVxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlcz17dGhpcy5zdGF0ZS5yYWRpYXRpb24uc2FtcGxlc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT0nY29sLXhzLTYgJy8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8aHIvPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnN0cnVtZW50c1wiPlxuXG4gICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldCBkaXNhYmxlZD17IXNob3dTYW1wbGVJbnB1dH0gY2xhc3NOYW1lPSdpbnN0cnVtZW50c19fc2VjdGlvbiByb3cgb3ZlcmxheWFibGUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPE92ZXJsYXkgYWN0aXZlPXsgIXNob3dTYW1wbGVJbnB1dCB9Lz5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT0nY29sLXhzLTEyJz5UYSBwcsO4dmVyPC9oMz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUaW1lclBhbmVsIGNsYXNzTmFtZT0nY29sLXhzLTEyIGNvbC1zbS04JyB0aW1lcklkPXtTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1RJTUVSXzF9Lz5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPFJhZGlhdGlvblNhbXBsZUJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT0nY29sLXhzLTUgY29sLXNtLTQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaWF0aW9uU3RvcmVTdGF0ZT17dGhpcy5zdGF0ZS5yYWRpYXRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRTYW1wbGVzPXs0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XG5cbiAgICAgICAgICAgICAgICAgICAgPGhyIC8+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3cgb3ZlcmxheWFibGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxPdmVybGF5IGFjdGl2ZT17ICFzaG93QXZlcmFnZUlucHV0IH0vPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJyYWRpYXRpb24taW5wdXQgaW5zdHJ1bWVudHNfX3NlY3Rpb24gY29sLXhzLTEyIGNvbC1zbS02XCI+XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9J2NvbC14cy0xMic+R2plbm5vbXNuaXR0bGlnIHN0csOlbGluZzwvaDM+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImNvbC14cy04XCIgZGlzYWJsZWQ9eyAhc2hvd0F2ZXJhZ2VJbnB1dCB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0gb25TdWJtaXQ9e3RoaXMuX2hhbmRsZUF2ZXJhZ2VSYWRpYXRpb25TdWJtaXR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCByZWY9J2F2ZXJhZ2UtaW5wdXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMC4xXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluPVwiMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heD1cIjEwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT0ncmFkaWF0aW9uLWlucHV0X19pbnB1dCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5Jz5FdmFsdWVyPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgIDxoci8+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93IG92ZXJsYXlhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8T3ZlcmxheSBhY3RpdmU9eyAhc2hvd0FkZFRvVG90YWxJbnB1dCB9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxmaWVsZHNldCBjbGFzc05hbWU9J3JhZGlhdGlvbi1pbnB1dCBjb2wteHMtOCcgZGlzYWJsZWQ9eyEgc2hvd0FkZFRvVG90YWxJbnB1dCB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMz5MZWdnIHZlcmRpIHRpbCB0b3RhbDwvaDM+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17dGhpcy5faGFuZGxlQWRkVG9Ub3RhbFN1Ym1pdH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgcmVmPSdhZGQtdG8tdG90YWwnIGNsYXNzTmFtZT0ncmFkaWF0aW9uLWlucHV0X19pbnB1dCc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPScwJz4wPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPScxNSc+MTU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9JzUwJz41MDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9J2J0biBidG4tcHJpbWFyeSc+RXZhbHVlcjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbn0pO1xuIiwiY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgQ08yU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvY2FyYm9uLWRpb3hpZGUtc3RvcmUnKTtcbmNvbnN0IE94eWdlblN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL294eWdlbi1zdG9yZScpO1xuY29uc3QgQ29tbXVuaWNhdGlvblF1YWxpdHlTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9jb21tdW5pY2F0aW9uLXF1YWxpdHktc3RvcmUnKTtcbmNvbnN0IFNlY3VyaXR5VGVhbUFDID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9TZWN1cml0eVRlYW1BY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgY2hhcnQgPSBudWxsO1xudmFyIGNoYXJ0RGF0YSA9IFt7dGl0bGU6ICdMdWZ0JywgdmFsdWU6IDEwMH1dO1xuXG5mdW5jdGlvbiBpbml0KGRvbUVsZW0pIHtcbiAgICBjaGFydCA9IG5ldyBBbUNoYXJ0cy5BbVBpZUNoYXJ0KCk7XG4gICAgY2hhcnQudmFsdWVGaWVsZCA9IFwidmFsdWVcIjtcbiAgICBjaGFydC50aXRsZUZpZWxkID0gXCJ0aXRsZVwiO1xuICAgIGNoYXJ0LmRhdGFQcm92aWRlciA9IGNoYXJ0RGF0YTtcbiAgICBjaGFydC53cml0ZShkb21FbGVtKTtcbn1cblxudmFyIFBpZUNoYXJ0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgICB3aWR0aDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIENPMlN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKCgpID0+IHRoaXMuX3VwZGF0ZURhdGEoKSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCl7XG4gICAgICAgIHZhciBlbCA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBpbml0KGVsKTtcbiAgICB9LFxuXG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCl7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG5cbiAgICBfdXBkYXRlRGF0YSgpe1xuICAgICAgICB2YXIgY28yID0gQ08yU3RvcmUuY28yTGV2ZWwoKTtcbiAgICAgICAgY2hhcnREYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgIGNoYXJ0RGF0YS5wdXNoKHt0aXRsZTogJ0FubmVuIGx1ZnQnLCB2YWx1ZTogMTAwIC0gY28yfSk7XG4gICAgICAgIGNoYXJ0RGF0YS5wdXNoKHt0aXRsZTogJ0NPXFx1MjA4MicsIHZhbHVlOiBjbzJ9KTtcblxuICAgICAgICBjaGFydC52YWxpZGF0ZURhdGEoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCl7XG4gICAgICAgIHJldHVybiA8ZGl2IHN0eWxlPXt7aGVpZ2h0IDogdGhpcy5wcm9wcy5oZWlnaHQsIHdpZHRoIDogdGhpcy5wcm9wcy53aWR0aCB9fS8+O1xuICAgIH1cbn0pO1xuXG5cbnZhciBQcm9ncmVzc0JhciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBwcm9ncmVzczogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgICAgICBtYXg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgYWN0aXZlOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgICAgICBjbGFzc05hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmdcbiAgICB9LFxuXG4gICAgcmVuZGVyKCl7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLnByb3BzLnByb2dyZXNzLCBtYXggPSB0aGlzLnByb3BzLm1heDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJvZ3Jlc3NcIj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17IFwicHJvZ3Jlc3MtYmFyIHByb2dyZXNzLWJhci1zdHJpcGVkIFwiICsgdGhpcy5wcm9wcy5jbGFzc05hbWUgKyAodGhpcy5wcm9wcy5hY3RpdmU/ICcgYWN0aXZlJzonJykgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e3dpZHRoIDogIHZhbCptYXggKyAnJSd9fVxuICAgICAgICAgICAgICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIj57TWF0aC5taW4oTWF0aC5yb3VuZCh2YWwgKiBtYXgpLCBtYXgpfSVcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBzdGF0aWNzOiB7fSxcblxuICAgIHByb3BUeXBlczoge30sXG5cbiAgICBtaXhpbnM6IFtdLFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZSgpO1xuICAgICAgICBzdGF0ZS5jb21tUHJvZ3Jlc3MgPSAwO1xuICAgICAgICBzdGF0ZS5xdWFsaXR5UHJvZ3Jlc3MgPSAwO1xuICAgICAgICBzdGF0ZS5kYXRhUXVhbGl0eUZhaWxpbmcgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5yZWFkeUZvclNhZmVNb2RlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBPeHlnZW5TdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcigoKSA9PiB0aGlzLl91cGRhdGVTdGF0ZSgpKTtcbiAgICAgICAgQ29tbXVuaWNhdGlvblF1YWxpdHlTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcigoKSA9PiB0aGlzLl91cGRhdGVTdGF0ZSgpKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgfSxcblxuICAgIF9zdGFydFF1YWxpdHlQcm9ncmVzc0Jhcigpe1xuICAgICAgICB2YXIgbXMgPSA1MDAsIHRvdGFsRHVyYXRpb24gPSA1ICogMTAwMDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7cXVhbGl0eVByb2dyZXNzOiAwfSlcblxuICAgICAgICB2YXIgdG1wID0gc2V0SW50ZXJ2YWwoKCk9PiB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy5zdGF0ZS5xdWFsaXR5UHJvZ3Jlc3M7XG4gICAgICAgICAgICBudW1iZXIgKz0gbXMgLyB0b3RhbER1cmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyID49IDEpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRtcCk7XG4gICAgICAgICAgICAgICAgU2VjdXJpdHlUZWFtQUMuZW5kRGF0YVF1YWxpdHlUZXN0KCF0aGlzLnN0YXRlLmRhdGFRdWFsaXR5RmFpbGluZyk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNldFN0YXRlKHtxdWFsaXR5UHJvZ3Jlc3M6IDB9KSwgOTAwMClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7cXVhbGl0eVByb2dyZXNzOiBudW1iZXJ9KVxuICAgICAgICB9LCBtcylcbiAgICB9LFxuXG5cbiAgICBfc3RhcnRUcmFuc2ZlclByb2dyZXNzQmFyKCl7XG4gICAgICAgIHZhciBtcyA9IDUwMCwgdG90YWxEdXJhdGlvbiA9IDUgKiAxMDAwO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtjb21tUHJvZ3Jlc3M6IDB9KTtcblxuICAgICAgICB2YXIgdG1wID0gc2V0SW50ZXJ2YWwoKCk9PiB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy5zdGF0ZS5jb21tUHJvZ3Jlc3M7XG4gICAgICAgICAgICBudW1iZXIgKz0gbXMgLyB0b3RhbER1cmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyID49IDEpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRtcCk7XG4gICAgICAgICAgICAgICAgU2VjdXJpdHlUZWFtQUMuZW5kRGF0YVRyYW5zZmVyVGVzdCghdGhpcy5zdGF0ZS5kYXRhVHJhbnNmZXJGYWlsaW5nKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2V0U3RhdGUoe2NvbW1Qcm9ncmVzczogMH0pLCA5MDAwKVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2NvbW1Qcm9ncmVzczogbnVtYmVyfSlcbiAgICAgICAgfSwgbXMpXG4gICAgfSxcblxuICAgIF9xdWFsaXR5QWN0aXZlKCl7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZS5xdWFsaXR5UHJvZ3Jlc3MgPCAxKTtcbiAgICB9LFxuXG4gICAgX2NvbW1BY3RpdmUoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY29tbVByb2dyZXNzIDwgMTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVN0YXRlKCl7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fZ2V0U3RhdGUoKSk7XG4gICAgfSxcblxuICAgIF9pbmRpY2F0b3JDb2xvcigpe1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5veHlnZW5TdG9yZS5jb2xvckluZGljYXRvcjtcbiAgICB9LFxuXG4gICAgX2dldFN0YXRlKCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBveHlnZW5TdG9yZTogT3h5Z2VuU3RvcmUuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgIGRhdGFRdWFsaXR5RmFpbGluZzogQ29tbXVuaWNhdGlvblF1YWxpdHlTdG9yZS5xdWFsaXR5VGVzdFNob3VsZEZhaWwoKSxcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlckZhaWxpbmc6IENvbW11bmljYXRpb25RdWFsaXR5U3RvcmUudHJhbnNmZXJUZXN0U2hvdWxkKCksXG4gICAgICAgICAgICByZWFkeUZvclNhZmVNb2RlOiBDb21tdW5pY2F0aW9uUXVhbGl0eVN0b3JlLnJlYWR5Rm9yU2FmZU1vZGUoKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgdmFyIGluZGljYXRvciA9IDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNpcmNsZSBcIlxuICAgICAgICAgICAgc3R5bGU9eyB7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLCBiYWNrZ3JvdW5kQ29sb3IgOiB0aGlzLl9pbmRpY2F0b3JDb2xvcigpIH0gfVxuICAgICAgICAgICAgLz47XG5cblxuICAgICAgICByZXR1cm4gKCA8ZGl2ID5cblxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuXG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS02XCI+XG5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAnMjBweCd9fVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXsgJ2J0biBidG4tcHJpbWFyeSAnICsgKHRoaXMuc3RhdGUucmVhZHlGb3JTYWZlTW9kZT8gJycgOiAnZGlzYWJsZWQnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e1NlY3VyaXR5VGVhbUFDLnNldEluU2FmZU1vZGV9XG4gICAgICAgICAgICAgICAgICAgICAgICA+U2VuZCBpIFNBRkUgTU9ERTwvYnV0dG9uPlxuXG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9Jyc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+U2NydWJmaWx0ZXIgYnl0dGV0OiB7Q08yU3RvcmUuZmlsdGVyQ2hhbmdlZCgpID8gJ2phJyA6ICduZWknfTwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+T2tzeWdlbmluZGlrYXRvcjoge2luZGljYXRvcn0gPC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb2wteHMtMTIgY29sLXNtLTYnPlxuICAgICAgICAgICAgICAgICAgICA8aDM+SW5uaG9sZCBrYXJib25kaW9rc2lkIGkgZHJha3RlbiBhdiB0b3RhbCBsdWZ0bWVuZ2RlPC9oMz5cbiAgICAgICAgICAgICAgICAgICAgPFBpZUNoYXJ0IGhlaWdodD1cIjIwMHB4XCIvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiXCI+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIlwiPktvbW11bmlrYXNqb24gb2cgZGF0YTwvcD5cblxuICAgICAgICAgICAgICAgICAgICA8cCA+S29tbXVuaWthc2pvbnNzdGF0dXMgPC9wPlxuICAgICAgICAgICAgICAgICAgICA8UHJvZ3Jlc3NCYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heD17MTAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXt0aGlzLl9jb21tQWN0aXZlKCl9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3RoaXMuc3RhdGUuZGF0YVRyYW5zZmVyRmFpbGluZyA/ICghdGhpcy5fY29tbUFjdGl2ZSgpPyAncHJvZ3Jlc3MtYmFyLWRhbmdlcicgOiAnJyk6Jyd9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcz17dGhpcy5zdGF0ZS5jb21tUHJvZ3Jlc3N9Lz5cblxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3RoaXMuX3N0YXJ0VHJhbnNmZXJQcm9ncmVzc0Jhcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnlcIj5UZXN0XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAgICAgICAgICAgIDxwID5EYXRha3ZhbGl0ZXQ8L3A+XG5cbiAgICAgICAgICAgICAgICAgICAgPFByb2dyZXNzQmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg9ezEwMH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17dGhpcy5fcXVhbGl0eUFjdGl2ZSgpfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXt0aGlzLnN0YXRlLmRhdGFRdWFsaXR5RmFpbGluZyA/ICghdGhpcy5fcXVhbGl0eUFjdGl2ZSgpPyAncHJvZ3Jlc3MtYmFyLWRhbmdlcicgOiAnJyk6Jyd9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcz17dGhpcy5zdGF0ZS5xdWFsaXR5UHJvZ3Jlc3N9Lz5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9eyAnYnRuIGJ0bi1wcmltYXJ5ICcgKyAodGhpcy5zdGF0ZS5kYXRhVHJhbnNmZXJGYWlsaW5nPyAnZGlzYWJsZWQnIDogJycpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX3N0YXJ0UXVhbGl0eVByb2dyZXNzQmFyfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlRlc3RcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvZGl2PiApO1xuICAgIH1cblxufSk7XG5cbiIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKSxcbiAgICBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKSxcbiAgICBNZXNzYWdlU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvbWVzc2FnZS1zdG9yZScpLFxuICAgIFRhc2tTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy90YXNrLXN0b3JlJyksXG4gICAgUm91dGVTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9yb3V0ZS1zdG9yZScpLFxuICAgIE1lc3NhZ2VMaXN0ID0gcmVxdWlyZSgnLi9tZXNzYWdlLWxpc3QucmVhY3QnKSxcbiAgICBJbnRyb2R1Y3Rpb25TY3JlZW4gPSByZXF1aXJlKCcuL2ludHJvZHVjdGlvbi1zY3JlZW4ucmVhY3QuanMnKSxcbiAgICBUZWFtRGlzcGxheWVyID0gcmVxdWlyZSgnLi90ZWFtLWRpc3BsYXllci5yZWFjdCcpLFxuICAgIE1pc3Npb25UaW1lciA9IHJlcXVpcmUoJy4vbWlzc2lvbi10aW1lci5yZWFjdC5qcycpLFxuICAgIFNjaWVuY2VUYXNrID0gcmVxdWlyZSgnLi9zY2llbmNlLXRhc2sucmVhY3QnKSxcbiAgICBBc3Ryb25hdXRUYXNrID0gcmVxdWlyZSgnLi9hc3Ryb25hdXQtdGFzay5yZWFjdCcpLFxuICAgIENvbW11bmljYXRpb25UYXNrID0gcmVxdWlyZSgnLi9jb21tdW5pY2F0aW9uLXRhc2sucmVhY3QuanMnKSxcbiAgICBTZWN1cml0eVRhc2sgPSByZXF1aXJlKCcuL3NlY3VyaXR5LXRhc2sucmVhY3QuanMnKSxcbiAgICB7IGZvcm1hdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyBsYXp5cmVxdWlyZVxuZnVuY3Rpb24gbGF6eVJlcXVpcmUocGF0aCkge1xuICAgIGxldCB0bXAgPSBudWxsO1xuICAgIHJldHVybiAoKT0+IHtcbiAgICAgICAgaWYgKCF0bXApIHRtcCA9IHJlcXVpcmUocGF0aCk7XG4gICAgICAgIHJldHVybiB0bXA7XG4gICAgfVxufVxuaWYgKGZhbHNlKSB7XG4gICAgcmVxdWlyZSgnLi4vYWN0aW9ucy9NaXNzaW9uQWN0aW9uQ3JlYXRvcnMnKTtcbn1cbmNvbnN0IGdldE1pc3Npb25BQyA9IGxhenlSZXF1aXJlKCcuLi9hY3Rpb25zL01pc3Npb25BY3Rpb25DcmVhdG9ycycpO1xuXG5mdW5jdGlvbiB1cmxPZlRhc2sodGFza0lkKSB7XG4gICAgcmV0dXJuIGZvcm1hdCgnLyVzL3Rhc2svJXMnLCBSb3V0ZVN0b3JlLmdldFRlYW1JZCgpLCB0YXNrSWQpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uVG9DdXJyZW50VGFzayh0cmFuc2l0aW9uRnVuY3Rpb24pIHtcbiAgICB2YXIgY3VycmVudFRhc2tJZCA9IFRhc2tTdG9yZS5nZXRDdXJyZW50VGFza0lkKCk7XG5cbiAgICAvLyB0aGlzIGxvZ2ljIGlzIGZyYWdpbGUgLSBpZiB5b3Ugc2hvdWxkIHN1ZGRlbmx5IGRlY2lkZSB0byB2aXNpdCBhbm90aGVyIHRlYW1cbiAgICAvLyBfYWZ0ZXJfIHlvdSBoYXZlIHN0YXJ0ZWQgYSB0YXNrLCB0aGUgdGVhbSt0YXNrIGNvbWJvIGlzIGludmFsaWQgLT4gNDA0XG4gICAgaWYgKGN1cnJlbnRUYXNrSWQgIT09IFJvdXRlU3RvcmUuZ2V0VGFza0lkKCkpIHtcbiAgICAgICAgdmFyIHRvID0gdXJsT2ZUYXNrKGN1cnJlbnRUYXNrSWQpO1xuICAgICAgICB0cmFuc2l0aW9uRnVuY3Rpb24odG8pO1xuICAgIH1cblxufVxuXG5jb25zdCBUYXNrID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgY29udGV4dFR5cGVzOiB7XG4gICAgICAgIHJvdXRlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgICB9LFxuXG4gICAgbWl4aW5zOiBbXSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgd2lsbFRyYW5zaXRpb25Ubyh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uVG9DdXJyZW50VGFzayh0cmFuc2l0aW9uLnJlZGlyZWN0LmJpbmQodHJhbnNpdGlvbikpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICBNZXNzYWdlU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgICBUYXNrU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgTWVzc2FnZVN0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgICAgVGFza1N0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RhdGVUaW1lb3V0KTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdjb21wb25lbnREaWRVbm1vdW50Jyk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnLmNvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgIH0sXG5cbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+IHRoaXMuc2V0U3RhdGUoe3Rhc2tJc05ldzogZmFsc2V9KSwgMjAwMCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBNZXNzYWdlU3RvcmUuZ2V0TWVzc2FnZXMoKSxcbiAgICAgICAgICAgIHRhc2tTdG9yZTogVGFza1N0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgICB0YXNrSXNOZXc6IHRydWVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX29uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBNZXNzYWdlU3RvcmUuZ2V0TWVzc2FnZXMoKSxcbiAgICAgICAgICAgIHRhc2tTdG9yZTogVGFza1N0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgICB0YXNrSXNOZXc6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXI7XG4gICAgICAgIHRyYW5zaXRpb25Ub0N1cnJlbnRUYXNrKHJvdXRlci50cmFuc2l0aW9uVG8uYmluZChyb3V0ZXIpKTtcblxuICAgICAgICAvLyBhIGJpdCBydWRpbWVudGFyeSAtIHRyaWdnZXJzIG9uIGFsbCBjaGFuZ2VzLCBub3QganVzdCBUYXNrIGNoYW5nZXMgLi4uXG4gICAgICAgIHRoaXMuX3N0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoKCk9PiB0aGlzLnNldFN0YXRlKHt0YXNrSXNOZXc6IGZhbHNlfSksIDIwMDApO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlU3ViVGFza1VJKCkge1xuICAgICAgICBzd2l0Y2ggKFJvdXRlU3RvcmUuZ2V0VGVhbUlkKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NjaWVuY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiA8U2NpZW5jZVRhc2sgYXBwc3RhdGU9e3RoaXMuc3RhdGV9Lz47XG4gICAgICAgICAgICBjYXNlICdhc3Ryb25hdXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiA8QXN0cm9uYXV0VGFzayBhcHBzdGF0ZT17dGhpcy5zdGF0ZX0vPjtcbiAgICAgICAgICAgIGNhc2UgJ2NvbW11bmljYXRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiA8Q29tbXVuaWNhdGlvblRhc2sgYXBwc3RhdGU9e3RoaXMuc3RhdGV9Lz47XG4gICAgICAgICAgICBjYXNlICdzZWN1cml0eSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxTZWN1cml0eVRhc2sgYXBwc3RhdGU9e3RoaXMuc3RhdGV9Lz47XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2hhbmRsZVRhc2tPS0NsaWNrKCl7XG4gICAgICAgICBnZXRNaXNzaW9uQUMoKS50YXNrQ29tcGxldGVkKCBSb3V0ZVN0b3JlLmdldFRlYW1JZCgpLCAgdGhpcy5zdGF0ZS50YXNrU3RvcmUuY3VycmVudFRhc2tJZCk7XG4gICAgfSxcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLl9jcmVhdGVTdWJUYXNrVUkoKSxcbiAgICAgICAgICAgIGJsaW5rID0gdGhpcy5zdGF0ZS50YXNrSXNOZXcgPyAnYmxpbmsnIDogJycsXG4gICAgICAgICAgICB0ZWFtTmFtZXMsIG1pc3Npb25UaW1lcjtcblxuXG4gICAgICAgIHRlYW1OYW1lcyA9IChcbiAgICAgICAgICAgIDxkaXYgaWQ9J3RlYW0tbmFtZScgY2xhc3NOYW1lPScnPlxuICAgICAgICAgICAgICAgIDxoZWFkZXIgY2xhc3NOYW1lPScnPlxuICAgICAgICAgICAgICAgICAgICA8VGVhbURpc3BsYXllciBjbGFzc05hbWU9JycvPlxuICAgICAgICAgICAgICAgIDwvaGVhZGVyPlxuICAgICAgICAgICAgPC9kaXY+KTtcblxuICAgICAgICBtaXNzaW9uVGltZXIgPSAoXG4gICAgICAgICAgICA8c2VjdGlvbiBpZD0nbWlzc2lvbi10aW1lcicgY2xhc3NOYW1lPScnPlxuICAgICAgICAgICAgICAgIDxNaXNzaW9uVGltZXIgLz5cbiAgICAgICAgICAgIDwvc2VjdGlvbj4gKTtcblxuICAgICAgICBpZiAoIXRoaXMucHJvcHMuaXNNaXNzaW9uUnVubmluZykge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgaWQ6ICdub3RfdXNlZCcsXG4gICAgICAgICAgICAgICAgdGV4dDogJ0lra2Uga2xhci4gVmVudGVyIHDDpSBhdCBvcHBkcmFnZXQgc2thbCBzdGFydGUuJyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ2luZm8nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIHsgdGVhbU5hbWVzIH1cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxNZXNzYWdlTGlzdCBjbGFzc05hbWU9J2NvbC14cy0xMidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcz17W21lc3NhZ2VdfS8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9Jyc+XG4gICAgICAgICAgICAgICAge3RlYW1OYW1lc31cbiAgICAgICAgICAgICAgICB7bWlzc2lvblRpbWVyfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgIDxNZXNzYWdlTGlzdCBjbGFzc05hbWU9J2NvbC14cy0xMicgbWVzc2FnZXM9e3RoaXMuc3RhdGUubWVzc2FnZXN9Lz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIHsgLyogaWYgeW91IHdhbnQgdGhpcyB0byBiZSBzdGlja3k6IGh0dHA6Ly9jb2RlcGVuLmlvL3NlbmZmL3Blbi9heUd2RCAqLyB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wteHMtMTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdqdW1ib3Ryb24gdGFza2JveCc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT0ndGFza2JveF9faGVhZGVyJz5PcHBnYXZlPC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9eyd0YXNrYm94X190ZXh0ICcgKyBibGlua30+IHt0aGlzLnN0YXRlLnRhc2tTdG9yZS5jdXJyZW50VGFza30gPC9zcGFuPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0aGlzLnN0YXRlLnRhc2tTdG9yZS5wbGFpbkluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiA8YnV0dG9uIGNsYXNzTmFtZT1cImJ0bi1wcmltYXJ5IGJ0blwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsgdGhpcy5faGFuZGxlVGFza09LQ2xpY2sgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+T0s8L2J1dHRvbj4gfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2s7XG4iLCJjb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBSb3V0ZVN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL3JvdXRlLXN0b3JlJyk7XG5jb25zdCB0ZWFtTmFtZXMgPSByZXF1aXJlKCcuLi90ZWFtLW5hbWUtbWFwJyk7XG5cbmNvbnN0IFRlYW1XaWRnZXQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBjb250ZXh0VHlwZXM6IHtcbiAgICAgICAgcm91dGVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtdLFxuXG4gICAgX29uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vUm91dGVTdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vUm91dGVTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG5cbiAgICB9LFxuXG4gICAgdGVhbU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0ZWFtTmFtZXMubmFtZU1hcFsoUm91dGVTdG9yZS5nZXRUZWFtSWQoKSldO1xuICAgIH0sXG5cbiAgICBvdGhlclRlYW1OYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRlYW1OYW1lcy5vdGhlclRlYW1OYW1lcyhSb3V0ZVN0b3JlLmdldFRlYW1JZCgpKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lID0geyB0aGlzLnByb3BzLmNsYXNzTmFtZSArICcgdGVhbXdpZGdldCd9ID5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lID0gJ2FjdGl2ZScgPnsgdGhpcy50ZWFtTmFtZSgpICB9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWUgPSAnJz4sIHsgdGhpcy5vdGhlclRlYW1OYW1lcygpIH0gPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PiApO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRlYW1XaWRnZXQ7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpLFxuICAgIGFjdGlvbnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL1RpbWVyQWN0aW9uQ3JlYXRvcnMnKSxcbiAgICBUaW1lciA9IHJlcXVpcmUoJy4vdGltZXIucmVhY3QuanMnKSxcbiAgICBUaW1lclN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL3RpbWVyLXN0b3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIHRpbWVySWQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZFxuICAgIH0sXG5cbiAgICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUaW1lclN0YXRlKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFRpbWVyU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5faGFuZGxlVGltZVN0b3JlQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVGltZXJTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLl9oYW5kbGVUaW1lU3RvcmVDaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZS50aW1lSW5TZWNvbmRzICE9PSB0aGlzLnN0YXRlLnRpbWVJblNlY29uZHM7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnVGltZXJQYW5lbC5jb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZVRpbWVTdG9yZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRUaW1lclN0YXRlKCkpO1xuICAgIH0sXG5cbiAgICBfaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIGFjdGlvbnMuc3RhcnRUaW1lcih0aGlzLnByb3BzLnRpbWVySWQpO1xuICAgIH0sXG5cbiAgICBfZ2V0VGltZXJTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWR5OiBUaW1lclN0b3JlLmlzUmVhZHlUb1N0YXJ0KHRoaXMucHJvcHMudGltZXJJZCksXG4gICAgICAgICAgICB0aW1lSW5TZWNvbmRzOiBUaW1lclN0b3JlLmdldFJlbWFpbmluZ1RpbWUodGhpcy5wcm9wcy50aW1lcklkKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e1widGltZXIgXCIgKyB0aGlzLnByb3BzLmNsYXNzTmFtZSB9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3RpbWVyLS1idXR0b24gY29sLXhzLTUgJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9eyAnYnRuIGJ0bi1wcmltYXJ5ICcgKyAodGhpcy5zdGF0ZS5yZWFkeSA/ICcnIDogJ2Rpc2FibGVkJyApIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9oYW5kbGVDbGlja30+U3RhcnQga2xva2thXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd0aW1lci0tdmFsdWUgY29sLXhzLTYgcGFkZGluZy14cy0xJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUaW1lciB0aW1lSW5TZWNvbmRzPXt0aGlzLnN0YXRlLnRpbWVJblNlY29uZHN9Lz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICk7XG4gICAgfVxufSkiLCIvLyBUaGlzIGV4YW1wbGUgY2FuIGJlIG1vZGlmaWVkIHRvIGFjdCBhcyBhIGNvdW50ZG93biB0aW1lclxuXG5cbmNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKSxcbiAgICBwcmludGYgPSByZXF1aXJlKCdwcmludGYnKTtcblxuZnVuY3Rpb24gcGFkKG51bSkge1xuICAgIHJldHVybiBwcmludGYoJyUwMmQnLCBudW0pO1xufVxuXG5cbmNvbnN0IFRpbWVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIHRpbWVJblNlY29uZHM6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ1RpbWVyLmNvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgIH0sXG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQcm9wcy50aW1lSW5TZWNvbmRzICE9PSB0aGlzLnByb3BzLnRpbWVJblNlY29uZHM7XG4gICAgfSxcblxuICAgIF9taW51dGVzKCkge1xuICAgICAgICByZXR1cm4gcGFkKE1hdGgubWF4KDAsIHRoaXMucHJvcHMudGltZUluU2Vjb25kcykgLyA2MCA+PiAwKTtcbiAgICB9LFxuXG4gICAgX3NlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiBwYWQoTWF0aC5tYXgoMCwgdGhpcy5wcm9wcy50aW1lSW5TZWNvbmRzKSAlIDYwKTtcbiAgICB9LFxuXG4gICAgX3RpbWVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbnV0ZXMoKSArICc6JyArIHRoaXMuX3NlY29uZHMoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3RpbWVyLXZhbHVlJz4ge3RoaXMuX3RpbWVWYWx1ZSgpfTwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVyO1xuXG4iLCJ3aW5kb3cuX19hc3RDb25zdCA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgICdHT09EX09YWUdFTic6ICdHT09EX09YWUdFTicsXG4gICAgJ1dBUk5fT1hZR0VOJzogJ1dBUk5fT1hZR0VOJyxcbiAgICAnQ1JJVElDQUxfT1hZR0VOJzogJ0NSSVRJQ0FMX09YWUdFTicsXG4gICAgXCJMT1dfUkVTUF9SQVRFXCI6ICdMT1dfUkVTUF9SQVRFJyxcbiAgICAnSElHSF9SRVNQX1JBVEUnOiAnSElHSF9SRVNQX1JBVEUnLFxuXG4gICAgLyogcmVtb3ZlPyBkb24ndCB0aGluayB0aGV5IGFyZSB1c2VkICovXG4gICAgU0VUX0hFQVJUX1JBVEU6ICdTRVRfSEVBUlRfUkFURScsXG4gICAgU0VUX09YWUdFTl9MRVZFTCA6ICdTRVRfT1hZR0VOX0xFVkVMJyxcbiAgICBTRVRfT1hZR0VOX0NPTlNVTVBUSU9OIDogJ1NFVF9PWFlHRU5fQ09OU1VNUFRJT04nLFxuXG4gICAgSEVBUlRfUkFURV9USU1FUiA6ICdIRUFSVF9SQVRFX1RJTUVSJyxcbiAgICBSRVNQSVJBVElPTl9USU1FUiA6ICdSRVNQSVJBVElPTl9USU1FUidcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvLyBldmVudHNcbiAgICBNRVNTQUdFX0FEREVEOiAnTUVTU0FHRV9BRERFRCcsXG4gICAgUkVNT1ZFX01FU1NBR0U6ICdSRU1PVkVfTUVTU0FHRSdcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdyZWFjdC9saWIva2V5TWlycm9yJykoe1xuICAgIE1JU1NJT05fVElNRV9TWU5DOiAnTUlTU0lPTl9USU1FX1NZTkMnLFxuICAgIE1JU1NJT05fU1RBUlRFRF9FVkVOVDogJ01JU1NJT05fU1RBUlRFRF9FVkVOVCcsXG4gICAgTUlTU0lPTl9TVE9QUEVEX0VWRU5UOiAnTUlTU0lPTl9TVE9QUEVEX0VWRU5UJyxcbiAgICBNSVNTSU9OX0NPTVBMRVRFRF9FVkVOVDogJ01JU1NJT05fQ09NUExFVEVEX0VWRU5UJyxcbiAgICBNSVNTSU9OX1dBU19SRVNFVDogJ01JU1NJT05fV0FTX1JFU0VUJyxcbiAgICBSRUNFSVZFRF9FVkVOVFM6IG51bGwsXG4gICAgSU5UUk9EVUNUSU9OX1JFQUQ6ICdJTlRST0RVQ1RJT05fUkVBRCcsXG4gICAgU1RBUlRfVEFTSzogJ1NUQVJUX1RBU0snLFxuICAgIENPTVBMRVRFRF9UQVNLIDogJ0NPTVBMRVRFRF9UQVNLJyxcbiAgICBBU0tfRk9SX0FQUF9TVEFURTogJ0FTS19GT1JfQVBQX1NUQVRFJyxcbiAgICBSRUNFSVZFRF9BUFBfU1RBVEU6ICdSRUNFSVZFRF9BUFBfU1RBVEUnLFxuICAgIFNFTkRJTkdfVEVBTV9TVEFURTogJ1NFTkRJTkdfVEVBTV9TVEFURSdcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvLyBldmVudHNcbiAgICBST1VURV9DSEFOR0VEX0VWRU5UOiAnUk9VVEVfQ0hBTkdFRF9FVkVOVCcsXG4gICAgUk9VVEVSX0FWQUlMQUJMRTogJ1JPVVRFUl9BVkFJTEFCTEUnLFxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8vIGlkc1xuICAgIFNDSUVOQ0VfVElNRVJfMTogJ1NDSUVOQ0VfVElNRVJfMScsXG4gICAgU0NJRU5DRV9SQURJQVRJT05fV0FSTklOR19NU0cgOiAnU0NJRU5DRV9SQURJQVRJT05fV0FSTklOR19NU0cnLFxuXG4gICAgU0NJRU5DRV9DTEVBUl9SQURJQVRJT05fU0FNUExFUzonU0NJRU5DRV9DTEVBUl9SQURJQVRJT05fU0FNUExFUycsXG5cbiAgICAvLyBldmVudHNcbiAgICBTQ0lFTkNFX0NPVU5URE9XTl9USU1FUl9DSEFOR0VEOiAnU0NJRU5DRV9DT1VOVERPV05fVElNRVJfQ0hBTkdFRCcsXG4gICAgU0NJRU5DRV9UQUtFX1JBRElBVElPTl9TQU1QTEU6ICdTQ0lFTkNFX1RBS0VfUkFESUFUSU9OX1NBTVBMRScsXG4gICAgU0NJRU5DRV9SQURJQVRJT05fTEVWRUxfQ0hBTkdFRDogJ1NDSUVOQ0VfUkFESUFUSU9OX0xFVkVMX0NIQU5HRUQnLFxuICAgIFNDSUVOQ0VfVE9UQUxfUkFESUFUSU9OX0xFVkVMX0NIQU5HRUQ6ICdTQ0lFTkNFX1RPVEFMX1JBRElBVElPTl9MRVZFTF9DSEFOR0VEJyxcbiAgICBTQ0lFTkNFX0FWR19SQURJQVRJT05fQ0FMQ1VMQVRFRDogJ1NDSUVOQ0VfQVZHX1JBRElBVElPTl9DQUxDVUxBVEVEJyxcblxuICAgIC8vIHZhbHVlc1xuICAgIFNDSUVOQ0VfUkFESUFUSU9OX01JTjogMCxcbiAgICBTQ0lFTkNFX1JBRElBVElPTl9NQVg6IDEwMCxcbiAgICBTQ0lFTkNFX0FWR19SQURfR1JFRU5fVkFMVUU6IDAsXG4gICAgU0NJRU5DRV9BVkdfUkFEX09SQU5HRV9WQUxVRTogMTUsXG4gICAgU0NJRU5DRV9BVkdfUkFEX1JFRF9WQUxVRTogNTAsXG4gICAgU0NJRU5DRV9BVkdfUkFEX09SQU5HRV9USFJFU0hPTEQ6IDQwLFxuICAgIFNDSUVOQ0VfQVZHX1JBRF9SRURfVEhSRVNIT0xEOiA3NSxcbiAgICBTQ0lFTkNFX1RPVEFMX1JBRElBVElPTl9TRVJJT1VTX1RIUkVTSE9MRDogNTAsXG4gICAgU0NJRU5DRV9UT1RBTF9SQURJQVRJT05fVkVSWV9TRVJJT1VTX1RIUkVTSE9MRDogNzVcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgU0VUX1RJTUVSOiAnU0VUX1RJTUVSJyxcbiAgICBTVEFSVF9USU1FUjogJ1NUQVJUX1RJTUVSJyxcbiAgICBTVE9QX1RJTUVSOiAnU1RPUF9USU1FUicsXG4gICAgUkVTRVRfVElNRVI6ICdSRVNFVF9USU1FUidcbn07XG5cbiIsIi8vIHByb3h5IGFjY2VzcyB0byB0aGUgcm91dGVyIGFzIGZpcnN0IHN0ZXAgaW4gYnJpbmdpbmcgaXQgaW50byB0aGUgZmx1eCBmbG93XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWNrdC9yZWFjdC1yb3V0ZXIvYmxvYi9tYXN0ZXIvZG9jcy9ndWlkZXMvZmx1eC5tZFxuXG52YXIgcm91dGVyID0gbnVsbDtcblxud2luZG93Ll9fcm91dGVyID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdHJhbnNpdGlvblRvKHRvLHBhcmFtcyxxdWVyeSkge1xuICAgICAgICByZXR1cm4gcm91dGVyLnRyYW5zaXRpb25Ubyh0byxwYXJhbXMscXVlcnkpXG4gICAgfSxcblxuICAgIGdldEN1cnJlbnRQYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9LFxuXG4gICAgZ2V0VGVhbUlkKCl7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50UGF0aG5hbWUoKS5zcGxpdCgnLycpWzFdO1xuICAgIH0sXG5cbiAgICBnZXRUYXNrSWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFBhdGhuYW1lKCkuc3BsaXQoJy8nKVszXTtcbiAgICB9LFxuXG4gICAgcnVuKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlci5ydW4oLi4uYXJncylcbiAgICB9XG59O1xuXG5jb25zdCBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbmNvbnN0IHJvdXRlcyA9IHJlcXVpcmUoJy4vcm91dGVzLnJlYWN0Jyk7XG5cbi8vIEJ5IHRoZSB0aW1lIHJvdXRlIGNvbmZpZyBpcyByZXF1aXJlKCktZCxcbi8vIHJlcXVpcmUoJy4vcm91dGVyJykgYWxyZWFkeSByZXR1cm5zIGEgdmFsaWQgb2JqZWN0XG5cbnJvdXRlciA9IFJvdXRlci5jcmVhdGUoe1xuICAgIHJvdXRlczogcm91dGVzLFxuXG4gICAgLy8gVXNlIHRoZSBIVE1MNSBIaXN0b3J5IEFQSSBmb3IgY2xlYW4gVVJMc1xuICAgIGxvY2F0aW9uOiBSb3V0ZXIuSGlzdG9yeUxvY2F0aW9uXG59KTtcbiIsImNvbnN0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmNvbnN0IFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xuY29uc3QgUm91dGUgPSBSb3V0ZXIuUm91dGU7XG5jb25zdCBOb3RGb3VuZFJvdXRlID0gUm91dGVyLk5vdEZvdW5kUm91dGU7XG5jb25zdCBEZWZhdWx0Um91dGUgPSBSb3V0ZXIuRGVmYXVsdFJvdXRlO1xuXG5jb25zdCBBcHAgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvYXBwLnJlYWN0Jyk7XG5jb25zdCBNaXNzaW9uQ29tbWFuZGVyQXBwID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL21pc3Npb24tY29tbWFuZGVyLnJlYWN0LmpzJyk7XG5jb25zdCBJbmRleEFwcCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9pbmRleC1hcHAucmVhY3QnKTtcbmNvbnN0IE5vdEZvdW5kID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL25vdC1mb3VuZC5yZWFjdCcpO1xuY29uc3QgSW50cm9TY3JlZW4gPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvaW50cm9kdWN0aW9uLXNjcmVlbi5yZWFjdCcpO1xuY29uc3QgU29sYXJTdG9ybSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9mdWxsLXNjcmVlbi12aWRlby5qcycpO1xuY29uc3QgVGFzayA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy90YXNrLnJlYWN0Jyk7XG5jb25zdCBEdW1teVJlbmRlck1peGluID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2R1bW15LXJlbmRlci5taXhpbicpO1xuY29uc3QgeyBjbGVhblJvb3RQYXRoIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB0ZWFtTmFtZU1hcCA9IHJlcXVpcmUoJy4vdGVhbS1uYW1lLW1hcCcpO1xuXG5jb25zdCBSZWRpcmVjdFRvSW50cm8gPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIHdpbGxUcmFuc2l0aW9uVG8odHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdmFyIHRlYW1JZCA9IGNsZWFuUm9vdFBhdGgodHJhbnNpdGlvbi5wYXRoKTtcblxuICAgICAgICAgICAgaWYodGVhbUlkIGluIHRlYW1OYW1lTWFwLm5hbWVNYXApIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KHRyYW5zaXRpb24ucGF0aCArICcvaW50cm8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvL21peGlucyA6IFtEdW1teVJlbmRlck1peGluXVxuICAgIHJlbmRlcigpe1xuICAgICAgICByZXR1cm4gPE5vdEZvdW5kIC8+O1xuICAgIH1cbn0pO1xuXG5jb25zdCByb3V0ZXMgPSAoXG4gICAgPFJvdXRlIG5hbWU9XCJhcHBcIiBwYXRoPVwiL1wiIGhhbmRsZXI9e0FwcH0+XG5cbiAgICAgICAgPFJvdXRlIG5hbWU9XCJqb2ItY29tcGxldGVkXCIgcGF0aD0nL2NvbXBsZXRlZCcgaGFuZGxlcj17U29sYXJTdG9ybX0gLz5cblxuICAgICAgICA8Um91dGUgbmFtZT1cImNvbW1hbmRlclwiIGhhbmRsZXI9e01pc3Npb25Db21tYW5kZXJBcHB9Lz5cbiAgICAgICAgPFJvdXRlIG5hbWU9XCJ0ZWFtLXJvb3RcIiBwYXRoPScvOnRlYW1JZCcgaGFuZGxlcj17UmVkaXJlY3RUb0ludHJvfSAvPlxuICAgICAgICA8Um91dGUgbmFtZT1cInRlYW0taW50cm9cIiBwYXRoPScvOnRlYW1JZC9pbnRybycgaGFuZGxlcj17SW50cm9TY3JlZW59IC8+XG4gICAgICAgIDxSb3V0ZSBuYW1lPVwidGVhbS10YXNrXCIgcGF0aD0nLzp0ZWFtSWQvdGFzay86dGFza0lkJyBoYW5kbGVyPXtUYXNrfSAvPlxuXG4gICAgICAgIDxOb3RGb3VuZFJvdXRlIGhhbmRsZXI9e05vdEZvdW5kfS8+XG4gICAgICAgIDxEZWZhdWx0Um91dGUgaGFuZGxlcj17SW5kZXhBcHB9Lz5cbiAgICA8L1JvdXRlPlxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb3V0ZXM7XG4iLCJjb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0ICBDSEFOR0VfRVZFTlQ9ICdDSEFOR0VfRVZFTlQnO1xuXG52YXIgcGF0aCA9IG51bGw7XG5cbmNsYXNzIEJhc2VTdG9yZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgICBlbWl0Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5UKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIGVtaXR0ZXIsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgICAqL1xuICAgIGFkZENoYW5nZUxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKENIQU5HRV9FVkVOVCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMgZW1pdHRlciwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQ2hhbmdlTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoQ0hBTkdFX0VWRU5ULCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZGlzcGF0Y2hlckluZGV4Ok51bWJlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlU3RvcmU7XG4iLCJjb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgTUNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5jb25zdCBBc3RDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvQXN0cm9UZWFtQ29uc3RhbnRzJyk7XG5jb25zdCBCYXNlU3RvcmUgPSByZXF1aXJlKCcuL2Jhc2Utc3RvcmUnKTtcblxudmFyIGN1cnJlbnQgPSBBc3RDb25zdGFudHMuTE9XX1JFU1BfUkFURTtcblxuY29uc3QgQnJlYXRoUmF0ZVN0b3JlID0gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlU3RvcmUsIHtcblxuICAgIGdldFN0YXRlKCl7XG4gICAgICAgIGlmIChjdXJyZW50ID09IEFzdENvbnN0YW50cy5MT1dfUkVTUF9SQVRFKSB7XG4gICAgICAgICAgICByZXR1cm4ge3JhdGU6IGN1cnJlbnQsIG1pbjogMjMsIG1heDogMjh9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtyYXRlOiBjdXJyZW50LCBtaW46IDQ1LCBtYXg6IDU1fVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogRGlzcGF0Y2hlci5yZWdpc3RlcigocGF5bG9hZCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAocGF5bG9hZC5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTUNvbnN0YW50cy5SRUNFSVZFRF9BUFBfU1RBVEU6XG4gICAgICAgICAgICAgICAgdmFyIGFwcFN0YXRlID0gcGF5bG9hZC5hcHBTdGF0ZTtcblxuICAgICAgICAgICAgICAgIGlmKGFwcFN0YXRlLmJyZWF0aF9yYXRlID09PSAnaGlnaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IEFzdENvbnN0YW50cy5ISUdIX1JFU1BfUkFURTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gQXN0Q29uc3RhbnRzLkxPV19SRVNQX1JBVEU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQnJlYXRoUmF0ZVN0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pXG59KTtcbiIsImNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBNaXNzaW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL01pc3Npb25Db25zdGFudHMnKTtcbmNvbnN0IEJhc2VTdG9yZSA9IHJlcXVpcmUoJy4vYmFzZS1zdG9yZScpO1xuXG52YXIgbGV2ZWwgPSAwO1xudmFyIGZpbHRlckNoYW5nZWQgPSBmYWxzZTtcblxuY29uc3QgQ08yU3RvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSwge1xuXG4gICAgY28yTGV2ZWwoKXtcbiAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH0sXG5cbiAgICBmaWx0ZXJDaGFuZ2VkKCl7XG4gICAgICAgIHJldHVybiBmaWx0ZXJDaGFuZ2VkO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IERpc3BhdGNoZXIucmVnaXN0ZXIoKHBheWxvYWQpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuUkVDRUlWRURfQVBQX1NUQVRFOlxuICAgICAgICAgICAgICAgIHZhciBhcHBTdGF0ZSA9IHBheWxvYWQuYXBwU3RhdGU7XG5cbiAgICAgICAgICAgICAgICBsZXZlbCA9IGFwcFN0YXRlLmNhcmJvbl9kaW94aWRlO1xuICAgICAgICAgICAgICAgIGZpbHRlckNoYW5nZWQgPSBhcHBTdGF0ZS5zY3J1Yl9maWx0ZXJfY2hhbmdlZDtcbiAgICAgICAgICAgICAgICBDTzJTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KVxufSk7XG4iLCJjb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgTWlzc2lvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5jb25zdCBCYXNlU3RvcmUgPSByZXF1aXJlKCcuL2Jhc2Utc3RvcmUnKTtcbnZhciBxdWFsaXR5U2hvdWxkRmFpbCA9IHRydWU7XG52YXIgdHJhbnNmZXJTaG91bGRGYWlsID0gdHJ1ZTtcbnZhciBfcmVhZHlGb3JTYWZlTW9kZSA9IGZhbHNlO1xuXG52YXIgQ29tbXVuaWNhdGlvblF1YWxpdHlTdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlKCksIHtcblxuICAgIHF1YWxpdHlUZXN0U2hvdWxkRmFpbCgpIHtcbiAgICAgICAgcmV0dXJuIHF1YWxpdHlTaG91bGRGYWlsO1xuICAgIH0sXG5cbiAgICB0cmFuc2ZlclRlc3RTaG91bGQoKXtcbiAgICAgICAgcmV0dXJuIHRyYW5zZmVyU2hvdWxkRmFpbDtcbiAgICB9LFxuXG4gICAgcmVhZHlGb3JTYWZlTW9kZSgpe1xuICAgICAgICByZXR1cm4gX3JlYWR5Rm9yU2FmZU1vZGU7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogQXBwRGlzcGF0Y2hlci5yZWdpc3RlcigocGF5bG9hZCk9PiB7XG5cbiAgICAgICAgaWYgKHBheWxvYWQuYWN0aW9uID09PSBNaXNzaW9uQ29uc3RhbnRzLlJFQ0VJVkVEX0FQUF9TVEFURSkge1xuICAgICAgICAgICAgcXVhbGl0eVNob3VsZEZhaWwgPSBwYXlsb2FkLmFwcFN0YXRlLnF1YWxpdHlfdGVzdF9zaG91bGRfZmFpbDtcbiAgICAgICAgICAgIHRyYW5zZmVyU2hvdWxkRmFpbCA9IHBheWxvYWQuYXBwU3RhdGUudHJhbnNmZXJfdGVzdF9zaG91bGRfZmFpbDtcbiAgICAgICAgICAgIF9yZWFkeUZvclNhZmVNb2RlID0gcGF5bG9hZC5hcHBTdGF0ZS5yZWFkeV9mb3Jfc2FmZV9tb2RlO1xuXG4gICAgICAgICAgICBDb21tdW5pY2F0aW9uUXVhbGl0eVN0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH0pXG59KTsiLCJjb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgTUNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5jb25zdCBCYXNlU3RvcmUgPSByZXF1aXJlKCcuL2Jhc2Utc3RvcmUnKTtcblxudmFyIGV2ZW50c0NvbGxlY3Rpb24gPSB7XG4gICAgcmVtYWluaW5nOiBbXSxcbiAgICBjb21wbGV0ZWQ6IFtdLFxuICAgIG92ZXJkdWU6IFtdXG59O1xuXG5jb25zdCBFdmVudFN0b3JlID0gbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuX19ldmVudFN0b3JlID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlLCB7XG5cbiAgICByZW1haW5pbmcoKSB7IHJldHVybiBldmVudHNDb2xsZWN0aW9uLnJlbWFpbmluZzsgfSxcblxuICAgIGNvbXBsZXRlZCgpIHsgcmV0dXJuIGV2ZW50c0NvbGxlY3Rpb24uY29tcGxldGVkOyB9LFxuXG4gICAgb3ZlcmR1ZSgpIHsgcmV0dXJuIGV2ZW50c0NvbGxlY3Rpb24ub3ZlcmR1ZTsgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogRGlzcGF0Y2hlci5yZWdpc3RlcigocGF5bG9hZCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaChwYXlsb2FkLmFjdGlvbil7XG5cbiAgICAgICAgICAgIGNhc2UgTUNvbnN0YW50cy5SRUNFSVZFRF9FVkVOVFM6XG4gICAgICAgICAgICAgICAgZXZlbnRzQ29sbGVjdGlvbi5yZW1haW5pbmcgPSBwYXlsb2FkLnJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBldmVudHNDb2xsZWN0aW9uLm92ZXJkdWUgPSBwYXlsb2FkLm92ZXJkdWU7XG4gICAgICAgICAgICAgICAgZXZlbnRzQ29sbGVjdGlvbi5jb21wbGV0ZWQgPSBwYXlsb2FkLmNvbXBsZXRlZDtcbiAgICAgICAgICAgICAgICBFdmVudFN0b3JlLmVtaXRDaGFuZ2UoKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSlcbn0pO1xuXG5cbi8vd2luZG93Ll9fZXZlbnRTdG9yZSA9IG1vZHVsZS5leHBvcnRzO1xuIiwiY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IE1Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuY29uc3QgQXN0Q29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL0FzdHJvVGVhbUNvbnN0YW50cycpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5cbnZhciBjdXJyZW50ID0ge21pbjogNjAsIG1heDogNzB9O1xuXG5jb25zdCBIZWFydFJhdGVTdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlLCB7XG5cbiAgICAvLyBvbSB2aSB2aWwgYmFja2Ugb3BwIHZlcmRpZXIgcMOlIHNlcnZlciBtw6UgdmkgYnJ1a2UgZGVubmUgc3RvcmVuXG4gICAgZ2V0U3RhdGUoKXtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogRGlzcGF0Y2hlci5yZWdpc3RlcigocGF5bG9hZCkgPT4ge1xuXG4gICAgICAgIHN3aXRjaCAocGF5bG9hZC5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTUNvbnN0YW50cy5SRUNFSVZFRF9BUFBfU1RBVEU6XG4gICAgICAgICAgICAgICAgdmFyIHJhdGUgPSBwYXlsb2FkLmFwcFN0YXRlLmhlYXJ0X3JhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHJhdGUgJiYgcmF0ZS5taW4gJiYgcmF0ZS5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHJhdGU7XG4gICAgICAgICAgICAgICAgICAgIEhlYXJ0UmF0ZVN0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KVxufSk7XG4iLCIvKiBIb2xkcyB0aGUgc3RhdGUgb2Ygd2hldGhlciBpbnRyb2R1Y3Rpb25zIGhhdmUgYmVlbiByZWFkICovXG5cbmNvbnN0IEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBCYXNlU3RvcmUgPSByZXF1aXJlKCcuL2Jhc2Utc3RvcmUnKTtcbmNvbnN0IE1pc3Npb25Db25zdGFudHM9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5jb25zdCBSb3V0ZVN0b3JlID0gcmVxdWlyZSgnLi9yb3V0ZS1zdG9yZScpO1xuXG52YXIgaW50cm9SZWFkID0ge307XG5cbmNvbnN0IEludHJvZHVjdGlvblN0b3JlID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlKCksIHtcblxuICAgIHNldEludHJvZHVjdGlvblJlYWQodGVhbSkge1xuICAgICAgICBpbnRyb1JlYWRbJ2ludHJvXycrdGVhbV0gPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgaXNJbnRyb2R1Y3Rpb25SZWFkKHRlYW0pIHtcbiAgICAgICAgaWYoIXRlYW0pIHsgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGFyZ3VtZW50IFwidGVhbVwiJyk7IH1cblxuICAgICAgICByZXR1cm4gaW50cm9SZWFkWydpbnRyb18nK3RlYW1dO1xuICAgIH0sXG5cblxuICAgIGRpc3BhdGNoZXJJbmRleDogQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gcGF5bG9hZC5hY3Rpb247XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5JTlRST0RVQ1RJT05fUkVBRDpcbiAgICAgICAgICAgICAgICBJbnRyb2R1Y3Rpb25TdG9yZS5zZXRJbnRyb2R1Y3Rpb25SZWFkKHBheWxvYWQudGVhbU5hbWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuUkVDRUlWRURfQVBQX1NUQVRFOlxuICAgICAgICAgICAgICAgIHZhciB0ZWFtSWQgPSBSb3V0ZVN0b3JlLmdldFRlYW1JZCgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRlYW1TdGF0ZSA9IHBheWxvYWQuYXBwU3RhdGVbdGVhbUlkXTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZWFtU3RhdGUgJiYgdGVhbVN0YXRlLmludHJvZHVjdGlvbl9yZWFkICkge1xuICAgICAgICAgICAgICAgICAgICBJbnRyb2R1Y3Rpb25TdG9yZS5zZXRJbnRyb2R1Y3Rpb25SZWFkKHRlYW1TdGF0ZS50ZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gZXJyb3JzLiBOZWVkZWQgYnkgcHJvbWlzZSBpbiBEaXNwYXRjaGVyLlxuICAgIH0pXG5cbn0pO1xuXG53aW5kb3cuX19JbnRyb2R1Y3Rpb25TdG9yZT0gSW50cm9kdWN0aW9uU3RvcmU7XG5tb2R1bGUuZXhwb3J0cyA9IEludHJvZHVjdGlvblN0b3JlO1xuIiwiLyogQSBzdG9yZSB0aGF0IGNhbiBiZSBxdWVyaWVkIGZvciB0aGUgY3VycmVudCBwYXRoICovXG5cbmNvbnN0IHsgRW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5jb25zdCB7IFJFTU9WRV9NRVNTQUdFLCBNRVNTQUdFX0FEREVEIH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWVzc2FnZUNvbnN0YW50cycpO1xudmFyIG1lc3NhZ2VzID0ge307XG5cblxudmFyIE1lc3NhZ2VTdG9yZSA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSgpLCB7XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgbWVzc2FnZXMgPSB7fTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIGhhbmRsZUFkZGVkTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGRhdGEuZGlzbWlzc2FibGUgPSBkYXRhLmRpc21pc3NhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogZGF0YS5kaXNtaXNzYWJsZTtcbiAgICAgICAgbWVzc2FnZXNbZGF0YS5pZF0gPSBkYXRhO1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlUmVtb3ZlTWVzc2FnZShpZCkge1xuICAgICAgICBkZWxldGUgbWVzc2FnZXNbaWRdO1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFsbCBtZXNzYWdlcyBtYXRjaGluZyBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gW2ZpbHRlcl1cbiAgICAgKiBAcmV0dXJucyBbXU1lc3NhZ2UgYSBNZXNzYWdlID0geyB0ZXh0LCBpZCwgbGV2ZWwgfVxuICAgICAqL1xuICAgIGdldE1lc3NhZ2VzKGZpbHRlcikge1xuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5tYXAoKG1zZ0tleSk9PiAgbWVzc2FnZXNbbXNnS2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1VOSU1QTEVNRU5URUQgXCJmaWx0ZXJcIiBmZWF0dXJlJyk7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgeyBhY3Rpb24sIGRhdGEgfSA9IHBheWxvYWQ7XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTUVTU0FHRV9BRERFRDpcbiAgICAgICAgICAgICAgICBNZXNzYWdlU3RvcmUuaGFuZGxlQWRkZWRNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSRU1PVkVfTUVTU0FHRTpcbiAgICAgICAgICAgICAgICBNZXNzYWdlU3RvcmUuaGFuZGxlUmVtb3ZlTWVzc2FnZShkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBlcnJvcnMuIE5lZWRlZCBieSBwcm9taXNlIGluIERpc3BhdGNoZXIuXG4gICAgfSlcblxufSk7XG5cbndpbmRvdy5fX01lc3NhZ2VTdG9yZSA9IE1lc3NhZ2VTdG9yZTtcbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVN0b3JlO1xuIiwiLyogQSBzdG9yZSB0aGF0IGNhbiBiZSBxdWVyaWVkIGZvciB0aGUgY3VycmVudCBwYXRoICovXG5cbmNvbnN0IHsgRW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5jb25zdCB7IE1JU1NJT05fU1RBUlRFRF9FVkVOVCxNSVNTSU9OX1NUT1BQRURfRVZFTlQsIFJFQ0VJVkVEX0FQUF9TVEFURSB9ID0gIHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5cbnZhciBtaXNzaW9uUnVubmluZyA9IGZhbHNlLCBtaXNzaW9uSGFzQmVlblN0b3BwZWQgPSBmYWxzZTtcbnZhciBjdXJyZW50Q2hhcHRlciA9IG51bGw7XG52YXIgY2hhcHRlclRpbWUgPSAwO1xudmFyIGluU2FmZU1vZGUgPSBmYWxzZTtcblxudmFyIE1pc3Npb25TdGF0ZVN0b3JlID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlKCksIHtcblxuICAgIGhhbmRsZU1pc3Npb25TdGFydGVkKCkge1xuICAgICAgICBtaXNzaW9uUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH0sXG5cbiAgICBoYW5kbGVNaXNzaW9uU3RvcHBlZCgpIHtcbiAgICAgICAgbWlzc2lvblJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIGlzU2F0ZWxsaXRlSW5TYWZlTW9kZSgpe1xuICAgICAgICByZXR1cm4gaW5TYWZlTW9kZTtcbiAgICB9LFxuXG4gICAgaXNNaXNzaW9uUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIG1pc3Npb25SdW5uaW5nO1xuICAgIH0sXG5cbiAgICBpc01pc3Npb25TdG9wcGVkKCkge1xuICAgICAgICByZXR1cm4gbWlzc2lvbkhhc0JlZW5TdG9wcGVkO1xuICAgIH0sXG5cbiAgICBjdXJyZW50Q2hhcHRlcigpe1xuICAgICAgICByZXR1cm4gY3VycmVudENoYXB0ZXI7XG4gICAgfSxcblxuICAgIGNoYXB0ZXJUaW1lKCl7XG4gICAgICAgIHJldHVybiBjaGFwdGVyVGltZTtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hlckluZGV4OiBBcHBEaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciB7IGFjdGlvbn0gPSBwYXlsb2FkO1xuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1JU1NJT05fU1RBUlRFRF9FVkVOVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWlzc2lvblN0YXRlU3RvcmUuaGFuZGxlTWlzc2lvblN0YXJ0ZWQoKTtcblxuICAgICAgICAgICAgY2FzZSBNSVNTSU9OX1NUT1BQRURfRVZFTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1pc3Npb25TdGF0ZVN0b3JlLmhhbmRsZU1pc3Npb25TdG9wcGVkKCk7XG5cbiAgICAgICAgICAgIGNhc2UgUkVDRUlWRURfQVBQX1NUQVRFOlxuICAgICAgICAgICAgICAgIGxldCBhcHBTdGF0ZSA9IHBheWxvYWQuYXBwU3RhdGU7XG4gICAgICAgICAgICAgICAgbWlzc2lvblJ1bm5pbmcgPSBhcHBTdGF0ZS5taXNzaW9uX3J1bm5pbmc7XG4gICAgICAgICAgICAgICAgY3VycmVudENoYXB0ZXIgPSBhcHBTdGF0ZS5jdXJyZW50X2NoYXB0ZXI7XG4gICAgICAgICAgICAgICAgY2hhcHRlclRpbWUgPSBhcHBTdGF0ZS5lbGFwc2VkX2NoYXB0ZXJfdGltZTtcbiAgICAgICAgICAgICAgICBpblNhZmVNb2RlID0gYXBwU3RhdGUuc2F0ZWxsaXRlX2luX3NhZmVfbW9kZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBNaXNzaW9uU3RhdGVTdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gZXJyb3JzLiBOZWVkZWQgYnkgcHJvbWlzZSBpbiBEaXNwYXRjaGVyLlxuICAgIH0pXG5cbn0pO1xuXG53aW5kb3cuX19NaXNzaW9uU3RhdGVTdG9yZSA9IE1pc3Npb25TdGF0ZVN0b3JlO1xubW9kdWxlLmV4cG9ydHMgPSBNaXNzaW9uU3RhdGVTdG9yZTtcbiIsImNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBNaXNzaW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL01pc3Npb25Db25zdGFudHMnKTtcbmNvbnN0IEFzdENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9Bc3Ryb1RlYW1Db25zdGFudHMnKTtcbmNvbnN0IEJhc2VTdG9yZSA9IHJlcXVpcmUoJy4vYmFzZS1zdG9yZScpO1xuXG52YXIgX3N0YXR1cyA9IEFzdENvbnN0YW50cy5HT09EX09YWUdFTjtcbnZhciBjb25zdW1wdGlvblBlck1pbnV0ZSA9IG51bGw7XG52YXIgcmVtYWluaW5nID0gMTAwO1xuXG5jb25zdCBPeHlnZW5TdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZVN0b3JlLCB7XG5cbiAgICBzdGF0dXMoKXtcbiAgICAgICAgcmV0dXJuIF9zdGF0dXM7XG4gICAgfSxcblxuICAgIHN0YXR1c0FzQ29sb3IoKXtcbiAgICAgICAgc3dpdGNoIChfc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIEFzdENvbnN0YW50cy5DUklUSUNBTF9PWFlHRU46XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZWQnO1xuICAgICAgICAgICAgY2FzZSBBc3RDb25zdGFudHMuV0FSTl9PWFlHRU46XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvcmFuZ2UnO1xuICAgICAgICAgICAgY2FzZSBBc3RDb25zdGFudHMuR09PRF9PWFlHRU46XG4gICAgICAgICAgICAgICAgcmV0dXJuICdncmVlbidcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTdGF0ZSgpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sb3JJbmRpY2F0b3I6IHRoaXMuc3RhdHVzQXNDb2xvcigpLFxuICAgICAgICAgICAgY29uc3VtcHRpb25QZXJNaW51dGU6IGNvbnN1bXB0aW9uUGVyTWludXRlLFxuICAgICAgICAgICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IERpc3BhdGNoZXIucmVnaXN0ZXIoKHBheWxvYWQpID0+IHtcblxuICAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuUkVDRUlWRURfQVBQX1NUQVRFOlxuICAgICAgICAgICAgICAgIHZhciBhcHBTdGF0ZSA9IHBheWxvYWQuYXBwU3RhdGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXBwU3RhdGUub3h5Z2VuX2NvbnN1bXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bXB0aW9uUGVyTWludXRlID0gYXBwU3RhdGUub3h5Z2VuX2NvbnN1bXB0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdW1wdGlvblBlck1pbnV0ZSA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIF9zdGF0dXMgIT09IEFzdENvbnN0YW50cy5DUklUSUNBTF9PWFlHRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0dXMgPSBBc3RDb25zdGFudHMuV0FSTl9PWFlHRU5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb25zdW1wdGlvblBlck1pbnV0ZSA8IDIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXR1cyA9IEFzdENvbnN0YW50cy5HT09EX09YWUdFTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIE94eWdlblN0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXBwU3RhdGUub3h5Z2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IGFwcFN0YXRlLm94eWdlbjtcbiAgICAgICAgICAgICAgICAgICAgT3h5Z2VuU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pXG59KTtcbiIsIi8qIEEgc2luZ2xldG9uIHN0b3JlIHRoYXQgY2FuIGJlIHF1ZXJpZWQgZm9yIHJlbWFpbmluZyB0aW1lICovXG5cbmNvbnN0IEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9hcHBkaXNwYXRjaGVyJyk7XG5jb25zdCBCYXNlU3RvcmUgPSByZXF1aXJlKCcuL2Jhc2Utc3RvcmUnKTtcbmNvbnN0IFNjaWVuY2VUZWFtQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL1NjaWVuY2VUZWFtQ29uc3RhbnRzJyk7XG5jb25zdCBNaXNzaW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL01pc3Npb25Db25zdGFudHMnKTtcbmNvbnN0IHJhbmRvbUludCA9IHJlcXVpcmUoJy4uL3V0aWxzJykucmFuZG9tSW50O1xuY29uc3QgcmFkaWF0aW9uUmFuZ2UgPSB7XG4gICAgbWluOiA1LFxuICAgIG1heDogMjBcbn07XG52YXIgc2FtcGxlcyA9IFtdO1xudmFyIHRvdGFsUmFkaWF0aW9uID0gMDtcbnZhciBsYXN0Q2FsY3VsYXRlZEF2ZXJhZ2UgPSBudWxsO1xuXG5jb25zdCBSYWRpYXRpb25TdG9yZSA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSgpLCB7XG5cbiAgICBfc2V0UmFkaWF0aW9uTGV2ZWwobWluLCBtYXgpIHtcbiAgICAgICAgcmFkaWF0aW9uUmFuZ2UubWluID0gbWluO1xuICAgICAgICByYWRpYXRpb25SYW5nZS5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH0sXG5cbiAgICBfY2xlYXJTYW1wbGVzKCkge1xuICAgICAgICBzYW1wbGVzID0gW107XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH0sXG5cbiAgICBfdGFrZVNhbXBsZSgpIHtcbiAgICAgICAgc2FtcGxlcy5wdXNoKHRoaXMuZ2V0TGV2ZWwoKSk7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH0sXG5cbiAgICBnZXRMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRvbUludChyYWRpYXRpb25SYW5nZS5taW4sIHJhZGlhdGlvblJhbmdlLm1heCk7XG4gICAgfSxcblxuICAgIGdldFRvdGFsTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0b3RhbFJhZGlhdGlvbjtcbiAgICB9LFxuXG4gICAgZ2V0U2FtcGxlcygpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZXMuc2xpY2UoKTtcbiAgICB9LFxuXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzYW1wbGVzOiBzYW1wbGVzLnNsaWNlKDApLFxuICAgICAgICAgICAgdG90YWw6IHRvdGFsUmFkaWF0aW9uLFxuICAgICAgICAgICAgY3VycmVudExldmVsOiB0aGlzLmdldExldmVsKCksXG4gICAgICAgICAgICBsYXN0Q2FsY3VsYXRlZEF2ZXJhZ2U6IGxhc3RDYWxjdWxhdGVkQXZlcmFnZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BhdGNoZXJJbmRleDogQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgeyBhY3Rpb24sIGRhdGF9ID0gcGF5bG9hZDtcblxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1JBRElBVElPTl9MRVZFTF9DSEFOR0VEOlxuICAgICAgICAgICAgICAgIFJhZGlhdGlvblN0b3JlLl9zZXRSYWRpYXRpb25MZXZlbChkYXRhLm1pbiwgZGF0YS5tYXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY2llbmNlVGVhbUNvbnN0YW50cy5TQ0lFTkNFX1RPVEFMX1JBRElBVElPTl9MRVZFTF9DSEFOR0VEOlxuICAgICAgICAgICAgICAgIHRvdGFsUmFkaWF0aW9uID0gZGF0YS50b3RhbDtcbiAgICAgICAgICAgICAgICBSYWRpYXRpb25TdG9yZS5lbWl0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9UQUtFX1JBRElBVElPTl9TQU1QTEU6XG4gICAgICAgICAgICAgICAgUmFkaWF0aW9uU3RvcmUuX3Rha2VTYW1wbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9BVkdfUkFESUFUSU9OX0NBTENVTEFURUQ6XG4gICAgICAgICAgICAgICAgbGFzdENhbGN1bGF0ZWRBdmVyYWdlID0gZGF0YS5hdmVyYWdlO1xuICAgICAgICAgICAgICAgIFJhZGlhdGlvblN0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NpZW5jZVRlYW1Db25zdGFudHMuU0NJRU5DRV9DTEVBUl9SQURJQVRJT05fU0FNUExFUzpcbiAgICAgICAgICAgICAgICBzYW1wbGVzID0gW107XG4gICAgICAgICAgICAgICAgUmFkaWF0aW9uU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuUkVDRUlWRURfQVBQX1NUQVRFOlxuICAgICAgICAgICAgICAgIGxldCBhcHBTdGF0ZSA9IHBheWxvYWQuYXBwU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHJhZGlhdGlvbkxldmVsID0gYXBwU3RhdGUucmFkaWF0aW9uX2xldmVsO1xuXG4gICAgICAgICAgICAgICAgUmFkaWF0aW9uU3RvcmUuX3NldFJhZGlhdGlvbkxldmVsKHJhZGlhdGlvbkxldmVsLmxvdyxyYWRpYXRpb25MZXZlbC5oaWdoKTtcblxuICAgICAgICAgICAgICAgIGlmKGFwcFN0YXRlLnNjaWVuY2UgJiYgYXBwU3RhdGUuc2NpZW5jZS5yYWRpYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhZGlhdGlvblN0YXRlID0gYXBwU3RhdGUuc2NpZW5jZS5yYWRpYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSByYWRpYXRpb25TdGF0ZS5zYW1wbGVzO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2FsY3VsYXRlZEF2ZXJhZ2UgPSByYWRpYXRpb25TdGF0ZS5sYXN0Q2FsY3VsYXRlZEF2ZXJhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsUmFkaWF0aW9uID0gcmFkaWF0aW9uU3RhdGUudG90YWw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUmFkaWF0aW9uU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuTUlTU0lPTl9XQVNfUkVTRVQ6XG4gICAgICAgICAgICAgICAgc2FtcGxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxhc3RDYWxjdWxhdGVkQXZlcmFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdG90YWxSYWRpYXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIGVycm9ycy4gTmVlZGVkIGJ5IHByb21pc2UgaW4gRGlzcGF0Y2hlci5cbiAgICB9KVxuXG59KTtcblxud2luZG93Ll9fUmFkaWF0aW9uU3RvcmUgPSBSYWRpYXRpb25TdG9yZTtcbm1vZHVsZS5leHBvcnRzID0gUmFkaWF0aW9uU3RvcmU7XG4iLCIvKiBBIHN0b3JlIHRoYXQgY2FuIGJlIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHBhdGggKi9cblxuY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IEJhc2VTdG9yZSA9IHJlcXVpcmUoJy4vYmFzZS1zdG9yZScpO1xuY29uc3QgeyBST1VURV9DSEFOR0VEX0VWRU5UIH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMvUm91dGVyQ29uc3RhbnRzJyk7XG5jb25zdCB7IGNsZWFuUm9vdFBhdGggfT0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIHJvdXRlciA9IHJlcXVpcmUoJy4uL3JvdXRlci1jb250YWluZXInKVxuXG52YXIgUm91dGVTdG9yZSA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSgpLCB7XG5cbiAgICBoYW5kbGVSb3V0ZUNoYW5nZWQoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcblxuICAgIGdldFRlYW1JZCgpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlci5nZXRUZWFtSWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0VGFza0lkKCkge1xuICAgICAgICByZXR1cm4gcm91dGVyLmdldFRhc2tJZCgpO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IEFwcERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHBheWxvYWQuYWN0aW9uO1xuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFJPVVRFX0NIQU5HRURfRVZFTlQ6XG4gICAgICAgICAgICAgICAgUm91dGVTdG9yZS5oYW5kbGVSb3V0ZUNoYW5nZWQocGF5bG9hZC5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gZXJyb3JzLiBOZWVkZWQgYnkgcHJvbWlzZSBpbiBEaXNwYXRjaGVyLlxuICAgIH0pXG5cbn0pO1xuXG53aW5kb3cuX19Sb3V0ZVN0b3JlID0gUm91dGVTdG9yZTtcbm1vZHVsZS5leHBvcnRzID0gUm91dGVTdG9yZTtcbiIsIi8qIEEgc3RvcmUgdGhhdCBjYW4gYmUgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgcGF0aCAqL1xuXG5jb25zdCBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vYXBwZGlzcGF0Y2hlcicpO1xuY29uc3QgQmFzZVN0b3JlID0gcmVxdWlyZSgnLi9iYXNlLXN0b3JlJyk7XG5jb25zdCBSb3V0ZVN0b3JlID0gcmVxdWlyZSgnLi9yb3V0ZS1zdG9yZScpO1xuY29uc3QgTWlzc2lvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9NaXNzaW9uQ29uc3RhbnRzJyk7XG5cbnZhciBhd2FpdGluZ05ld0luc3RydWN0aW9ucyA9IHtcbiAgICAndGV4dCc6ICdWZW50ZXIgcMOlIG55ZSBpbnN0cnVrc2pvbmVyIC4uLidcbn07XG5cbnZhciBhc3NpZ25tZW50cyA9IHtcbiAgICBzY2llbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgICAgIHNhbXBsZToge1xuICAgICAgICAgICAgdGV4dDogJ1N0YXJ0IGtsb2trYSBvZyB0YSBmaXJlIG3DpWxpbmdlciBqZXZudCBmb3JkZWx0IHV0b3ZlciBkZSAzMCBzZWt1bmRlbmUnLFxuICAgICAgICAgICAgbmV4dDogJ2F2ZXJhZ2UnXG4gICAgICAgIH0sXG4gICAgICAgIGF2ZXJhZ2U6IHtcbiAgICAgICAgICAgIHRleHQ6ICdSZWduIHV0IGdqZW5ub21zbml0dHN2ZXJkaWVuIGF2IHN0csOlbGluZ3N2ZXJkaWVuZSBkZXJlIGZhbnQuIFNrcml2IGRlbiBpbm4gaSB0ZWtzdGZlbHRldC4nLFxuICAgICAgICAgICAgbmV4dDogJ2FkZHRvdGFsJ1xuICAgICAgICB9LFxuICAgICAgICBhZGR0b3RhbDoge1xuICAgICAgICAgICAgdGV4dDogJ0Jhc2VydCBww6UgZmFyZ2VuIHNvbSBibGUgaW5kaWtlcnQgdmVkIGV2YWx1ZXJpbmcgYXYgZ2plbm5vbXNuaXR0c3ZlcmRpZW4gJ1xuICAgICAgICAgICAgKyAnc2thbCB2aSBuw6UgbGVnZ2UgdGlsIGV0IHRhbGwgdGlsIHRvdGFsdCBmdW5uZXQgc3Ryw6VsaW5nc21lbmdkZS4nXG4gICAgICAgICAgICArICcgRm9yIGdyw7hubiBzdGF0dXMgbWFuIGxlZ2dlIHRpbCAwLCAnXG4gICAgICAgICAgICArICcgZm9yIG9yYW5zaiBzdGF0dXMgbWFuIGxlZ2dlIHRpbCAxNSwgJ1xuICAgICAgICAgICAgKyAnIGZvciByw7hkIHN0YXR1cyBtYW4gbGVnZ2UgdGlsIDUwLidcbiAgICAgICAgICAgICsgJyBEZW4gdG90YWxlIHN0csOlbGluZ3N2ZXJkaWVuIGkga3JvcHBlbiBza2FsIGhlbHN0IGlra2UgZ8OlIG92ZXIgNTAsIG9nIGFsZHJpIG92ZXIgNzUhJyxcbiAgICAgICAgICAgIG5leHQ6ICdhd2FpdGluZydcbiAgICAgICAgfSxcbiAgICAgICAgYXdhaXRpbmc6IGF3YWl0aW5nTmV3SW5zdHJ1Y3Rpb25zXG4gICAgfSxcblxuICAgIGFzdHJvbmF1dDoge1xuICAgICAgICBjdXJyZW50OiBudWxsLFxuICAgICAgICBhd2FpdGluZzogYXdhaXRpbmdOZXdJbnN0cnVjdGlvbnMsXG4gICAgICAgIGJyZWF0aGluZ190aW1lcjoge1xuICAgICAgICAgICAgdGV4dDogJ1N0YXJ0IGtsb2trYSwgb2cgdGVsbCBhbnRhbGwgaW5ucHVzdCAodG9wcGVyKSBww6UgcHVzdGVncmFmZW4uJyxcbiAgICAgICAgICAgIG5leHQ6ICdicmVhdGhpbmdfY2FsY3VsYXRlJyxcbiAgICAgICAgICAgIHBsYWluX2luZm86IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgYnJlYXRoaW5nX2NhbGN1bGF0ZToge1xuICAgICAgICAgICAgdGV4dDogJ0h2b3IgbWFuZ2UgaW5ucHVzdCBibGlyIGRldCBww6UgZXR0IG1pbnV0dD8gQnJ1ayB0YWxsZXQgZHUgZmlubmVyIHRpbCDDpSByZWduZSB1dCBva3N5Z2VuZm9yYnJ1a2V0IHByIG1pbnV0dC4gR2plbm5vbXNuaXR0bGlnIG9rc3lnZW5mb3JicnVrIG1lZCAyNSBpbm5wdXN0IGkgbWludXR0ZXQgZXIgMSBva3N5Z2VuZW5oZXQuJyxcbiAgICAgICAgICAgIG5leHQ6ICdoZWFydHJhdGVfdGltZXInXG4gICAgICAgIH0sXG4gICAgICAgIGhlYXJ0cmF0ZV90aW1lcjoge1xuICAgICAgICAgICAgdGV4dDogJ1N0YXJ0IGtsb2trYSBvZyB0ZWxsIGFudGFsbCBoamVydGVzbGFnIHDDpSB0aSBzZWt1bmRlcicsXG4gICAgICAgICAgICBuZXh0OiAnaGVhcnRyYXRlX2NhbGN1bGF0ZScsXG4gICAgICAgICAgICBwbGFpbl9pbmZvOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGhlYXJ0cmF0ZV9jYWxjdWxhdGU6IHtcbiAgICAgICAgICAgIHRleHQ6ICdGaW5uIG7DpSB1dCBodm9yIG1hbmdlIHNsYWcgZGV0IGJsaXIgaSBtaW51dHRldC4gRXZhbHVlciByZXN1bHRhdGV0IHZlZCDDpSBza3JpdmUgZGV0IGlubiBpIHRla3N0ZmVsdGV0LicsXG4gICAgICAgICAgICBuZXh0OiAnYXdhaXRpbmcnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VjdXJpdHk6IHtcbiAgICAgICAgY3VycmVudCA6IG51bGwsXG4gICAgICAgIGF3YWl0aW5nIDogYXdhaXRpbmdOZXdJbnN0cnVjdGlvbnMsXG5cbiAgICAgICAgc2NydWJiZXIgOntcbiAgICAgICAgICAgIHRleHQgOiAnTk9UIFNVUkUgQUJPVVQgVEhJUyBPTkUuIEkgVEhJTksgSVQgV0lMTCBCRSBUUklHR0VSRUQgV0lUSE9VVCBBTlkgTkVFRCBGT1IgSU5TVFJVQ1RJT05TJyxcbiAgICAgICAgICAgIG5leHQgOiAnYXdhaXRpbmcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2lnbmFsX3Rlc3QgOiB7XG4gICAgICAgICAgICB0ZXh0IDogJ1NqZWtrIG9tIGRhdGFvdmVyZsO4cmluZ2VyIGxhciBzZWcgZ2rDuHJlLiBPbSBkZXQgZ8OlciBicmEga2FuIGRlcmUgdGVzdGUgb20gZGF0YWt2YWxpdGV0ZW4gZXIgdGlsZnJlZHNzdGlsbGVuZGUnLFxuICAgICAgICAgICAgbmV4dCA6ICdhd2FpdGluZydcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21tdW5pY2F0aW9uIDoge1xuICAgICAgICBjdXJyZW50IDogbnVsbCxcbiAgICAgICAgYXdhaXRpbmcgOiBhd2FpdGluZ05ld0luc3RydWN0aW9ucyxcblxuICAgICAgICBjb21tX2NoZWNrIDoge1xuICAgICAgICAgICAgdGV4dCA6ICdTamVrayBzdGF0dXMgcMOlIGtvbW11bmlrYXNqb25zbGlua2VuLiBPbSBzaWduYWxldCBlciBzdmFrdCBiw7hyIGVuIGFubmVuIHNhdGVsaXR0IHZlbGdlcy4gJ1xuICAgICAgICAgICAgKydPbSBkZXJlIHZlbGdlciBlbiBhbm5lbiBzYXRlbGl0dCBtw6UgZGVyZSBvZ3PDpSB2ZWxnZSBlbiBmcmVrdmVucyBmcmEgZnJla3ZlbnNiw6VuZGV0LiAnXG4gICAgICAgICAgICArICdEZXQgYmVzdGUgdmFsZ2V0IGF2IGZyZWt2ZW5zIGVyIHZhbmxpZ3ZpcyBtaWR0IGkgZnJla3ZlbnNiw6VuZGV0LiAnXG4gICAgICAgIH1cblxuICAgIH1cbn07XG5cbnZhciBUYXNrU3RvcmUgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlU3RvcmUoKSwge1xuXG4gICAgZ2V0Q3VycmVudFRhc2soKSB7XG4gICAgICAgIHZhciB0ZWFtSWQgPSBSb3V0ZVN0b3JlLmdldFRlYW1JZCgpO1xuICAgICAgICB2YXIgYXNzaWdubWVudHNGb3JUZWFtID0gYXNzaWdubWVudHNbdGVhbUlkXTtcbiAgICAgICAgcmV0dXJuIChhc3NpZ25tZW50c0ZvclRlYW0gJiYgYXNzaWdubWVudHNGb3JUZWFtW3RoaXMuZ2V0Q3VycmVudFRhc2tJZCh0ZWFtSWQpXSlcbiAgICAgICAgICAgIHx8ICdJbmdlbiBvcHBnYXZlIGZ1bm5ldCc7XG4gICAgfSxcblxuICAgIGdldEN1cnJlbnRUYXNrSWQodGVhbUlkID0gUm91dGVTdG9yZS5nZXRUZWFtSWQoKSkge1xuICAgICAgICBpZiAoIXRlYW1JZC5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ25tZW50c1t0ZWFtSWRdLmN1cnJlbnQgfHwgJ2F3YWl0aW5nJztcbiAgICB9LFxuXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50VGFza0lkOiB0aGlzLmdldEN1cnJlbnRUYXNrSWQoKSxcbiAgICAgICAgICAgIGN1cnJlbnRUYXNrOiB0aGlzLmdldEN1cnJlbnRUYXNrKCkudGV4dCxcbiAgICAgICAgICAgIG5leHRUYXNrSWQ6IHRoaXMuZ2V0Q3VycmVudFRhc2soKS5uZXh0LFxuICAgICAgICAgICAgcGxhaW5JbmZvOiB0aGlzLmdldEN1cnJlbnRUYXNrKCkucGxhaW5faW5mb1xuICAgICAgICB9O1xuICAgIH0sXG5cblxuICAgIGRpc3BhdGNoZXJJbmRleDogQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgdGFza0lkO1xuICAgICAgICB2YXIgdGVhbUlkO1xuICAgICAgICB2YXIgY3VycmVudFRhc2s7XG4gICAgICAgIHZhciB0ZWFtVGFza3M7XG5cbiAgICAgICAgc3dpdGNoIChwYXlsb2FkLmFjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuU1RBUlRfVEFTSzpcbiAgICAgICAgICAgICAgICB0ZWFtSWQgPSBwYXlsb2FkLnRlYW1JZDtcbiAgICAgICAgICAgICAgICB0YXNrSWQgPSBwYXlsb2FkLnRhc2tJZDtcblxuICAgICAgICAgICAgICAgIHRlYW1UYXNrcyA9IGFzc2lnbm1lbnRzW3RlYW1JZF07XG4gICAgICAgICAgICAgICAgdGVhbVRhc2tzLmN1cnJlbnQgPSB0YXNrSWQ7XG4gICAgICAgICAgICAgICAgVGFza1N0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBNaXNzaW9uQ29uc3RhbnRzLkNPTVBMRVRFRF9UQVNLOlxuICAgICAgICAgICAgICAgIHRlYW1JZCA9IHBheWxvYWQudGVhbUlkO1xuICAgICAgICAgICAgICAgIHRhc2tJZCA9IHBheWxvYWQudGFza0lkO1xuXG4gICAgICAgICAgICAgICAgdGVhbVRhc2tzID0gYXNzaWdubWVudHNbdGVhbUlkXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHRlYW1UYXNrc1t0YXNrSWRdO1xuICAgICAgICAgICAgICAgIHRlYW1UYXNrcy5jdXJyZW50ID0gY3VycmVudFRhc2submV4dDtcbiAgICAgICAgICAgICAgICBUYXNrU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuUkVDRUlWRURfQVBQX1NUQVRFOlxuICAgICAgICAgICAgICAgIHRlYW1JZCA9IFJvdXRlU3RvcmUuZ2V0VGVhbUlkKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGVhbVN0YXRlID0gcGF5bG9hZC5hcHBTdGF0ZVt0ZWFtSWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRlYW1TdGF0ZSAmJiB0ZWFtU3RhdGUuY3VycmVudF90YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gdGVhbVN0YXRlLmN1cnJlbnRfdGFzaztcbiAgICAgICAgICAgICAgICAgICAgdGVhbVRhc2tzID0gYXNzaWdubWVudHNbdGVhbUlkXTtcbiAgICAgICAgICAgICAgICAgICAgdGVhbVRhc2tzLmN1cnJlbnQgPSBjdXJyZW50VGFzaztcbiAgICAgICAgICAgICAgICAgICAgVGFza1N0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBlcnJvcnMuIE5lZWRlZCBieSBwcm9taXNlIGluIERpc3BhdGNoZXIuXG4gICAgfSlcblxufSk7XG5cbndpbmRvdy5fX1Rhc2tTdG9yZSA9IFRhc2tTdG9yZTtcbm1vZHVsZS5leHBvcnRzID0gVGFza1N0b3JlO1xuIiwiLyogQSBzaW5nbGV0b24gc3RvcmUgdGhhdCBjYW4gYmUgcXVlcmllZCBmb3IgcmVtYWluaW5nIHRpbWUgKi9cblxuY29uc3QgY2hlY2sgPSByZXF1aXJlKCdjaGVjay10eXBlcycpO1xuY29uc3QgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2FwcGRpc3BhdGNoZXInKTtcbmNvbnN0IEJhc2VTdG9yZSA9IHJlcXVpcmUoJy4vYmFzZS1zdG9yZScpO1xuY29uc3QgVGltZXJDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvVGltZXJDb25zdGFudHMnKTtcbmNvbnN0IE1pc3Npb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvTWlzc2lvbkNvbnN0YW50cycpO1xuXG5cbi8vIGtlZXBpbmcgc3RhdGUgaGlkZGVuIGluIHRoZSBtb2R1bGVcbnZhciByZW1haW5pbmdUaW1lID0ge30sXG4gICAgaW5pdGlhbFRpbWUgPSB7fSxcbiAgICBpbnRlcnZhbElkID0ge30sXG4gICAgZWxhcHNlZE1pc3Npb25UaW1lID0gMCxcbiAgICBtaXNzaW9uVGltZXIgPSBudWxsO1xuXG5cbmZ1bmN0aW9uIHJlc2V0KHRpbWVySWQpIHtcbiAgICBzdG9wKHRpbWVySWQpO1xuICAgIHJlbWFpbmluZ1RpbWVbdGltZXJJZF0gPSBpbml0aWFsVGltZVt0aW1lcklkXTtcbn1cblxuZnVuY3Rpb24gc3RhcnQodGltZXJJZCkge1xuICAgIGFzc2VydEV4aXN0cyh0aW1lcklkKTtcblxuICAgIGludGVydmFsSWRbdGltZXJJZF0gPSBzZXRJbnRlcnZhbChmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgaWYgKHJlbWFpbmluZ1RpbWVbdGltZXJJZF0gPiAwKSB7XG4gICAgICAgICAgICByZW1haW5pbmdUaW1lW3RpbWVySWRdLS07XG4gICAgICAgICAgICBUaW1lclN0b3JlLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICB9LCAxMDAwKTtcbn1cblxuZnVuY3Rpb24gc3RvcCh0aW1lcklkKSB7XG4gICAgYXNzZXJ0RXhpc3RzKHRpbWVySWQpO1xuXG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkW3RpbWVySWRdKTtcbiAgICBkZWxldGUgaW50ZXJ2YWxJZFt0aW1lcklkXTtcbiAgICBUaW1lclN0b3JlLmVtaXRDaGFuZ2UoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRNaXNzaW9uVGltZXIoKXtcbiAgICBzdG9wTWlzc2lvblRpbWVyKCk7XG4gICAgbWlzc2lvblRpbWVyID0gc2V0SW50ZXJ2YWwoKCk9PntcbiAgICAgICAgZWxhcHNlZE1pc3Npb25UaW1lKys7XG4gICAgICAgIFRpbWVyU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgIH0sMTAwMCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BNaXNzaW9uVGltZXIoKXtcbiAgICBjbGVhckludGVydmFsKG1pc3Npb25UaW1lcik7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0gZGF0YS5yZW1haW5pbmdUaW1lIHtOdW1iZXJ9XG4gKiBAcGFyYW0gZGF0YS50aW1lcklkIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVJlbWFpbmluZ1RpbWVDaGFuZ2VkKGRhdGEpIHtcbiAgICB2YXIgcmVtYWluaW5nID0gZGF0YS5yZW1haW5pbmdUaW1lO1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IGludmFsaWQgcmVtYWluaW5nIHRpbWUgOicgKyByZW1haW5pbmcpO1xuXG4gICAgcmVtYWluaW5nVGltZVtkYXRhLnRpbWVySWRdID0gcmVtYWluaW5nO1xuICAgIGluaXRpYWxUaW1lW2RhdGEudGltZXJJZF0gPSByZW1haW5pbmc7XG4gICAgVGltZXJTdG9yZS5lbWl0Q2hhbmdlKCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4aXN0cyh0aW1lcklkKSB7XG4gICAgY2hlY2suYXNzZXJ0KHRpbWVySWQgaW4gcmVtYWluaW5nVGltZSwgJ05vIHRpbWUgc2V0IGZvciB0aW1lciB3aXRoIGlkICcgKyB0aW1lcklkKTtcbn1cblxuY29uc3QgVGltZXJTdG9yZSA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2VTdG9yZSgpLCB7XG4gICAgXG4gICAgZ2V0UmVtYWluaW5nVGltZSh0aW1lcklkKSB7XG4gICAgICAgIGNoZWNrLm51bWJlcih0aW1lcklkKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ1RpbWVbdGltZXJJZF07XG4gICAgfSxcblxuICAgIGlzUnVubmluZyh0aW1lcklkKSB7XG4gICAgICAgIGNoZWNrLm51bWJlcih0aW1lcklkKTtcbiAgICAgICAgcmV0dXJuICEhaW50ZXJ2YWxJZFt0aW1lcklkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVyIGlzIHNldCAob3IgaGFzIGJlZW4gcmVzZXQpLCBidXQgbm90IHN0YXJ0ZWRcbiAgICAgKiBAcGFyYW0gdGltZXJJZFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgcmVhZHksIGZhbHNlIGlmIHJ1bm5pbmcgb3IgdGltZWQgb3V0XG4gICAgICovXG4gICAgaXNSZWFkeVRvU3RhcnQodGltZXJJZCkge1xuICAgICAgICBjaGVjay5udW1iZXIodGltZXJJZCk7XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmlzUnVubmluZyh0aW1lcklkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW1haW5pbmdUaW1lKHRpbWVySWQpID4gMDtcbiAgICB9LFxuXG4gICAgZ2V0RWxhcHNlZE1pc3Npb25UaW1lKCkge1xuICAgICAgICByZXR1cm4gZWxhcHNlZE1pc3Npb25UaW1lO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaGVySW5kZXg6IEFwcERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHsgYWN0aW9uLCBkYXRhfSA9IHBheWxvYWQ7XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcblxuICAgICAgICAgICAgY2FzZSBUaW1lckNvbnN0YW50cy5TRVRfVElNRVI6XG4gICAgICAgICAgICAgICAgaGFuZGxlUmVtYWluaW5nVGltZUNoYW5nZWQoZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgVGltZXJDb25zdGFudHMuU1RBUlRfVElNRVI6XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXhpc3RzKGRhdGEudGltZXJJZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBzZXR0aW5nIHVwIG1vcmUgdGhhbiBvbmUgdGltZXJcbiAgICAgICAgICAgICAgICBpZighVGltZXJTdG9yZS5pc1J1bm5pbmcoZGF0YS50aW1lcklkKSl7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0KGRhdGEudGltZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFRpbWVyQ29uc3RhbnRzLlNUT1BfVElNRVI6XG4gICAgICAgICAgICAgICAgc3RvcChkYXRhLnRpbWVySWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFRpbWVyQ29uc3RhbnRzLlJFU0VUX1RJTUVSOlxuICAgICAgICAgICAgICAgIHJlc2V0KGRhdGEudGltZXJJZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5NSVNTSU9OX1NUQVJURURfRVZFTlQ6XG4gICAgICAgICAgICAgICAgc3RhcnRNaXNzaW9uVGltZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBNaXNzaW9uQ29uc3RhbnRzLk1JU1NJT05fU1RPUFBFRF9FVkVOVDpcbiAgICAgICAgICAgICAgICBzdG9wTWlzc2lvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTWlzc2lvbkNvbnN0YW50cy5SRUNFSVZFRF9BUFBfU1RBVEU6XG4gICAgICAgICAgICAgICAgdmFyIGFwcFN0YXRlID0gcGF5bG9hZC5hcHBTdGF0ZTtcblxuICAgICAgICAgICAgICAgIGVsYXBzZWRNaXNzaW9uVGltZSA9IGFwcFN0YXRlLmVsYXBzZWRfbWlzc2lvbl90aW1lO1xuXG4gICAgICAgICAgICAgICAgaWYoYXBwU3RhdGUubWlzc2lvbl9ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWlzc2lvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcE1pc3Npb25UaW1lcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFRpbWVyU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE1pc3Npb25Db25zdGFudHMuTUlTU0lPTl9USU1FX1NZTkM6XG4gICAgICAgICAgICAgICAgZWxhcHNlZE1pc3Npb25UaW1lICA9IGRhdGEuZWxhcHNlZE1pc3Npb25UaW1lO1xuICAgICAgICAgICAgICAgIFRpbWVyU3RvcmUuZW1pdENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIGVycm9ycy4gTmVlZGVkIGJ5IHByb21pc2UgaW4gRGlzcGF0Y2hlci5cbiAgICB9KVxuXG59KTtcblxud2luZG93Ll9fVGltZVN0b3JlID0gVGltZXJTdG9yZTtcbm1vZHVsZS5leHBvcnRzID0gVGltZXJTdG9yZTtcbiIsImNvbnN0IHRlYW1NYXAgPSBPYmplY3QuZnJlZXplKHtcbiAgICAnc2NpZW5jZSc6ICdmb3Jza25pbmdzdGVhbScsXG4gICAgJ2NvbW11bmljYXRpb24nOiAna29tbXVuaWthc2pvbnN0ZWFtJyxcbiAgICAnc2VjdXJpdHknOiAnc2lra2VyaGV0c3RlYW0nLFxuICAgICdhc3Ryb25hdXQnOiAnYXN0cm9uYXV0dGVhbSdcbn0pO1xuXG5mdW5jdGlvbiBvdGhlclRlYW1OYW1lcyhjdXJyZW50VGVhbUlkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRlYW1NYXApXG4gICAgICAgIC5maWx0ZXIoKG4pID0+IG4gIT09IGN1cnJlbnRUZWFtSWQgJiYgbiAhPT0gJ2xlYWRlcicpXG4gICAgICAgIC5tYXAoKG4pID0+IHRlYW1NYXBbbl0pXG4gICAgICAgIC5qb2luKCcsICcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG5hbWVNYXA6IHRlYW1NYXAsXG4gICAgb3RoZXJUZWFtTmFtZXNcbn07XG4iLCJmdW5jdGlvbiBjbGVhblJvb3RQYXRoKHBhdGgpIHtcbiAgICAvLyBjb252ZXJ0ICcvc2NpZW5jZS9zdGVwMScgPT4gJ3NjaWVuY2UnXG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvPyhcXHcrKS4qLywgXCIkMVwiKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggKyAxIC0gbWluKSkgKyBtaW47XG59XG5cbi8qKlxuICogU3RhbmRhcmRpemUgbnVtYmVyIHBhcnNpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIGlzIGEgbm9uLWVtcHR5IHN0cmluZ1xuICogQHJldHVybnMge051bWJlcn0gLSBwb3NzaWJseSBOYU5cbiAqXG4gKiBUaGUgc3RhbmRhcmRpemF0aW9uIHN0ZXAgb2YgY29udmVydGluZyAnMSwyMycgLT4gJzEuMjMnIGlzIHN0cmljdGx5IG5vdCBuZWVkZWQgd2hlbiBoYW5kbGluZyBpbnB1dHMgZnJvbVxuICogaW5wdXQgZmllbGRzIHRoYXQgaGF2ZSB0eXBlPSdudW1iZXInLCB3aGVyZSB0aGlzIGhhcHBlbnMgYXV0b21hdGljYWxseS5cbiAqIFRoZSByZXN0IG9mIHRoZSBlcnJvciBoYW5kbGluZyBpcyB1c2VmdWwsIG5vbmUgdGhlIGxlc3MuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKHN0cikge1xuICAgIGlmICghdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgc3RyaW5ncy4gR290IHNvbWV0aGluZyBlbHNlOiAnICsgc3RyKTtcbiAgICB9XG5cbiAgICAvLyBzdGFuZGFyZGl6ZSB0aGUgbnVtYmVyIGZvcm1hdCAtIHJlbW92aW5nIE5vcndlZ2lhbiBjdXJyZW5jeSBmb3JtYXRcbiAgICBsZXQgY2xlYW5lZFN0cmluZyA9IHN0ci50cmltKCkucmVwbGFjZSgnLCcsICcuJyk7XG5cbiAgICBpZiAoIWNsZWFuZWRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignR290IGEgYmxhbmsgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKGNsZWFuZWRTdHJpbmcuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChjbGVhbmVkU3RyaW5nLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNsZWFuZWRTdHJpbmcsIDEwKTtcbiAgICB9XG59XG5cbi8vIGdlbmVyYXRlcyBhIFVVSURcbi8vIHdvcmxkcyBzbWFsbGVzdCB1dWlkIGxpYi4gY3Jhenkgc2hpdCA6KVxuLy8gQHNlZSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG5mdW5jdGlvbiBiKGEpIHtcbiAgICByZXR1cm4gYSA/IChhIF4gTWF0aC5yYW5kb20oKSAqIDE2ID4+IGEgLyA0KS50b1N0cmluZygxNikgOiAoWzFlN10gKyAtMWUzICsgLTRlMyArIC04ZTMgKyAtMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgYilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2xlYW5Sb290UGF0aCwgcmFuZG9tSW50LCBwYXJzZU51bWJlciwgdXVpZDogYlxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9mcmVlemVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSkoKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkYXNzaWduID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfT2JqZWN0JGFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKS5jb3JlLk9iamVjdC5hc3NpZ247IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnN0YXRpY3MtYWNjZXB0LXByaW1pdGl2ZXMnKTtcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKS5jb3JlLk9iamVjdC5mcmVlemU7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnN0YXRpY3MtYWNjZXB0LXByaW1pdGl2ZXMnKTtcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKS5jb3JlLk9iamVjdC5rZXlzOyIsInZhciAkID0gcmVxdWlyZSgnLi8kJyk7XHJcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcclxuLyplc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXtcclxuLyplc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXHJcbiAgdmFyIFQgPSBPYmplY3QoJC5hc3NlcnREZWZpbmVkKHRhcmdldCkpXHJcbiAgICAsIGwgPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAsIGkgPSAxO1xyXG4gIHdoaWxlKGwgPiBpKXtcclxuICAgIHZhciBTICAgICAgPSAkLkVTNU9iamVjdChhcmd1bWVudHNbaSsrXSlcclxuICAgICAgLCBrZXlzICAgPSAkLmdldEtleXMoUylcclxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgICAsIGogICAgICA9IDBcclxuICAgICAgLCBrZXk7XHJcbiAgICB3aGlsZShsZW5ndGggPiBqKVRba2V5ID0ga2V5c1tqKytdXSA9IFNba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIFQ7XHJcbn07IiwidmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxyXG4gICwgZ2xvYmFsICAgICA9ICQuZ1xyXG4gICwgY29yZSAgICAgICA9ICQuY29yZVxyXG4gICwgaXNGdW5jdGlvbiA9ICQuaXNGdW5jdGlvbjtcclxuZnVuY3Rpb24gY3R4KGZuLCB0aGF0KXtcclxuICByZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xyXG4gIH07XHJcbn1cclxuLy8gdHlwZSBiaXRtYXBcclxuJGRlZi5GID0gMTsgIC8vIGZvcmNlZFxyXG4kZGVmLkcgPSAyOyAgLy8gZ2xvYmFsXHJcbiRkZWYuUyA9IDQ7ICAvLyBzdGF0aWNcclxuJGRlZi5QID0gODsgIC8vIHByb3RvXHJcbiRkZWYuQiA9IDE2OyAvLyBiaW5kXHJcbiRkZWYuVyA9IDMyOyAvLyB3cmFwXHJcbmZ1bmN0aW9uICRkZWYodHlwZSwgbmFtZSwgc291cmNlKXtcclxuICB2YXIga2V5LCBvd24sIG91dCwgZXhwXHJcbiAgICAsIGlzR2xvYmFsID0gdHlwZSAmICRkZWYuR1xyXG4gICAgLCB0YXJnZXQgICA9IGlzR2xvYmFsID8gZ2xvYmFsIDogdHlwZSAmICRkZWYuU1xyXG4gICAgICAgID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSkucHJvdG90eXBlXHJcbiAgICAsIGV4cG9ydHMgID0gaXNHbG9iYWwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcclxuICBpZihpc0dsb2JhbClzb3VyY2UgPSBuYW1lO1xyXG4gIGZvcihrZXkgaW4gc291cmNlKXtcclxuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxyXG4gICAgb3duID0gISh0eXBlICYgJGRlZi5GKSAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcclxuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcclxuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXHJcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xyXG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXHJcbiAgICBpZihpc0dsb2JhbCAmJiAhaXNGdW5jdGlvbih0YXJnZXRba2V5XSkpZXhwID0gc291cmNlW2tleV07XHJcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxyXG4gICAgZWxzZSBpZih0eXBlICYgJGRlZi5CICYmIG93billeHAgPSBjdHgob3V0LCBnbG9iYWwpO1xyXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcclxuICAgIGVsc2UgaWYodHlwZSAmICRkZWYuVyAmJiB0YXJnZXRba2V5XSA9PSBvdXQpIWZ1bmN0aW9uKEMpe1xyXG4gICAgICBleHAgPSBmdW5jdGlvbihwYXJhbSl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBDID8gbmV3IEMocGFyYW0pIDogQyhwYXJhbSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGV4cC5wcm90b3R5cGUgPSBDLnByb3RvdHlwZTtcclxuICAgIH0ob3V0KTtcclxuICAgIGVsc2UgZXhwID0gdHlwZSAmICRkZWYuUCAmJiBpc0Z1bmN0aW9uKG91dCkgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcclxuICAgIC8vIGV4cG9ydFxyXG4gICAgJC5oaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcclxuICB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSAkZGVmOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJCl7XHJcbiAgJC5GVyAgID0gZmFsc2U7XHJcbiAgJC5wYXRoID0gJC5jb3JlO1xyXG4gIHJldHVybiAkO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGdsb2JhbCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClcclxuICAsIGNvcmUgICA9IHt9XHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxyXG4gICwgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eVxyXG4gICwgY2VpbCAgPSBNYXRoLmNlaWxcclxuICAsIGZsb29yID0gTWF0aC5mbG9vclxyXG4gICwgbWF4ICAgPSBNYXRoLm1heFxyXG4gICwgbWluICAgPSBNYXRoLm1pbjtcclxuLy8gVGhlIGVuZ2luZSB3b3JrcyBmaW5lIHdpdGggZGVzY3JpcHRvcnM/IFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHkuXHJcbnZhciBERVNDID0gISFmdW5jdGlvbigpe1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDI7IH19KS5hID09IDI7XHJcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxyXG59KCk7XHJcbnZhciBoaWRlID0gY3JlYXRlRGVmaW5lcigxKTtcclxuLy8gNy4xLjQgVG9JbnRlZ2VyXHJcbmZ1bmN0aW9uIHRvSW50ZWdlcihpdCl7XHJcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XHJcbn1cclxuZnVuY3Rpb24gZGVzYyhiaXRtYXAsIHZhbHVlKXtcclxuICByZXR1cm4ge1xyXG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxyXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxyXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxyXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gc2ltcGxlU2V0KG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuICByZXR1cm4gb2JqZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmluZXIoYml0bWFwKXtcclxuICByZXR1cm4gREVTQyA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBkZXNjKGJpdG1hcCwgdmFsdWUpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxyXG4gIH0gOiBzaW1wbGVTZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGl0KXtcclxuICByZXR1cm4gaXQgIT09IG51bGwgJiYgKHR5cGVvZiBpdCA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaXQgPT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihpdCl7XHJcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydERlZmluZWQoaXQpe1xyXG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XHJcbiAgcmV0dXJuIGl0O1xyXG59XHJcblxyXG52YXIgJCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmZ3Jykoe1xyXG4gIGc6IGdsb2JhbCxcclxuICBjb3JlOiBjb3JlLFxyXG4gIGh0bWw6IGdsb2JhbC5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vY29yZS1qcy1pc29iamVjdFxyXG4gIGlzT2JqZWN0OiAgIGlzT2JqZWN0LFxyXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXHJcbiAgaXQ6IGZ1bmN0aW9uKGl0KXtcclxuICAgIHJldHVybiBpdDtcclxuICB9LFxyXG4gIHRoYXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG4gIC8vIDcuMS40IFRvSW50ZWdlclxyXG4gIHRvSW50ZWdlcjogdG9JbnRlZ2VyLFxyXG4gIC8vIDcuMS4xNSBUb0xlbmd0aFxyXG4gIHRvTGVuZ3RoOiBmdW5jdGlvbihpdCl7XHJcbiAgICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxyXG4gIH0sXHJcbiAgdG9JbmRleDogZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XHJcbiAgICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XHJcbiAgICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcclxuICB9LFxyXG4gIGhhczogZnVuY3Rpb24oaXQsIGtleSl7XHJcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcclxuICB9LFxyXG4gIGNyZWF0ZTogICAgIE9iamVjdC5jcmVhdGUsXHJcbiAgZ2V0UHJvdG86ICAgT2JqZWN0LmdldFByb3RvdHlwZU9mLFxyXG4gIERFU0M6ICAgICAgIERFU0MsXHJcbiAgZGVzYzogICAgICAgZGVzYyxcclxuICBnZXREZXNjOiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxyXG4gIHNldERlc2M6ICAgIGRlZmluZVByb3BlcnR5LFxyXG4gIGdldEtleXM6ICAgIE9iamVjdC5rZXlzLFxyXG4gIGdldE5hbWVzOiAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxyXG4gIGdldFN5bWJvbHM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXHJcbiAgLy8gRHVtbXksIGZpeCBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZyBpbiBlczUgbW9kdWxlXHJcbiAgYXNzZXJ0RGVmaW5lZDogYXNzZXJ0RGVmaW5lZCxcclxuICBFUzVPYmplY3Q6IE9iamVjdCxcclxuICB0b09iamVjdDogZnVuY3Rpb24oaXQpe1xyXG4gICAgcmV0dXJuICQuRVM1T2JqZWN0KGFzc2VydERlZmluZWQoaXQpKTtcclxuICB9LFxyXG4gIGhpZGU6IGhpZGUsXHJcbiAgZGVmOiBjcmVhdGVEZWZpbmVyKDApLFxyXG4gIHNldDogZ2xvYmFsLlN5bWJvbCA/IHNpbXBsZVNldCA6IGhpZGUsXHJcbiAgbWl4OiBmdW5jdGlvbih0YXJnZXQsIHNyYyl7XHJcbiAgICBmb3IodmFyIGtleSBpbiBzcmMpaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9LFxyXG4gIGVhY2g6IFtdLmZvckVhY2hcclxufSk7XHJcbmlmKHR5cGVvZiBfX2UgIT0gJ3VuZGVmaW5lZCcpX19lID0gY29yZTtcclxuaWYodHlwZW9mIF9fZyAhPSAndW5kZWZpbmVkJylfX2cgPSBnbG9iYWw7IiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcclxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XHJcbiRkZWYoJGRlZi5TLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi8kLmFzc2lnbicpfSk7IiwidmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcclxuICAsICRkZWYgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXHJcbiAgLCBpc09iamVjdCA9ICQuaXNPYmplY3RcclxuICAsIHRvT2JqZWN0ID0gJC50b09iamVjdDtcclxuZnVuY3Rpb24gd3JhcE9iamVjdE1ldGhvZChNRVRIT0QsIE1PREUpe1xyXG4gIHZhciBmbiAgPSAoJC5jb3JlLk9iamVjdCB8fCB7fSlbTUVUSE9EXSB8fCBPYmplY3RbTUVUSE9EXVxyXG4gICAgLCBmICAgPSAwXHJcbiAgICAsIG8gICA9IHt9O1xyXG4gIG9bTUVUSE9EXSA9IE1PREUgPT0gMSA/IGZ1bmN0aW9uKGl0KXtcclxuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBpdDtcclxuICB9IDogTU9ERSA9PSAyID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IHRydWU7XHJcbiAgfSA6IE1PREUgPT0gMyA/IGZ1bmN0aW9uKGl0KXtcclxuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBmYWxzZTtcclxuICB9IDogTU9ERSA9PSA0ID8gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xyXG4gICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSwga2V5KTtcclxuICB9IDogTU9ERSA9PSA1ID8gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xyXG4gICAgcmV0dXJuIGZuKE9iamVjdCgkLmFzc2VydERlZmluZWQoaXQpKSk7XHJcbiAgfSA6IGZ1bmN0aW9uKGl0KXtcclxuICAgIHJldHVybiBmbih0b09iamVjdChpdCkpO1xyXG4gIH07XHJcbiAgdHJ5IHtcclxuICAgIGZuKCd6Jyk7XHJcbiAgfSBjYXRjaChlKXtcclxuICAgIGYgPSAxO1xyXG4gIH1cclxuICAkZGVmKCRkZWYuUyArICRkZWYuRiAqIGYsICdPYmplY3QnLCBvKTtcclxufVxyXG53cmFwT2JqZWN0TWV0aG9kKCdmcmVlemUnLCAxKTtcclxud3JhcE9iamVjdE1ldGhvZCgnc2VhbCcsIDEpO1xyXG53cmFwT2JqZWN0TWV0aG9kKCdwcmV2ZW50RXh0ZW5zaW9ucycsIDEpO1xyXG53cmFwT2JqZWN0TWV0aG9kKCdpc0Zyb3plbicsIDIpO1xyXG53cmFwT2JqZWN0TWV0aG9kKCdpc1NlYWxlZCcsIDIpO1xyXG53cmFwT2JqZWN0TWV0aG9kKCdpc0V4dGVuc2libGUnLCAzKTtcclxud3JhcE9iamVjdE1ldGhvZCgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgNCk7XHJcbndyYXBPYmplY3RNZXRob2QoJ2dldFByb3RvdHlwZU9mJywgNSk7XHJcbndyYXBPYmplY3RNZXRob2QoJ2tleXMnKTtcclxud3JhcE9iamVjdE1ldGhvZCgnZ2V0T3duUHJvcGVydHlOYW1lcycpOyIsbnVsbCwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgQnVmZmVyKSkgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuICB2YXIgbGVuZ3RoXG5cbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgbGVuZ3RoID0gK3N1YmplY3RcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHN1YmplY3QgIT09IG51bGwpIHtcbiAgICAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAobGVuZ3RoID4ga01heExlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4JyArXG4gICAgICBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIGxlbmd0aCA9IDBcbiAgZWxzZSBsZW5ndGggPj4+PSAwIC8vIGNvZXJjZSB0byB1aW50MzJcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgc2VsZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgc2VsZi5sZW5ndGggPSBsZW5ndGhcbiAgICBzZWxmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgc2VsZi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGZbaV0gPSAoKHN1YmplY3RbaV0gJSAyNTYpICsgMjU2KSAlIDI1NlxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHNlbGYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggPiAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUpIHNlbGYucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiBzZWxmXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggPj4+IDFcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG5CdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuXG4gIGlmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpID4+PiAwICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSA+Pj4gMCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0ludChcbiAgICAgIHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsXG4gICAgICBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpIC0gMSxcbiAgICAgIC1NYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG4gICAgKVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSW50KFxuICAgICAgdGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCxcbiAgICAgIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSkgLSAxLFxuICAgICAgLU1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcbiAgICApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRfc3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiB0b0FycmF5QnVmZmVyICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiBfYXVnbWVudCAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgc2V0IG1ldGhvZCBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtelxcLV0vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuICB2YXIgaSA9IDBcblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgyMDAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ3V0aWwnKTtcbmlmIChkZWJ1ZyAmJiBkZWJ1Zy5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc1N0cmluZyhjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChhZGRUb0Zyb250KVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IHV0aWwuaXNOdWxsKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAoIXV0aWwuaXNOdW1iZXIobikgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAodXRpbC5pc051bGwocmV0KSkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHJldCkpXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiZcbiAgICAgICAgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSlcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLFxuICAgICAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbilcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gICAgICAgICAgc2VsZi5yZWFkKDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB9XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgcmVzdW1lXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZylcbiAgICBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICBpZiAoIWNodW5rIHx8ICFzdGF0ZS5vYmplY3RNb2RlICYmICFjaHVuay5sZW5ndGgpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHN0cmVhbVtpXSkgJiYgdXRpbC5pc1VuZGVmaW5lZCh0aGlzW2ldKSkge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoZGF0YSkpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHRoaXMuX2ZsdXNoKSlcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICghdXRpbC5pc051bGwodHMud3JpdGVjaHVuaykgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGNiKSlcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdXRpbC5pc1N0cmluZyhjaHVuaykpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpXG4gICAgc3RhdGUuYnVmZmVyLnB1c2gobmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpKTtcbiAgZWxzZVxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpXG4gICAgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO1xuICBlbHNlXG4gICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcik7XG4gIH1cblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGNicyA9IFtdO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKVxuICAgICAgY2JzLnB1c2goc3RhdGUuYnVmZmVyW2NdLmNhbGxiYWNrKTtcblxuICAgIC8vIGNvdW50IHRoZSBvbmUgd2UgYXJlIGFkZGluZywgYXMgd2VsbC5cbiAgICAvLyBUT0RPKGlzYWFjcykgY2xlYW4gdGhpcyB1cFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5idWZmZXIsICcnLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgICBjYnNbaV0oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsZWFyIGJ1ZmZlclxuICAgIHN0YXRlLmJ1ZmZlciA9IFtdO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyW2NdO1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYysrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gICAgZWxzZVxuICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xuXG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihjaHVuaykpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZVxuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGFyZyk7XG59XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgZXhwb3J0cyBmdW5jdGlvbnMgZm9yIGNoZWNraW5nIHR5cGVzXG4gKiBhbmQgdGhyb3dpbmcgZXhjZXB0aW9ucy5cbiAqL1xuXG4vKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUgKi9cblxuKGZ1bmN0aW9uIChnbG9iYWxzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1lc3NhZ2VzLCBwcmVkaWNhdGVzLCBmdW5jdGlvbnMsIGFzc2VydCwgbm90LCBtYXliZSwgZWl0aGVyO1xuXG4gICAgbWVzc2FnZXMgPSB7XG4gICAgICAgIGxpa2U6ICdJbnZhbGlkIHR5cGUnLFxuICAgICAgICBpbnN0YW5jZTogJ0ludmFsaWQgdHlwZScsXG4gICAgICAgIGVtcHR5T2JqZWN0OiAnSW52YWxpZCBvYmplY3QnLFxuICAgICAgICBvYmplY3Q6ICdJbnZhbGlkIG9iamVjdCcsXG4gICAgICAgIGFzc2lnbmVkOiAnSW52YWxpZCB2YWx1ZScsXG4gICAgICAgIHVuZGVmaW5lZDogJ0ludmFsaWQgdmFsdWUnLFxuICAgICAgICBudWxsOiAnSW52YWxpZCB2YWx1ZScsXG4gICAgICAgIGhhc0xlbmd0aDogJ0ludmFsaWQgbGVuZ3RoJyxcbiAgICAgICAgZW1wdHlBcnJheTogJ0ludmFsaWQgYXJyYXknLFxuICAgICAgICBhcnJheTogJ0ludmFsaWQgYXJyYXknLFxuICAgICAgICBkYXRlOiAnSW52YWxpZCBkYXRlJyxcbiAgICAgICAgZXJyb3I6ICdJbnZhbGlkIGVycm9yJyxcbiAgICAgICAgZm46ICdJbnZhbGlkIGZ1bmN0aW9uJyxcbiAgICAgICAgbWF0Y2g6ICdJbnZhbGlkIHN0cmluZycsXG4gICAgICAgIGNvbnRhaW5zOiAnSW52YWxpZCBzdHJpbmcnLFxuICAgICAgICB1bmVtcHR5U3RyaW5nOiAnSW52YWxpZCBzdHJpbmcnLFxuICAgICAgICBzdHJpbmc6ICdJbnZhbGlkIHN0cmluZycsXG4gICAgICAgIG9kZDogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgZXZlbjogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgYmV0d2VlbjogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgZ3JlYXRlcjogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgbGVzczogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgcG9zaXRpdmU6ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIG5lZ2F0aXZlOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBpbnRlZ2VyOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICB6ZXJvOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBudW1iZXI6ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIGJvb2xlYW46ICdJbnZhbGlkIGJvb2xlYW4nXG4gICAgfTtcblxuICAgIHByZWRpY2F0ZXMgPSB7XG4gICAgICAgIGxpa2U6IGxpa2UsXG4gICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgZW1wdHlPYmplY3Q6IGVtcHR5T2JqZWN0LFxuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYXNzaWduZWQ6IGFzc2lnbmVkLFxuICAgICAgICB1bmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICAgICAgICBudWxsOiBpc051bGwsXG4gICAgICAgIGhhc0xlbmd0aDogaGFzTGVuZ3RoLFxuICAgICAgICBlbXB0eUFycmF5OiBlbXB0eUFycmF5LFxuICAgICAgICBhcnJheTogYXJyYXksXG4gICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgICAgICB1bmVtcHR5U3RyaW5nOiB1bmVtcHR5U3RyaW5nLFxuICAgICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgICAgb2RkOiBvZGQsXG4gICAgICAgIGV2ZW46IGV2ZW4sXG4gICAgICAgIGJldHdlZW46IGJldHdlZW4sXG4gICAgICAgIGdyZWF0ZXI6IGdyZWF0ZXIsXG4gICAgICAgIGxlc3M6IGxlc3MsXG4gICAgICAgIHBvc2l0aXZlOiBwb3NpdGl2ZSxcbiAgICAgICAgbmVnYXRpdmU6IG5lZ2F0aXZlLFxuICAgICAgICBpbnRlZ2VyIDogaW50ZWdlcixcbiAgICAgICAgemVybzogemVybyxcbiAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgIGJvb2xlYW46IGJvb2xlYW5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb25zID0ge1xuICAgICAgICBhcHBseTogYXBwbHksXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICBhbGw6IGFsbCxcbiAgICAgICAgYW55OiBhbnlcbiAgICB9O1xuXG4gICAgZnVuY3Rpb25zID0gbWl4aW4oZnVuY3Rpb25zLCBwcmVkaWNhdGVzKTtcbiAgICBhc3NlcnQgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMoYXNzZXJ0TW9kaWZpZXIsIGFzc2VydEltcGwpO1xuICAgIG5vdCA9IGNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyhub3RNb2RpZmllciwgbm90SW1wbCk7XG4gICAgbWF5YmUgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMobWF5YmVNb2RpZmllciwgbWF5YmVJbXBsKTtcbiAgICBlaXRoZXIgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMoZWl0aGVyTW9kaWZpZXIpO1xuICAgIGFzc2VydC5ub3QgPSBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyhhc3NlcnRNb2RpZmllciwgbm90KTtcbiAgICBhc3NlcnQubWF5YmUgPSBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyhhc3NlcnRNb2RpZmllciwgbWF5YmUpO1xuICAgIGFzc2VydC5laXRoZXIgPSBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyhhc3NlcnRFaXRoZXJNb2RpZmllciwgcHJlZGljYXRlcyk7XG5cbiAgICBleHBvcnRGdW5jdGlvbnMobWl4aW4oZnVuY3Rpb25zLCB7XG4gICAgICAgIGFzc2VydDogYXNzZXJ0LFxuICAgICAgICBub3Q6IG5vdCxcbiAgICAgICAgbWF5YmU6IG1heWJlLFxuICAgICAgICBlaXRoZXI6IGVpdGhlclxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgbGlrZWAuXG4gICAgICpcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGFuIG9iamVjdCAncXVhY2tzIGxpa2UgYSBkdWNrJy5cbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaGFzIGFsbCBvZlxuICAgICAqIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQsIGFyY2hldHlwYWwgYXJndW1lbnRcbiAgICAgKiAodGhlICdkdWNrJykuIFJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaWtlIChkYXRhLCBkdWNrKSB7XG4gICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgIGZvciAobmFtZSBpbiBkdWNrKSB7XG4gICAgICAgICAgICBpZiAoZHVjay5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KG5hbWUpID09PSBmYWxzZSB8fCB0eXBlb2YgZGF0YVtuYW1lXSAhPT0gdHlwZW9mIGR1Y2tbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QoZGF0YVtuYW1lXSkgJiYgbGlrZShkYXRhW25hbWVdLCBkdWNrW25hbWVdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgaW5zdGFuY2VgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIGEgcHJvdG90eXBlLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zdGFuY2UgKGRhdGEsIHByb3RvdHlwZSkge1xuICAgICAgICBpZiAoZGF0YSAmJiBpc0Z1bmN0aW9uKHByb3RvdHlwZSkgJiYgZGF0YSBpbnN0YW5jZW9mIHByb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eU9iamVjdGAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYW4gZW1wdHkgb2JqZWN0LFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1wdHlPYmplY3QgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdChkYXRhKSAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgcGxhaW4tb2xkIEpTIG9iamVjdCxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdCAoZGF0YSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFzc2lnbmVkYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25lZCAoZGF0YSkge1xuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKGRhdGEpICYmICFpc051bGwoZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIHVuZGVmaW5lZCxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBudWxsYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBudWxsLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgaGFzTGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBoYXMgYSBsZW5ndGggcHJvcGVydHlcbiAgICAgKiB0aGF0IGVxdWFscyBgdmFsdWVgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0xlbmd0aCAoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbmVkKGRhdGEpICYmIGRhdGEubGVuZ3RoID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGVtcHR5QXJyYXlgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGFuIGVtcHR5IGFycmF5LFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1wdHlBcnJheSAoZGF0YSkge1xuICAgICAgICByZXR1cm4gYXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBzb21ldGhpbmcgaXMgYW4gYXJyYXksXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheSAoZGF0YSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGRhdGVgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgc29tZXRoaW5nIGlzIGEgdmFsaWQgZGF0ZSxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRhdGUgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmXG4gICAgICAgICAgICAhaXNOYU4oZGF0YS5nZXRUaW1lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZXJyb3JgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgcGxhaW4tb2xkIEpTIG9iamVjdCxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVycm9yIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBmdW5jdGlvbmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgZnVuY3Rpb24sXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG1hdGNoYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIHN0cmluZ1xuICAgICAqIHRoYXQgbWF0Y2hlcyBgcmVnZXhgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoIChkYXRhLCByZWdleCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nKGRhdGEpICYmICEhZGF0YS5tYXRjaChyZWdleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBjb250YWluc2AuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBzdHJpbmdcbiAgICAgKiB0aGF0IGNvbnRhaW5zIGBzdWJzdHJpbmdgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zIChkYXRhLCBzdWJzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyhkYXRhKSAmJiBkYXRhLmluZGV4T2Yoc3Vic3RyaW5nKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGB1bmVtcHR5U3RyaW5nYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVtcHR5U3RyaW5nIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgZGF0YSAhPT0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgc3RyaW5nLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZyAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgb2RkYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhbiBvZGQgbnVtYmVyLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2RkIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBpbnRlZ2VyKGRhdGEpICYmICFldmVuKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZXZlbmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYW4gZXZlbiBudW1iZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVuIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIoZGF0YSkgJiYgZGF0YSAlIDIgPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBpbnRlZ2VyYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhbiBpbnRlZ2VyLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZWdlciAoZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyKGRhdGEpICYmIGRhdGEgJSAxID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgYmV0d2VlbmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBudW1iZXJcbiAgICAgKiBiZXR3ZWVuIGBhYCBhbmQgYGJgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJldHdlZW4gKGRhdGEsIGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JlYXRlcihkYXRhLCBhKSAmJiBsZXNzKGRhdGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlc3MoZGF0YSwgYSkgJiYgZ3JlYXRlcihkYXRhLCBiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGdyZWF0ZXJgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgbnVtYmVyXG4gICAgICogZ3JlYXRlciB0aGFuIGB2YWx1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ3JlYXRlciAoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihkYXRhKSAmJiBkYXRhID4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBsZXNzYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIG51bWJlclxuICAgICAqIGxlc3MgdGhhbiBgdmFsdWVgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlc3MgKGRhdGEsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIoZGF0YSkgJiYgZGF0YSA8IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgcG9zaXRpdmVgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgcG9zaXRpdmUgbnVtYmVyLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gcG9zaXRpdmUgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdyZWF0ZXIoZGF0YSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBuZWdhdGl2ZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBuZWdhdGl2ZSBudW1iZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAgICAgICAgICBUaGUgdGhpbmcgdG8gdGVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGl2ZSAoZGF0YSkge1xuICAgICAgICByZXR1cm4gbGVzcyhkYXRhLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG51bWJlcmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBkYXRhIGlzIGEgbnVtYmVyLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnVtYmVyIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicgJiYgaXNOYU4oZGF0YSkgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICBkYXRhICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiZcbiAgICAgICAgICAgICAgIGRhdGEgIT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYHplcm9gLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIHplcm8sXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAgICAgICAgICBUaGUgdGhpbmcgdG8gdGVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6ZXJvIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgYm9vbGVhbmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBkYXRhIGlzIGEgYm9vbGVhbiB2YWx1ZSxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJvb2xlYW4gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgPT09IGZhbHNlIHx8IGRhdGEgPT09IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBNYXBzIGVhY2ggdmFsdWUgZnJvbSB0aGUgZGF0YSB0byB0aGUgY29ycmVzcG9uZGluZyBwcmVkaWNhdGUgYW5kIHJldHVybnNcbiAgICAgKiB0aGUgcmVzdWx0IGFycmF5LiBJZiB0aGUgc2FtZSBmdW5jdGlvbiBpcyB0byBiZSBhcHBsaWVkIGFjcm9zcyBhbGwgb2YgdGhlXG4gICAgICogZGF0YSwgYSBzaW5nbGUgcHJlZGljYXRlIGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgaW4uXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcHBseSAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgICAgICBhc3NlcnQuYXJyYXkoZGF0YSk7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlcyh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2VydC5hcnJheShwcmVkaWNhdGVzKTtcbiAgICAgICAgYXNzZXJ0Lmhhc0xlbmd0aChkYXRhLCBwcmVkaWNhdGVzLmxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGVzW2luZGV4XSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgbWFwYC5cbiAgICAgKlxuICAgICAqIE1hcHMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBkYXRhIHRvIHRoZSBjb3JyZXNwb25kaW5nIHByZWRpY2F0ZSBhbmQgcmV0dXJuc1xuICAgICAqIHRoZSByZXN1bHQgb2JqZWN0LiBTdXBwb3J0cyBuZXN0ZWQgb2JqZWN0cy4gSWYgdGhlIGRhdGEgaXMgbm90IG5lc3RlZCBhbmRcbiAgICAgKiB0aGUgc2FtZSBmdW5jdGlvbiBpcyB0byBiZSBhcHBsaWVkIGFjcm9zcyBhbGwgb2YgaXQsIGEgc2luZ2xlIHByZWRpY2F0ZVxuICAgICAqIGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgaW4uXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAgKGRhdGEsIHByZWRpY2F0ZXMpIHtcbiAgICAgICAgYXNzZXJ0Lm9iamVjdChkYXRhKTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihwcmVkaWNhdGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFNpbXBsZShkYXRhLCBwcmVkaWNhdGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2VydC5vYmplY3QocHJlZGljYXRlcyk7XG5cbiAgICAgICAgcmV0dXJuIG1hcENvbXBsZXgoZGF0YSwgcHJlZGljYXRlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwU2ltcGxlIChkYXRhLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBwcmVkaWNhdGUoZGF0YVtrZXldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBDb21wbGV4IChkYXRhLCBwcmVkaWNhdGVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyhwcmVkaWNhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGUgPSBwcmVkaWNhdGVzW2tleV07XG5cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByZWRpY2F0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHByZWRpY2F0ZShkYXRhW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3QocHJlZGljYXRlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbWFwQ29tcGxleChkYXRhW2tleV0sIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBhbGxgXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGF0IGFsbCBib29sZWFuIHZhbHVlcyBhcmUgdHJ1ZVxuICAgICAqIGluIGFuIGFycmF5IChyZXR1cm5lZCBmcm9tIGBhcHBseWApXG4gICAgICogb3Igb2JqZWN0IChyZXR1cm5lZCBmcm9tIGBtYXBgKS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFsbCAoZGF0YSkge1xuICAgICAgICBpZiAoYXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0QXJyYXkoZGF0YSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0Lm9iamVjdChkYXRhKTtcblxuICAgICAgICByZXR1cm4gdGVzdE9iamVjdChkYXRhLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdEFycmF5IChkYXRhLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhW2ldID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdE9iamVjdCAoZGF0YSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBrZXksIHZhbHVlO1xuXG4gICAgICAgIGZvciAoa2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGFba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QodmFsdWUpICYmIHRlc3RPYmplY3QodmFsdWUsIHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBhbnlgXG4gICAgICpcbiAgICAgKiBDaGVjayB0aGF0IGF0IGxlYXN0IG9uZSBib29sZWFuIHZhbHVlIGlzIHRydWVcbiAgICAgKiBpbiBhbiBhcnJheSAocmV0dXJuZWQgZnJvbSBgYXBwbHlgKVxuICAgICAqIG9yIG9iamVjdCAocmV0dXJuZWQgZnJvbSBgbWFwYCkuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbnkgKGRhdGEpIHtcbiAgICAgICAgaWYgKGFycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdEFycmF5KGRhdGEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0Lm9iamVjdChkYXRhKTtcblxuICAgICAgICByZXR1cm4gdGVzdE9iamVjdChkYXRhLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtaXhpbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1vZGlmaWVyIGBhc3NlcnRgLlxuICAgICAqXG4gICAgICogVGhyb3dzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRNb2RpZmllciAocHJlZGljYXRlLCBkZWZhdWx0TWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXNzZXJ0UHJlZGljYXRlKHByZWRpY2F0ZSwgYXJndW1lbnRzLCBkZWZhdWx0TWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJlZGljYXRlIChwcmVkaWNhdGUsIGFyZ3MsIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBhc3NlcnRJbXBsKHByZWRpY2F0ZS5hcHBseShudWxsLCBhcmdzKSwgdW5lbXB0eVN0cmluZyhtZXNzYWdlKSA/IG1lc3NhZ2UgOiBkZWZhdWx0TWVzc2FnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0SW1wbCAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydEVpdGhlck1vZGlmaWVyIChwcmVkaWNhdGUsIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3I7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UHJlZGljYXRlKHByZWRpY2F0ZSwgYXJndW1lbnRzLCBkZWZhdWx0TWVzc2FnZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9yOiBPYmplY3Qua2V5cyhwcmVkaWNhdGVzKS5yZWR1Y2UoZGVsYXllZEFzc2VydCwge30pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBkZWxheWVkQXNzZXJ0IChyZXN1bHQsIGtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgIXByZWRpY2F0ZXNba2V5XS5hcHBseShudWxsLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtb2RpZmllciBgbm90YC5cbiAgICAgKlxuICAgICAqIE5lZ2F0ZXMgYHByZWRpY2F0ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm90TW9kaWZpZXIgKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdEltcGwocHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdEltcGwgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1vZGlmaWVyIGBtYXliZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBwcmVkaWNhdGUgYXJndW1lbnQgaXMgIGBudWxsYCBvciBgdW5kZWZpbmVkYCxcbiAgICAgKiBvdGhlcndpc2UgcHJvcGFnYXRlcyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gYHByZWRpY2F0ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF5YmVNb2RpZmllciAocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWFzc2lnbmVkKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heWJlSW1wbCAodmFsdWUpIHtcbiAgICAgICAgaWYgKGFzc2lnbmVkKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtb2RpZmllciBgZWl0aGVyYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGVpdGhlciBwcmVkaWNhdGUgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlaXRoZXJNb2RpZmllciAocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2hvcnRjdXQgPSBwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcjogT2JqZWN0LmtleXMocHJlZGljYXRlcykucmVkdWNlKG5vcE9yUHJlZGljYXRlLCB7fSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5vcE9yUHJlZGljYXRlIChyZXN1bHQsIGtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc2hvcnRjdXQgPyBub3AgOiBwcmVkaWNhdGVzW2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBub3AgKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMgKG1vZGlmaWVyLCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKG1vZGlmaWVyLCBwcmVkaWNhdGVzLCBvYmplY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zIChtb2RpZmllciwgZnVuY3Rpb25zLCBvYmplY3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCB8fCB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyhmdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbW9kaWZpZXIoZnVuY3Rpb25zW2tleV0sIG1lc3NhZ2VzW2tleV0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRGdW5jdGlvbnMgKGZ1bmN0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUgIT09IG51bGwgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFscy5jaGVjayA9IGZ1bmN0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbn0odGhpcykpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9saWIvRGlzcGF0Y2hlcicpXG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERpc3BhdGNoZXJcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG52YXIgX2xhc3RJRCA9IDE7XG52YXIgX3ByZWZpeCA9ICdJRF8nO1xuXG4vKipcbiAqIERpc3BhdGNoZXIgaXMgdXNlZCB0byBicm9hZGNhc3QgcGF5bG9hZHMgdG8gcmVnaXN0ZXJlZCBjYWxsYmFja3MuIFRoaXMgaXNcbiAqIGRpZmZlcmVudCBmcm9tIGdlbmVyaWMgcHViLXN1YiBzeXN0ZW1zIGluIHR3byB3YXlzOlxuICpcbiAqICAgMSkgQ2FsbGJhY2tzIGFyZSBub3Qgc3Vic2NyaWJlZCB0byBwYXJ0aWN1bGFyIGV2ZW50cy4gRXZlcnkgcGF5bG9hZCBpc1xuICogICAgICBkaXNwYXRjaGVkIHRvIGV2ZXJ5IHJlZ2lzdGVyZWQgY2FsbGJhY2suXG4gKiAgIDIpIENhbGxiYWNrcyBjYW4gYmUgZGVmZXJyZWQgaW4gd2hvbGUgb3IgcGFydCB1bnRpbCBvdGhlciBjYWxsYmFja3MgaGF2ZVxuICogICAgICBiZWVuIGV4ZWN1dGVkLlxuICpcbiAqIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGlzIGh5cG90aGV0aWNhbCBmbGlnaHQgZGVzdGluYXRpb24gZm9ybSwgd2hpY2hcbiAqIHNlbGVjdHMgYSBkZWZhdWx0IGNpdHkgd2hlbiBhIGNvdW50cnkgaXMgc2VsZWN0ZWQ6XG4gKlxuICogICB2YXIgZmxpZ2h0RGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBjb3VudHJ5IGlzIHNlbGVjdGVkXG4gKiAgIHZhciBDb3VudHJ5U3RvcmUgPSB7Y291bnRyeTogbnVsbH07XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBjaXR5IGlzIHNlbGVjdGVkXG4gKiAgIHZhciBDaXR5U3RvcmUgPSB7Y2l0eTogbnVsbH07XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgYmFzZSBmbGlnaHQgcHJpY2Ugb2YgdGhlIHNlbGVjdGVkIGNpdHlcbiAqICAgdmFyIEZsaWdodFByaWNlU3RvcmUgPSB7cHJpY2U6IG51bGx9XG4gKlxuICogV2hlbiBhIHVzZXIgY2hhbmdlcyB0aGUgc2VsZWN0ZWQgY2l0eSwgd2UgZGlzcGF0Y2ggdGhlIHBheWxvYWQ6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAqICAgICBhY3Rpb25UeXBlOiAnY2l0eS11cGRhdGUnLFxuICogICAgIHNlbGVjdGVkQ2l0eTogJ3BhcmlzJ1xuICogICB9KTtcbiAqXG4gKiBUaGlzIHBheWxvYWQgaXMgZGlnZXN0ZWQgYnkgYENpdHlTdG9yZWA6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY2l0eS11cGRhdGUnKSB7XG4gKiAgICAgICBDaXR5U3RvcmUuY2l0eSA9IHBheWxvYWQuc2VsZWN0ZWRDaXR5O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogV2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgY291bnRyeSwgd2UgZGlzcGF0Y2ggdGhlIHBheWxvYWQ6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAqICAgICBhY3Rpb25UeXBlOiAnY291bnRyeS11cGRhdGUnLFxuICogICAgIHNlbGVjdGVkQ291bnRyeTogJ2F1c3RyYWxpYSdcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGJvdGggc3RvcmVzOlxuICpcbiAqICAgIENvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgQ291bnRyeVN0b3JlLmNvdW50cnkgPSBwYXlsb2FkLnNlbGVjdGVkQ291bnRyeTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIGNhbGxiYWNrIHRvIHVwZGF0ZSBgQ291bnRyeVN0b3JlYCBpcyByZWdpc3RlcmVkLCB3ZSBzYXZlIGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgcmV0dXJuZWQgdG9rZW4uIFVzaW5nIHRoaXMgdG9rZW4gd2l0aCBgd2FpdEZvcigpYCwgd2UgY2FuIGd1YXJhbnRlZVxuICogdGhhdCBgQ291bnRyeVN0b3JlYCBpcyB1cGRhdGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgdGhhdCB1cGRhdGVzIGBDaXR5U3RvcmVgXG4gKiBuZWVkcyB0byBxdWVyeSBpdHMgZGF0YS5cbiAqXG4gKiAgIENpdHlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgLy8gYENvdW50cnlTdG9yZS5jb3VudHJ5YCBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gKiAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIGlzIG5vdyBndWFyYW50ZWVkIHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogICAgICAgLy8gU2VsZWN0IHRoZSBkZWZhdWx0IGNpdHkgZm9yIHRoZSBuZXcgY291bnRyeVxuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBnZXREZWZhdWx0Q2l0eUZvckNvdW50cnkoQ291bnRyeVN0b3JlLmNvdW50cnkpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIHVzYWdlIG9mIGB3YWl0Rm9yKClgIGNhbiBiZSBjaGFpbmVkLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgIEZsaWdodFByaWNlU3RvcmUuZGlzcGF0Y2hUb2tlbiA9XG4gKiAgICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uVHlwZSkge1xuICogICAgICAgICBjYXNlICdjb3VudHJ5LXVwZGF0ZSc6XG4gKiAgICAgICAgICAgZmxpZ2h0RGlzcGF0Y2hlci53YWl0Rm9yKFtDaXR5U3RvcmUuZGlzcGF0Y2hUb2tlbl0pO1xuICogICAgICAgICAgIEZsaWdodFByaWNlU3RvcmUucHJpY2UgPVxuICogICAgICAgICAgICAgZ2V0RmxpZ2h0UHJpY2VTdG9yZShDb3VudHJ5U3RvcmUuY291bnRyeSwgQ2l0eVN0b3JlLmNpdHkpO1xuICogICAgICAgICAgIGJyZWFrO1xuICpcbiAqICAgICAgICAgY2FzZSAnY2l0eS11cGRhdGUnOlxuICogICAgICAgICAgIEZsaWdodFByaWNlU3RvcmUucHJpY2UgPVxuICogICAgICAgICAgICAgRmxpZ2h0UHJpY2VTdG9yZShDb3VudHJ5U3RvcmUuY291bnRyeSwgQ2l0eVN0b3JlLmNpdHkpO1xuICogICAgICAgICAgIGJyZWFrO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGBjb3VudHJ5LXVwZGF0ZWAgcGF5bG9hZCB3aWxsIGJlIGd1YXJhbnRlZWQgdG8gaW52b2tlIHRoZSBzdG9yZXMnXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcyBpbiBvcmRlcjogYENvdW50cnlTdG9yZWAsIGBDaXR5U3RvcmVgLCB0aGVuXG4gKiBgRmxpZ2h0UHJpY2VTdG9yZWAuXG4gKi9cblxuICBmdW5jdGlvbiBEaXNwYXRjaGVyKCkge1xuICAgIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc1BlbmRpbmcgPSB7fTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzSGFuZGxlZCA9IHt9O1xuICAgIHRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfcGVuZGluZ1BheWxvYWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2l0aCBldmVyeSBkaXNwYXRjaGVkIHBheWxvYWQuIFJldHVybnNcbiAgICogYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYHdhaXRGb3IoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gX3ByZWZpeCArIF9sYXN0SUQrKztcbiAgICB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrc1tpZF0gPSBjYWxsYmFjaztcbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjYWxsYmFjayBiYXNlZCBvbiBpdHMgdG9rZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUudW5yZWdpc3Rlcj1mdW5jdGlvbihpZCkge1xuICAgIGludmFyaWFudChcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzW2lkXSxcbiAgICAgICdEaXNwYXRjaGVyLnVucmVnaXN0ZXIoLi4uKTogYCVzYCBkb2VzIG5vdCBtYXAgdG8gYSByZWdpc3RlcmVkIGNhbGxiYWNrLicsXG4gICAgICBpZFxuICAgICk7XG4gICAgZGVsZXRlIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBjYWxsYmFja3Mgc3BlY2lmaWVkIHRvIGJlIGludm9rZWQgYmVmb3JlIGNvbnRpbnVpbmcgZXhlY3V0aW9uXG4gICAqIG9mIHRoZSBjdXJyZW50IGNhbGxiYWNrLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IGEgY2FsbGJhY2sgaW5cbiAgICogcmVzcG9uc2UgdG8gYSBkaXNwYXRjaGVkIHBheWxvYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gaWRzXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS53YWl0Rm9yPWZ1bmN0aW9uKGlkcykge1xuICAgIGludmFyaWFudChcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZyxcbiAgICAgICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogTXVzdCBiZSBpbnZva2VkIHdoaWxlIGRpc3BhdGNoaW5nLidcbiAgICApO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpZHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpZHNbaWldO1xuICAgICAgaWYgKHRoaXMuJERpc3BhdGNoZXJfaXNQZW5kaW5nW2lkXSkge1xuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0hhbmRsZWRbaWRdLFxuICAgICAgICAgICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogQ2lyY3VsYXIgZGVwZW5kZW5jeSBkZXRlY3RlZCB3aGlsZSAnICtcbiAgICAgICAgICAnd2FpdGluZyBmb3IgYCVzYC4nLFxuICAgICAgICAgIGlkXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW52YXJpYW50KFxuICAgICAgICB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrc1tpZF0sXG4gICAgICAgICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogYCVzYCBkb2VzIG5vdCBtYXAgdG8gYSByZWdpc3RlcmVkIGNhbGxiYWNrLicsXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9pbnZva2VDYWxsYmFjayhpZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgcGF5bG9hZCB0byBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaD1mdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZyxcbiAgICAgICdEaXNwYXRjaC5kaXNwYXRjaCguLi4pOiBDYW5ub3QgZGlzcGF0Y2ggaW4gdGhlIG1pZGRsZSBvZiBhIGRpc3BhdGNoLidcbiAgICApO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfc3RhcnREaXNwYXRjaGluZyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKHRoaXMuJERpc3BhdGNoZXJfaXNQZW5kaW5nW2lkXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJERpc3BhdGNoZXJfaW52b2tlQ2FsbGJhY2soaWQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLiREaXNwYXRjaGVyX3N0b3BEaXNwYXRjaGluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhpcyBEaXNwYXRjaGVyIGN1cnJlbnRseSBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmlzRGlzcGF0Y2hpbmc9ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY2FsbGJhY2sgc3RvcmVkIHdpdGggdGhlIGdpdmVuIGlkLiBBbHNvIGRvIHNvbWUgaW50ZXJuYWxcbiAgICogYm9va2tlZXBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLiREaXNwYXRjaGVyX2ludm9rZUNhbGxiYWNrPWZ1bmN0aW9uKGlkKSB7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc1BlbmRpbmdbaWRdID0gdHJ1ZTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrc1tpZF0odGhpcy4kRGlzcGF0Y2hlcl9wZW5kaW5nUGF5bG9hZCk7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0hhbmRsZWRbaWRdID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHVwIGJvb2trZWVwaW5nIG5lZWRlZCB3aGVuIGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGF5bG9hZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLiREaXNwYXRjaGVyX3N0YXJ0RGlzcGF0Y2hpbmc9ZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLiREaXNwYXRjaGVyX2lzUGVuZGluZ1tpZF0gPSBmYWxzZTtcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfaXNIYW5kbGVkW2lkXSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiREaXNwYXRjaGVyX3BlbmRpbmdQYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBib29ra2VlcGluZyB1c2VkIGZvciBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS4kRGlzcGF0Y2hlcl9zdG9wRGlzcGF0Y2hpbmc9ZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9wZW5kaW5nUGF5bG9hZCA9IG51bGw7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIH07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAoZmFsc2UpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnSW52YXJpYW50IFZpb2xhdGlvbjogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iLCJ2YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IHJlcXVpcmUoJ21pbi1kb2N1bWVudCcpO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIHZhciBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xufVxuIiwiaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuIiwiXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIHRva2VuaXplID0gZnVuY3Rpb24oLypTdHJpbmcqLyBzdHIsIC8qUmVnRXhwKi8gcmUsIC8qRnVuY3Rpb24/Ki8gcGFyc2VEZWxpbSwgLypPYmplY3Q/Ki8gaW5zdGFuY2Upe1xuICAvLyBzdW1tYXJ5OlxuICAvLyAgICBTcGxpdCBhIHN0cmluZyBieSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRoIHRoZSBhYmlsaXR5IHRvIGNhcHR1cmUgdGhlIGRlbGltZXRlcnNcbiAgLy8gcGFyc2VEZWxpbTpcbiAgLy8gICAgRWFjaCBncm91cCAoZXhjbHVkaW5nIHRoZSAwIGdyb3VwKSBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gIC8vICAgIGEgdmFsdWUsIGl0J3MgYWRkZWQgdG8gdGhlIGxpc3Qgb2YgdG9rZW5zLlxuICAvLyBpbnN0YW5jZTpcbiAgLy8gICAgVXNlZCBhcyB0aGUgXCJ0aGlzJyBpbnN0YW5jZSB3aGVuIGNhbGxpbmcgcGFyc2VEZWxpbVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBtYXRjaCwgY29udGVudCwgbGFzdEluZGV4ID0gMDtcbiAgd2hpbGUobWF0Y2ggPSByZS5leGVjKHN0cikpe1xuICAgIGNvbnRlbnQgPSBzdHIuc2xpY2UobGFzdEluZGV4LCByZS5sYXN0SW5kZXggLSBtYXRjaFswXS5sZW5ndGgpO1xuICAgIGlmKGNvbnRlbnQubGVuZ3RoKXtcbiAgICAgIHRva2Vucy5wdXNoKGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZihwYXJzZURlbGltKXtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZURlbGltLmFwcGx5KGluc3RhbmNlLCBtYXRjaC5zbGljZSgxKS5jb25jYXQodG9rZW5zLmxlbmd0aCkpO1xuICAgICAgaWYodHlwZW9mIHBhcnNlZCAhPSAndW5kZWZpbmVkJyl7XG4gICAgICAgIGlmKHBhcnNlZC5zcGVjaWZpZXIgPT09ICclJyl7XG4gICAgICAgICAgdG9rZW5zLnB1c2goJyUnKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gIH1cbiAgY29udGVudCA9IHN0ci5zbGljZShsYXN0SW5kZXgpO1xuICBpZihjb250ZW50Lmxlbmd0aCl7XG4gICAgdG9rZW5zLnB1c2goY29udGVudCk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn1cblxudmFyIEZvcm1hdHRlciA9IGZ1bmN0aW9uKC8qU3RyaW5nKi8gZm9ybWF0KXtcbiAgdmFyIHRva2VucyA9IFtdO1xuICB0aGlzLl9tYXBwZWQgPSBmYWxzZTtcbiAgdGhpcy5fZm9ybWF0ID0gZm9ybWF0O1xuICB0aGlzLl90b2tlbnMgPSB0b2tlbml6ZShmb3JtYXQsIHRoaXMuX3JlLCB0aGlzLl9wYXJzZURlbGltLCB0aGlzKTtcbn1cblxuRm9ybWF0dGVyLnByb3RvdHlwZS5fcmUgPSAvXFwlKD86XFwoKFtcXHdfXSspXFwpfChbMS05XVxcZCopXFwkKT8oWzAgK1xcLVxcI10qKShcXCp8XFxkKyk/KFxcLik/KFxcKnxcXGQrKT9baGxMXT8oW1xcJWJzY2RlRWZGZ0dpb091eFhdKS9nO1xuRm9ybWF0dGVyLnByb3RvdHlwZS5fcGFyc2VEZWxpbSA9IGZ1bmN0aW9uKG1hcHBpbmcsIGludG1hcHBpbmcsIGZsYWdzLCBtaW5XaWR0aCwgcGVyaW9kLCBwcmVjaXNpb24sIHNwZWNpZmllcil7XG4gIGlmKG1hcHBpbmcpe1xuICAgIHRoaXMuX21hcHBlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYXBwaW5nOiBtYXBwaW5nLFxuICAgIGludG1hcHBpbmc6IGludG1hcHBpbmcsXG4gICAgZmxhZ3M6IGZsYWdzLFxuICAgIF9taW5XaWR0aDogbWluV2lkdGgsIC8vIE1heSBiZSBkZXBlbmRlbnQgb24gcGFyYW1ldGVyc1xuICAgIHBlcmlvZDogcGVyaW9kLFxuICAgIF9wcmVjaXNpb246IHByZWNpc2lvbiwgLy8gTWF5IGJlIGRlcGVuZGVudCBvbiBwYXJhbWV0ZXJzXG4gICAgc3BlY2lmaWVyOiBzcGVjaWZpZXJcbiAgfTtcbn07XG5Gb3JtYXR0ZXIucHJvdG90eXBlLl9zcGVjaWZpZXJzID0ge1xuICBiOiB7XG4gICAgYmFzZTogMixcbiAgICBpc0ludDogdHJ1ZVxuICB9LFxuICBvOiB7XG4gICAgYmFzZTogOCxcbiAgICBpc0ludDogdHJ1ZVxuICB9LFxuICB4OiB7XG4gICAgYmFzZTogMTYsXG4gICAgaXNJbnQ6IHRydWVcbiAgfSxcbiAgWDoge1xuICAgIGV4dGVuZDogWyd4J10sXG4gICAgdG9VcHBlcjogdHJ1ZVxuICB9LFxuICBkOiB7XG4gICAgYmFzZTogMTAsXG4gICAgaXNJbnQ6IHRydWVcbiAgfSxcbiAgaToge1xuICAgIGV4dGVuZDogWydkJ11cbiAgfSxcbiAgdToge1xuICAgIGV4dGVuZDogWydkJ10sXG4gICAgaXNVbnNpZ25lZDogdHJ1ZVxuICB9LFxuICBjOiB7XG4gICAgc2V0QXJnOiBmdW5jdGlvbih0b2tlbil7XG4gICAgICBpZighaXNOYU4odG9rZW4uYXJnKSl7XG4gICAgICAgIHZhciBudW0gPSBwYXJzZUludCh0b2tlbi5hcmcpO1xuICAgICAgICBpZihudW0gPCAwIHx8IG51bSA+IDEyNyl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNoYXJhY3RlciBjb2RlIHBhc3NlZCB0byAlYyBpbiBwcmludGYnKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbi5hcmcgPSBpc05hTihudW0pID8gJycgKyBudW0gOiBTdHJpbmcuZnJvbUNoYXJDb2RlKG51bSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzOiB7XG4gICAgc2V0TWF4V2lkdGg6IGZ1bmN0aW9uKHRva2VuKXtcbiAgICAgIHRva2VuLm1heFdpZHRoID0gKHRva2VuLnBlcmlvZCA9PSAnLicpID8gdG9rZW4ucHJlY2lzaW9uIDogLTE7XG4gICAgfVxuICB9LFxuICBlOiB7XG4gICAgaXNEb3VibGU6IHRydWUsXG4gICAgZG91YmxlTm90YXRpb246ICdlJ1xuICB9LFxuICBFOiB7XG4gICAgZXh0ZW5kOiBbJ2UnXSxcbiAgICB0b1VwcGVyOiB0cnVlXG4gIH0sXG4gIGY6IHtcbiAgICBpc0RvdWJsZTogdHJ1ZSxcbiAgICBkb3VibGVOb3RhdGlvbjogJ2YnXG4gIH0sXG4gIEY6IHtcbiAgICBleHRlbmQ6IFsnZiddXG4gIH0sXG4gIGc6IHtcbiAgICBpc0RvdWJsZTogdHJ1ZSxcbiAgICBkb3VibGVOb3RhdGlvbjogJ2cnXG4gIH0sXG4gIEc6IHtcbiAgICBleHRlbmQ6IFsnZyddLFxuICAgIHRvVXBwZXI6IHRydWVcbiAgfSxcbiAgTzoge1xuICAgIGlzT2JqZWN0OiB0cnVlXG4gIH0sXG59O1xuRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigvKm1peGVkLi4uKi8gZmlsbGVyKXtcbiAgaWYodGhpcy5fbWFwcGVkICYmIHR5cGVvZiBmaWxsZXIgIT0gJ29iamVjdCcpe1xuICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IHJlcXVpcmVzIGEgbWFwcGluZycpO1xuICB9XG5cbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgcG9zaXRpb24gPSAwO1xuICBmb3IodmFyIGkgPSAwLCB0b2tlbjsgaSA8IHRoaXMuX3Rva2Vucy5sZW5ndGg7IGkrKyl7XG4gICAgdG9rZW4gPSB0aGlzLl90b2tlbnNbaV07XG4gICAgXG4gICAgaWYodHlwZW9mIHRva2VuID09ICdzdHJpbmcnKXtcbiAgICAgIHN0ciArPSB0b2tlbjtcbiAgICB9ZWxzZXtcbiAgICAgIGlmKHRoaXMuX21hcHBlZCl7XG4gICAgICAgIGlmKHR5cGVvZiBmaWxsZXJbdG9rZW4ubWFwcGluZ10gPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBrZXkgJyArIHRva2VuLm1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuLmFyZyA9IGZpbGxlclt0b2tlbi5tYXBwaW5nXTtcbiAgICAgIH1lbHNle1xuICAgICAgICBpZih0b2tlbi5pbnRtYXBwaW5nKXtcbiAgICAgICAgICBwb3NpdGlvbiA9IHBhcnNlSW50KHRva2VuLmludG1hcHBpbmcpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihwb3NpdGlvbiA+PSBhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJpbnRmIGFyZ3VtZW50cywgaW5zdWZmaWNpZW50IGZvciBcXCcnICsgdGhpcy5fZm9ybWF0ICsgJ1xcJycpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuLmFyZyA9IGFyZ3VtZW50c1twb3NpdGlvbisrXTtcbiAgICAgIH1cblxuICAgICAgaWYoIXRva2VuLmNvbXBpbGVkKXtcbiAgICAgICAgdG9rZW4uY29tcGlsZWQgPSB0cnVlO1xuICAgICAgICB0b2tlbi5zaWduID0gJyc7XG4gICAgICAgIHRva2VuLnplcm9QYWQgPSBmYWxzZTtcbiAgICAgICAgdG9rZW4ucmlnaHRKdXN0aWZ5ID0gZmFsc2U7XG4gICAgICAgIHRva2VuLmFsdGVybmF0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGZsYWdzID0ge307XG4gICAgICAgIGZvcih2YXIgZmkgPSB0b2tlbi5mbGFncy5sZW5ndGg7IGZpLS07KXtcbiAgICAgICAgICB2YXIgZmxhZyA9IHRva2VuLmZsYWdzLmNoYXJBdChmaSk7XG4gICAgICAgICAgZmxhZ3NbZmxhZ10gPSB0cnVlO1xuICAgICAgICAgIHN3aXRjaChmbGFnKXtcbiAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICB0b2tlbi5zaWduID0gJyAnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICB0b2tlbi5zaWduID0gJysnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgICB0b2tlbi56ZXJvUGFkID0gKGZsYWdzWyctJ10pID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICB0b2tlbi5yaWdodEp1c3RpZnkgPSB0cnVlO1xuICAgICAgICAgICAgICB0b2tlbi56ZXJvUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgIHRva2VuLmFsdGVybmF0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcignYmFkIGZvcm1hdHRpbmcgZmxhZyBcXCcnICsgdG9rZW4uZmxhZ3MuY2hhckF0KGZpKSArICdcXCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbi5taW5XaWR0aCA9ICh0b2tlbi5fbWluV2lkdGgpID8gcGFyc2VJbnQodG9rZW4uX21pbldpZHRoKSA6IDA7XG4gICAgICAgIHRva2VuLm1heFdpZHRoID0gLTE7XG4gICAgICAgIHRva2VuLnRvVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgdG9rZW4uaXNVbnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB0b2tlbi5pc0ludCA9IGZhbHNlO1xuICAgICAgICB0b2tlbi5pc0RvdWJsZSA9IGZhbHNlO1xuICAgICAgICB0b2tlbi5pc09iamVjdCA9IGZhbHNlO1xuICAgICAgICB0b2tlbi5wcmVjaXNpb24gPSAxO1xuICAgICAgICBpZih0b2tlbi5wZXJpb2QgPT0gJy4nKXtcbiAgICAgICAgICBpZih0b2tlbi5fcHJlY2lzaW9uKXtcbiAgICAgICAgICAgIHRva2VuLnByZWNpc2lvbiA9IHBhcnNlSW50KHRva2VuLl9wcmVjaXNpb24pO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdG9rZW4ucHJlY2lzaW9uID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWl4aW5zID0gdGhpcy5fc3BlY2lmaWVyc1t0b2tlbi5zcGVjaWZpZXJdO1xuICAgICAgICBpZih0eXBlb2YgbWl4aW5zID09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc3BlY2lmaWVyIFxcJycgKyB0b2tlbi5zcGVjaWZpZXIgKyAnXFwnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWl4aW5zLmV4dGVuZCl7XG4gICAgICAgICAgdmFyIHMgPSB0aGlzLl9zcGVjaWZpZXJzW21peGlucy5leHRlbmRdO1xuICAgICAgICAgIGZvcih2YXIgayBpbiBzKXtcbiAgICAgICAgICAgIG1peGluc1trXSA9IHNba11cbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIG1peGlucy5leHRlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBsIGluIG1peGlucyl7XG4gICAgICAgICAgdG9rZW5bbF0gPSBtaXhpbnNbbF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodHlwZW9mIHRva2VuLnNldEFyZyA9PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgdG9rZW4uc2V0QXJnKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgaWYodHlwZW9mIHRva2VuLnNldE1heFdpZHRoID09ICdmdW5jdGlvbicpe1xuICAgICAgICB0b2tlbi5zZXRNYXhXaWR0aCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGlmKHRva2VuLl9taW5XaWR0aCA9PSAnKicpe1xuICAgICAgICBpZih0aGlzLl9tYXBwZWQpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignKiB3aWR0aCBub3Qgc3VwcG9ydGVkIGluIG1hcHBlZCBmb3JtYXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4ubWluV2lkdGggPSBwYXJzZUludChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgICBpZihpc05hTih0b2tlbi5taW5XaWR0aCkpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGFyZ3VtZW50IGZvciAqIHdpZHRoIGF0IHBvc2l0aW9uICcgKyBwb3NpdGlvbiArICcgaXMgbm90IGEgbnVtYmVyIGluICcgKyB0aGlzLl9mb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZ2F0aXZlIHdpZHRoIG1lYW5zIHJpZ2h0SnVzdGlmeVxuICAgICAgICBpZiAodG9rZW4ubWluV2lkdGggPCAwKSB7XG4gICAgICAgICAgdG9rZW4ucmlnaHRKdXN0aWZ5ID0gdHJ1ZTtcbiAgICAgICAgICB0b2tlbi5taW5XaWR0aCA9IC10b2tlbi5taW5XaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZih0b2tlbi5fcHJlY2lzaW9uID09ICcqJyAmJiB0b2tlbi5wZXJpb2QgPT0gJy4nKXtcbiAgICAgICAgaWYodGhpcy5fbWFwcGVkKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyogcHJlY2lzaW9uIG5vdCBzdXBwb3J0ZWQgaW4gbWFwcGVkIGZvcm1hdHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbi5wcmVjaXNpb24gPSBwYXJzZUludChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgICBpZihpc05hTih0b2tlbi5wcmVjaXNpb24pKXtcbiAgICAgICAgICB0aHJvdyBFcnJvcigndGhlIGFyZ3VtZW50IGZvciAqIHByZWNpc2lvbiBhdCBwb3NpdGlvbiAnICsgcG9zaXRpb24gKyAnIGlzIG5vdCBhIG51bWJlciBpbiAnICsgdGhpcy5fZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWdhdGl2ZSBwcmVjaXNpb24gbWVhbnMgdW5zcGVjaWZpZWRcbiAgICAgICAgaWYgKHRva2VuLnByZWNpc2lvbiA8IDApIHtcbiAgICAgICAgICB0b2tlbi5wcmVjaXNpb24gPSAxO1xuICAgICAgICAgIHRva2VuLnBlcmlvZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZih0b2tlbi5pc0ludCl7XG4gICAgICAgIC8vIGEgc3BlY2lmaWVkIHByZWNpc2lvbiBtZWFucyBubyB6ZXJvIHBhZGRpbmdcbiAgICAgICAgaWYodG9rZW4ucGVyaW9kID09ICcuJyl7XG4gICAgICAgICAgdG9rZW4uemVyb1BhZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9ybWF0SW50KHRva2VuKTtcbiAgICAgIH1lbHNlIGlmKHRva2VuLmlzRG91YmxlKXtcbiAgICAgICAgaWYodG9rZW4ucGVyaW9kICE9ICcuJyl7XG4gICAgICAgICAgdG9rZW4ucHJlY2lzaW9uID0gNjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcm1hdERvdWJsZSh0b2tlbik7IFxuICAgICAgfWVsc2UgaWYodG9rZW4uaXNPYmplY3Qpe1xuICAgICAgICB0aGlzLmZvcm1hdE9iamVjdCh0b2tlbik7XG4gICAgICB9XG4gICAgICB0aGlzLmZpdEZpZWxkKHRva2VuKTtcblxuICAgICAgc3RyICs9ICcnICsgdG9rZW4uYXJnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuRm9ybWF0dGVyLnByb3RvdHlwZS5femVyb3MxMCA9ICcwMDAwMDAwMDAwJztcbkZvcm1hdHRlci5wcm90b3R5cGUuX3NwYWNlczEwID0gJyAgICAgICAgICAnO1xuRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXRJbnQgPSBmdW5jdGlvbih0b2tlbikge1xuICB2YXIgaSA9IHBhcnNlSW50KHRva2VuLmFyZyk7XG4gIGlmKCFpc0Zpbml0ZShpKSl7IC8vIGlzTmFOKGYpIHx8IGYgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IGYgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxuICAgIC8vIGFsbG93IHRoaXMgb25seSBpZiBhcmcgaXMgbnVtYmVyXG4gICAgaWYodHlwZW9mIHRva2VuLmFyZyAhPSAnbnVtYmVyJyl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBhcmd1bWVudCBcXCcnICsgdG9rZW4uYXJnICsgJ1xcJyBub3QgYW4gaW50ZWdlcjsgcGFyc2VJbnQgcmV0dXJuZWQgJyArIGkpO1xuICAgIH1cbiAgICAvL3JldHVybiAnJyArIGk7XG4gICAgaSA9IDA7XG4gIH1cblxuICAvLyBpZiBub3QgYmFzZSAxMCwgbWFrZSBuZWdhdGl2ZXMgYmUgcG9zaXRpdmVcbiAgLy8gb3RoZXJ3aXNlLCAoLTEwKS50b1N0cmluZygxNikgaXMgJy1hJyBpbnN0ZWFkIG9mICdmZmZmZmZmNidcbiAgaWYoaSA8IDAgJiYgKHRva2VuLmlzVW5zaWduZWQgfHwgdG9rZW4uYmFzZSAhPSAxMCkpe1xuICAgIGkgPSAweGZmZmZmZmZmICsgaSArIDE7XG4gIH0gXG5cbiAgaWYoaSA8IDApe1xuICAgIHRva2VuLmFyZyA9ICgtIGkpLnRvU3RyaW5nKHRva2VuLmJhc2UpO1xuICAgIHRoaXMuemVyb1BhZCh0b2tlbik7XG4gICAgdG9rZW4uYXJnID0gJy0nICsgdG9rZW4uYXJnO1xuICB9ZWxzZXtcbiAgICB0b2tlbi5hcmcgPSBpLnRvU3RyaW5nKHRva2VuLmJhc2UpO1xuICAgIC8vIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYXJndW1lbnQgMCB3aXRoIHByZWNpc2lvbj09MCBpcyBmb3JtYXR0ZWQgYXMgJydcbiAgICBpZighaSAmJiAhdG9rZW4ucHJlY2lzaW9uKXtcbiAgICAgIHRva2VuLmFyZyA9ICcnO1xuICAgIH1lbHNle1xuICAgICAgdGhpcy56ZXJvUGFkKHRva2VuKTtcbiAgICB9XG4gICAgaWYodG9rZW4uc2lnbil7XG4gICAgICB0b2tlbi5hcmcgPSB0b2tlbi5zaWduICsgdG9rZW4uYXJnO1xuICAgIH1cbiAgfVxuICBpZih0b2tlbi5iYXNlID09IDE2KXtcbiAgICBpZih0b2tlbi5hbHRlcm5hdGl2ZSl7XG4gICAgICB0b2tlbi5hcmcgPSAnMHgnICsgdG9rZW4uYXJnO1xuICAgIH1cbiAgICB0b2tlbi5hcmcgPSB0b2tlbi50b1VwcGVyID8gdG9rZW4uYXJnLnRvVXBwZXJDYXNlKCkgOiB0b2tlbi5hcmcudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBpZih0b2tlbi5iYXNlID09IDgpe1xuICAgIGlmKHRva2VuLmFsdGVybmF0aXZlICYmIHRva2VuLmFyZy5jaGFyQXQoMCkgIT0gJzAnKXtcbiAgICAgIHRva2VuLmFyZyA9ICcwJyArIHRva2VuLmFyZztcbiAgICB9XG4gIH1cbn07XG5Gb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdERvdWJsZSA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIHZhciBmID0gcGFyc2VGbG9hdCh0b2tlbi5hcmcpO1xuICBpZighaXNGaW5pdGUoZikpeyAvLyBpc05hTihmKSB8fCBmID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCBmID09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSlcbiAgICAvLyBhbGxvdyB0aGlzIG9ubHkgaWYgYXJnIGlzIG51bWJlclxuICAgIGlmKHR5cGVvZiB0b2tlbi5hcmcgIT0gJ251bWJlcicpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgYXJndW1lbnQgXFwnJyArIHRva2VuLmFyZyArICdcXCcgbm90IGEgZmxvYXQ7IHBhcnNlRmxvYXQgcmV0dXJuZWQgJyArIGYpO1xuICAgIH1cbiAgICAvLyBDOTkgc2F5cyB0aGF0IGZvciAnZic6XG4gICAgLy8gICBpbmZpbml0eSAtPiAnWy1daW5mJyBvciAnWy1daW5maW5pdHknICgnWy1dSU5GJyBvciAnWy1dSU5GSU5JVFknIGZvciAnRicpXG4gICAgLy8gICBOYU4gLT4gYSBzdHJpbmcgIHN0YXJ0aW5nIHdpdGggJ25hbicgKCdOQU4nIGZvciAnRicpXG4gICAgLy8gdGhpcyBpcyBub3QgY29tbW9ubHkgaW1wbGVtZW50ZWQgdGhvdWdoLlxuICAgIC8vcmV0dXJuICcnICsgZjtcbiAgICBmID0gMDtcbiAgfVxuXG4gIHN3aXRjaCh0b2tlbi5kb3VibGVOb3RhdGlvbikge1xuICAgIGNhc2UgJ2UnOiB7XG4gICAgICB0b2tlbi5hcmcgPSBmLnRvRXhwb25lbnRpYWwodG9rZW4ucHJlY2lzaW9uKTsgXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnZic6IHtcbiAgICAgIHRva2VuLmFyZyA9IGYudG9GaXhlZCh0b2tlbi5wcmVjaXNpb24pOyBcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdnJzoge1xuICAgICAgLy8gQyBzYXlzIHVzZSAnZScgbm90YXRpb24gaWYgZXhwb25lbnQgaXMgPCAtNCBvciBpcyA+PSBwcmVjXG4gICAgICAvLyBFQ01BU2NyaXB0IGZvciB0b1ByZWNpc2lvbiBzYXlzIHVzZSBleHBvbmVudGlhbCBub3RhdGlvbiBpZiBleHBvbmVudCBpcyA+PSBwcmVjLFxuICAgICAgLy8gdGhvdWdoIHN0ZXAgMTcgb2YgdG9QcmVjaXNpb24gaW5kaWNhdGVzIGEgdGVzdCBmb3IgPCAtNiB0byBmb3JjZSBleHBvbmVudGlhbC5cbiAgICAgIGlmKE1hdGguYWJzKGYpIDwgMC4wMDAxKXtcbiAgICAgICAgLy9wcmludCgnZm9yY2luZyBleHBvbmVudGlhbCBub3RhdGlvbiBmb3IgZj0nICsgZik7XG4gICAgICAgIHRva2VuLmFyZyA9IGYudG9FeHBvbmVudGlhbCh0b2tlbi5wcmVjaXNpb24gPiAwID8gdG9rZW4ucHJlY2lzaW9uIC0gMSA6IHRva2VuLnByZWNpc2lvbik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdG9rZW4uYXJnID0gZi50b1ByZWNpc2lvbih0b2tlbi5wcmVjaXNpb24pOyBcbiAgICAgIH1cblxuICAgICAgLy8gSW4gQywgdW5saWtlICdmJywgJ2dHJyByZW1vdmVzIHRyYWlsaW5nIDBzIGZyb20gZnJhY3Rpb25hbCBwYXJ0LCB1bmxlc3MgYWx0ZXJuYXRpdmUgZm9ybWF0IGZsYWcgKCcjJykuXG4gICAgICAvLyBCdXQgRUNNQVNjcmlwdCBmb3JtYXRzIHRvUHJlY2lzaW9uIGFzIDAuMDAxMDAwMDAuIFNvIHJlbW92ZSB0cmFpbGluZyAwcy5cbiAgICAgIGlmKCF0b2tlbi5hbHRlcm5hdGl2ZSl7IFxuICAgICAgICAvL3ByaW50KCdyZXBsYWNpbmcgdHJhaWxpbmcgMCBpbiBcXCcnICsgcyArICdcXCcnKTtcbiAgICAgICAgdG9rZW4uYXJnID0gdG9rZW4uYXJnLnJlcGxhY2UoLyhcXC4uKlteMF0pMCplLywgJyQxZScpO1xuICAgICAgICAvLyBpZiBmcmFjdGlvbmFsIHBhcnQgaXMgZW50aXJlbHkgMCwgcmVtb3ZlIGl0IGFuZCBkZWNpbWFsIHBvaW50XG4gICAgICAgIHRva2VuLmFyZyA9IHRva2VuLmFyZy5yZXBsYWNlKC9cXC4wKmUvLCAnZScpLnJlcGxhY2UoL1xcLjAkLywnJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGRvdWJsZSBub3RhdGlvbiBcXCcnICsgdG9rZW4uZG91YmxlTm90YXRpb24gKyAnXFwnJyk7XG4gIH1cblxuICAvLyBDIHNheXMgdGhhdCBleHBvbmVudCBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgLy8gQnV0IEVDTUFTY3JpcHQgZG9lcyBub3Q7IHRvRXhwb25lbnRpYWwgcmVzdWx0cyBpbiB0aGluZ3MgbGlrZSAnMS4wMDAwMDBlLTgnIGFuZCAnMS4wMDAwMDBlKzgnLlxuICAvLyBOb3RlIHRoYXQgcy5yZXBsYWNlKC9lKFtcXCtcXC1dKShcXGQpLywgJ2UkMTAkMicpIHdvbid0IHdvcmsgYmVjYXVzZSBvZiB0aGUgJyQxMCcgaW5zdGVhZCBvZiAnJDEnLlxuICAvLyBBbmQgcmVwbGFjZShyZSwgZnVuYykgaXNuJ3Qgc3VwcG9ydGVkIG9uIElFNTAgb3IgU2FmYXJpMS5cbiAgdG9rZW4uYXJnID0gdG9rZW4uYXJnLnJlcGxhY2UoL2VcXCsoXFxkKSQvLCAnZSswJDEnKS5yZXBsYWNlKC9lXFwtKFxcZCkkLywgJ2UtMCQxJyk7XG5cbiAgLy8gaWYgYWx0LCBlbnN1cmUgYSBkZWNpbWFsIHBvaW50XG4gIGlmKHRva2VuLmFsdGVybmF0aXZlKXtcbiAgICB0b2tlbi5hcmcgPSB0b2tlbi5hcmcucmVwbGFjZSgvXihcXGQrKSQvLCckMS4nKTtcbiAgICB0b2tlbi5hcmcgPSB0b2tlbi5hcmcucmVwbGFjZSgvXihcXGQrKWUvLCckMS5lJyk7XG4gIH1cblxuICBpZihmID49IDAgJiYgdG9rZW4uc2lnbil7XG4gICAgdG9rZW4uYXJnID0gdG9rZW4uc2lnbiArIHRva2VuLmFyZztcbiAgfVxuXG4gIHRva2VuLmFyZyA9IHRva2VuLnRvVXBwZXIgPyB0b2tlbi5hcmcudG9VcHBlckNhc2UoKSA6IHRva2VuLmFyZy50b0xvd2VyQ2FzZSgpO1xufTtcbkZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0T2JqZWN0ID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgLy8gSWYgbm8gcHJlY2lzaW9uIGlzIHNwZWNpZmllZCwgdGhlbiByZXNldCBpdCB0byBudWxsIChpbmZpbml0ZSBkZXB0aCkuXG4gIHZhciBwcmVjaXNpb24gPSAodG9rZW4ucGVyaW9kID09PSAnLicpID8gdG9rZW4ucHJlY2lzaW9uIDogbnVsbDtcbiAgdG9rZW4uYXJnID0gdXRpbC5pbnNwZWN0KHRva2VuLmFyZywgIXRva2VuLmFsdGVybmF0aXZlLCBwcmVjaXNpb24pO1xufTtcbkZvcm1hdHRlci5wcm90b3R5cGUuemVyb1BhZCA9IGZ1bmN0aW9uKHRva2VuLCAvKkludCovIGxlbmd0aCkge1xuICBsZW5ndGggPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSA/IGxlbmd0aCA6IHRva2VuLnByZWNpc2lvbjtcbiAgdmFyIG5lZ2F0aXZlID0gZmFsc2U7XG4gIGlmKHR5cGVvZiB0b2tlbi5hcmcgIT0gXCJzdHJpbmdcIil7XG4gICAgdG9rZW4uYXJnID0gXCJcIiArIHRva2VuLmFyZztcbiAgfVxuICBpZiAodG9rZW4uYXJnLnN1YnN0cigwLDEpID09PSAnLScpIHtcbiAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgdG9rZW4uYXJnID0gdG9rZW4uYXJnLnN1YnN0cigxKTtcbiAgfVxuXG4gIHZhciB0ZW5sZXNzID0gbGVuZ3RoIC0gMTA7XG4gIHdoaWxlKHRva2VuLmFyZy5sZW5ndGggPCB0ZW5sZXNzKXtcbiAgICB0b2tlbi5hcmcgPSAodG9rZW4ucmlnaHRKdXN0aWZ5KSA/IHRva2VuLmFyZyArIHRoaXMuX3plcm9zMTAgOiB0aGlzLl96ZXJvczEwICsgdG9rZW4uYXJnO1xuICB9XG4gIHZhciBwYWQgPSBsZW5ndGggLSB0b2tlbi5hcmcubGVuZ3RoO1xuICB0b2tlbi5hcmcgPSAodG9rZW4ucmlnaHRKdXN0aWZ5KSA/IHRva2VuLmFyZyArIHRoaXMuX3plcm9zMTAuc3Vic3RyaW5nKDAsIHBhZCkgOiB0aGlzLl96ZXJvczEwLnN1YnN0cmluZygwLCBwYWQpICsgdG9rZW4uYXJnO1xuICBpZiAobmVnYXRpdmUpIHRva2VuLmFyZyA9ICctJyArIHRva2VuLmFyZztcbn07XG5Gb3JtYXR0ZXIucHJvdG90eXBlLmZpdEZpZWxkID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgaWYodG9rZW4ubWF4V2lkdGggPj0gMCAmJiB0b2tlbi5hcmcubGVuZ3RoID4gdG9rZW4ubWF4V2lkdGgpe1xuICAgIHJldHVybiB0b2tlbi5hcmcuc3Vic3RyaW5nKDAsIHRva2VuLm1heFdpZHRoKTtcbiAgfVxuICBpZih0b2tlbi56ZXJvUGFkKXtcbiAgICB0aGlzLnplcm9QYWQodG9rZW4sIHRva2VuLm1pbldpZHRoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5zcGFjZVBhZCh0b2tlbik7XG59O1xuRm9ybWF0dGVyLnByb3RvdHlwZS5zcGFjZVBhZCA9IGZ1bmN0aW9uKHRva2VuLCAvKkludCovIGxlbmd0aCkge1xuICBsZW5ndGggPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSA/IGxlbmd0aCA6IHRva2VuLm1pbldpZHRoO1xuICBpZih0eXBlb2YgdG9rZW4uYXJnICE9ICdzdHJpbmcnKXtcbiAgICB0b2tlbi5hcmcgPSAnJyArIHRva2VuLmFyZztcbiAgfVxuICB2YXIgdGVubGVzcyA9IGxlbmd0aCAtIDEwO1xuICB3aGlsZSh0b2tlbi5hcmcubGVuZ3RoIDwgdGVubGVzcyl7XG4gICAgdG9rZW4uYXJnID0gKHRva2VuLnJpZ2h0SnVzdGlmeSkgPyB0b2tlbi5hcmcgKyB0aGlzLl9zcGFjZXMxMCA6IHRoaXMuX3NwYWNlczEwICsgdG9rZW4uYXJnO1xuICB9XG4gIHZhciBwYWQgPSBsZW5ndGggLSB0b2tlbi5hcmcubGVuZ3RoO1xuICB0b2tlbi5hcmcgPSAodG9rZW4ucmlnaHRKdXN0aWZ5KSA/IHRva2VuLmFyZyArIHRoaXMuX3NwYWNlczEwLnN1YnN0cmluZygwLCBwYWQpIDogdGhpcy5fc3BhY2VzMTAuc3Vic3RyaW5nKDAsIHBhZCkgKyB0b2tlbi5hcmc7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIHN0cmVhbSwgZm9ybWF0O1xuICBpZihhcmdzWzBdIGluc3RhbmNlb2YgcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtKXtcbiAgICBzdHJlYW0gPSBhcmdzLnNoaWZ0KCk7XG4gIH1cbiAgZm9ybWF0ID0gYXJncy5zaGlmdCgpO1xuICB2YXIgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihmb3JtYXQpO1xuICB2YXIgc3RyaW5nID0gZm9ybWF0dGVyLmZvcm1hdC5hcHBseShmb3JtYXR0ZXIsIGFyZ3MpO1xuICBpZihzdHJlYW0pe1xuICAgIHN0cmVhbS53cml0ZShzdHJpbmcpO1xuICB9ZWxzZXtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Gb3JtYXR0ZXIgPSBGb3JtYXR0ZXI7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnSW52YXJpYW50IFZpb2xhdGlvbjogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5TWlycm9yXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopLFxuICAgICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJ1xuICApIDogaW52YXJpYW50KG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSk7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7XG4iLCJjb25zdCBrZXlNaXJyb3IgPSByZXF1aXJlKCdyZWFjdC9saWIva2V5TWlycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yKHtcbiAgICBNSVNTSU9OX1NUQVJURUQgOiBudWxsLFxuICAgIE1JU1NJT05fU1RPUFBFRCA6IG51bGwsXG4gICAgTUlTU0lPTl9SRVNFVCA6IG51bGwsXG4gICAgTUlTU0lPTl9DT01QTEVURUQgOiBudWxsLFxuICAgIEFQUF9TVEFURSA6IG51bGwsXG5cbiAgICBBRERfTUVTU0FHRSA6IG51bGwsXG5cbiAgICAvL0FDVElPTlNcbiAgICBHRVRfRVZFTlRTIDogbnVsbCxcbiAgICBTRVRfRVZFTlRTIDogbnVsbCxcbiAgICBUUklHR0VSX0VWRU5UIDogbnVsbCxcbiAgICBBRFZBTkNFX0NIQVBURVIgOiBudWxsLFxuICAgIENPTVBMRVRFX01JU1NJT04gOiBudWxsLFxuXG4gICAgLy8gU0NJRU5DRSBURUFNIEVWRU5UU1xuICAgIFNDSUVOQ0VfQ0hFQ0tfUkFESUFUSU9OIDogbnVsbCxcblxuICAgIC8vIEFTVFJPTkFVVCBURUFNIEVWRU5UU1xuICAgIEFTVF9DSEVDS19WSVRBTFMgOiBudWxsLFxuXG4gICAgLy8gQ09NTVVOSUNBVElPTiBURUFNIEVWRU5UU1xuICAgIENPTU1fSU5GT1JNX0FTVFJPTkFVVCA6IG51bGwsXG4gICAgQ09NTV9DSEVDS19TQVRfTElOSzogbnVsbCxcblxuXG4gICAgLy8gU0VDVVJJVFkgVEVBTSBFVkVOVFNcbiAgICBTRVRfSElHSF9DMDIgOiBudWxsLFxuICAgIFNFQ1VSSVRZX0NIRUNLX0RBVEFfVFJBTlNGRVIgOiBudWxsLFxuXG5cbiAgICBTRVRfSEVBUlRfUkFURV9ISUdIIDogbnVsbCxcbiAgICBTRVRfSEVBUlRfUkFURV9NRURJVU0gOiBudWxsLFxuICAgIFNFVF9IRUFSVF9SQVRFX0xPVyA6IG51bGxcbn0pO1xuIl19
